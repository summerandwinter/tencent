/*!
 * thumbplayer-h5
 *   Update Date: 2025-12-15 20:00:20
 *   Author: thumbplayer-h5 team
 *   ---
 *   Copyright (c) 2025 Tencent
 * https://vm.gtimg.cn/thumbplayer/core/1.57.5/txhlsjs-kernel.js?max_age=7776000
 */
!function() {
    var e = {
        291: function(e) {
            "undefined" != typeof window && (e.exports = function(e) {
                var t = {};
                function r(i) {
                    if (t[i])
                        return t[i].exports;
                    var n = t[i] = {
                        i: i,
                        l: !1,
                        exports: {}
                    };
                    return e[i].call(n.exports, n, n.exports, r),
                    n.l = !0,
                    n.exports
                }
                return r.m = e,
                r.c = t,
                r.d = function(e, t, i) {
                    r.o(e, t) || Object.defineProperty(e, t, {
                        enumerable: !0,
                        get: i
                    })
                }
                ,
                r.r = function(e) {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                        value: "Module"
                    }),
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }
                ,
                r.t = function(e, t) {
                    if (1 & t && (e = r(e)),
                    8 & t)
                        return e;
                    if (4 & t && "object" == typeof e && e && e.__esModule)
                        return e;
                    var i = Object.create(null);
                    if (r.r(i),
                    Object.defineProperty(i, "default", {
                        enumerable: !0,
                        value: e
                    }),
                    2 & t && "string" != typeof e)
                        for (var n in e)
                            r.d(i, n, function(t) {
                                return e[t]
                            }
                            .bind(null, n));
                    return i
                }
                ,
                r.n = function(e) {
                    var t = e && e.__esModule ? function() {
                        return e.default
                    }
                    : function() {
                        return e
                    }
                    ;
                    return r.d(t, "a", t),
                    t
                }
                ,
                r.o = function(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }
                ,
                r.p = "/dist/",
                r(r.s = 37)
            }([function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return i
                }
                ));
                var i = function(e) {
                    return e.MEDIA_ATTACHING = "hlsMediaAttaching",
                    e.MEDIA_ATTACHED = "hlsMediaAttached",
                    e.MEDIA_DETACHING = "hlsMediaDetaching",
                    e.MEDIA_DETACHED = "hlsMediaDetached",
                    e.BUFFER_RESET = "hlsBufferReset",
                    e.BUFFER_CODECS = "hlsBufferCodecs",
                    e.BUFFER_CREATED = "hlsBufferCreated",
                    e.BUFFER_APPENDING = "hlsBufferAppending",
                    e.BUFFER_APPENDED = "hlsBufferAppended",
                    e.BUFFER_EOS = "hlsBufferEos",
                    e.BUFFER_FLUSHING = "hlsBufferFlushing",
                    e.BUFFER_FLUSHED = "hlsBufferFlushed",
                    e.MANIFEST_LOADING = "hlsManifestLoading",
                    e.M3U8_DIRECT_LOAD = "hlsM3u8DirectLoad",
                    e.MANIFEST_LOADED = "hlsManifestLoaded",
                    e.MANIFEST_PARSED = "hlsManifestParsed",
                    e.LEVEL_SWITCHING = "hlsLevelSwitching",
                    e.LEVEL_SWITCHED = "hlsLevelSwitched",
                    e.LEVEL_LOADING = "hlsLevelLoading",
                    e.LEVEL_LOADED = "hlsLevelLoaded",
                    e.LEVEL_UPDATED = "hlsLevelUpdated",
                    e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated",
                    e.LEVELS_UPDATED = "hlsLevelsUpdated",
                    e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated",
                    e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching",
                    e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched",
                    e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading",
                    e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded",
                    e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated",
                    e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared",
                    e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch",
                    e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading",
                    e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded",
                    e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed",
                    e.CUES_PARSED = "hlsCuesParsed",
                    e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound",
                    e.INIT_PTS_FOUND = "hlsInitPtsFound",
                    e.FRAG_LOADING = "hlsFragLoading",
                    e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted",
                    e.FRAG_LOADED = "hlsFragLoaded",
                    e.FRAG_DECRYPTED = "hlsFragDecrypted",
                    e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment",
                    e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata",
                    e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata",
                    e.FRAG_PARSED = "hlsFragParsed",
                    e.FRAG_BUFFERED = "hlsFragBuffered",
                    e.FRAG_CHANGED = "hlsFragChanged",
                    e.FPS_DROP = "hlsFpsDrop",
                    e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping",
                    e.ERROR = "hlsError",
                    e.DESTROYING = "hlsDestroying",
                    e.KEY_LOADING = "hlsKeyLoading",
                    e.KEY_LOADED = "hlsKeyLoaded",
                    e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached",
                    e.BACK_BUFFER_REACHED = "hlsBackBufferReached",
                    e
                }({})
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return s
                }
                )),
                r.d(t, "b", (function() {
                    return l
                }
                ));
                var i = function() {}
                  , n = {
                    trace: i,
                    debug: i,
                    log: i,
                    warn: i,
                    info: i,
                    error: i
                }
                  , a = n;
                function o(e) {
                    var t = self.console[e];
                    return t ? t.bind(self.console, "[" + e + "] >") : i
                }
                function s(e) {
                    if (self.console && !0 === e || "[object Object]" === Object.prototype.toString.call(e)) {
                        !function(e) {
                            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
                                r[i - 1] = arguments[i];
                            r.forEach((function(t) {
                                a[t] = e[t] ? e[t].bind(e) : o(t)
                            }
                            ))
                        }(e, "debug", "log", "info", "warn", "error");
                        try {
                            a.log()
                        } catch (e) {
                            a = n
                        }
                    } else
                        a = n
                }
                var l = n
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "b", (function() {
                    return i
                }
                )),
                r.d(t, "a", (function() {
                    return n
                }
                ));
                var i = function(e) {
                    return e.NETWORK_ERROR = "networkError",
                    e.MEDIA_ERROR = "mediaError",
                    e.KEY_SYSTEM_ERROR = "keySystemError",
                    e.MUX_ERROR = "muxError",
                    e.OTHER_ERROR = "otherError",
                    e.FRAG_DECRYPT_ERROR = "fragDecryptError",
                    e
                }({})
                  , n = function(e) {
                    return e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys",
                    e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess",
                    e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession",
                    e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed",
                    e.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData",
                    e.MANIFEST_LOAD_ERROR = "manifestLoadError",
                    e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut",
                    e.MANIFEST_PARSING_ERROR = "manifestParsingError",
                    e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError",
                    e.LEVEL_EMPTY_ERROR = "levelEmptyError",
                    e.LEVEL_LOAD_ERROR = "levelLoadError",
                    e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut",
                    e.LEVEL_SWITCH_ERROR = "levelSwitchError",
                    e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError",
                    e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut",
                    e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError",
                    e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut",
                    e.FRAG_LOAD_ERROR = "fragLoadError",
                    e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut",
                    e.FRAG_DECRYPT_ERROR = "fragDecryptError",
                    e.FRAG_PARSING_ERROR = "fragParsingError",
                    e.REMUX_ALLOC_ERROR = "remuxAllocError",
                    e.KEY_LOAD_ERROR = "keyLoadError",
                    e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut",
                    e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError",
                    e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError",
                    e.BUFFER_APPEND_ERROR = "bufferAppendError",
                    e.BUFFER_APPENDING_ERROR = "bufferAppendingError",
                    e.BUFFER_STALLED_ERROR = "bufferStalledError",
                    e.BUFFER_FULL_ERROR = "bufferFullError",
                    e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole",
                    e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall",
                    e.INTERNAL_EXCEPTION = "internalException",
                    e.INTERNAL_ABORTED = "aborted",
                    e.UNKNOWN = "unknown",
                    e
                }({})
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return i
                }
                ));
                var i = Number.isFinite || function(e) {
                    return "number" == typeof e && isFinite(e)
                }
                ;
                Number.MAX_SAFE_INTEGER
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return i
                }
                )),
                r.d(t, "b", (function() {
                    return n
                }
                ));
                var i = function(e) {
                    return e.MANIFEST = "manifest",
                    e.LEVEL = "level",
                    e.AUDIO_TRACK = "audioTrack",
                    e.SUBTITLE_TRACK = "subtitleTrack",
                    e
                }({})
                  , n = function(e) {
                    return e.MAIN = "main",
                    e.AUDIO = "audio",
                    e.SUBTITLE = "subtitle",
                    e
                }({})
            }
            , function(e, t, r) {
                var i = r(28);
                function n(e, t) {
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        n.enumerable = n.enumerable || !1,
                        n.configurable = !0,
                        "value"in n && (n.writable = !0),
                        Object.defineProperty(e, i(n.key), n)
                    }
                }
                e.exports = function(e, t, r) {
                    return t && n(e.prototype, t),
                    r && n(e, r),
                    Object.defineProperty(e, "prototype", {
                        writable: !1
                    }),
                    e
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return d
                }
                )),
                r.d(t, "b", (function() {
                    return p
                }
                )),
                r.d(t, "c", (function() {
                    return g
                }
                ));
                var i = r(3)
                  , n = r(8)
                  , a = r.n(n)
                  , o = r(5)
                  , s = r.n(o)
                  , l = r(15)
                  , c = r(1)
                  , h = r(23)
                  , u = r(17)
                  , d = function(e) {
                    return e.AUDIO = "audio",
                    e.VIDEO = "video",
                    e.AUDIOVIDEO = "audiovideo",
                    e
                }({})
                  , f = function() {
                    function e(e) {
                        var t;
                        this._byteRange = null,
                        this._url = null,
                        this.baseurl = void 0,
                        this.relurl = void 0,
                        this.elementaryStreams = ((t = {})[d.AUDIO] = null,
                        t[d.VIDEO] = null,
                        t[d.AUDIOVIDEO] = null,
                        t),
                        this.baseurl = e
                    }
                    return e.prototype.setByteRange = function(e, t) {
                        var r = e.split("@", 2)
                          , i = [];
                        1 === r.length ? i[0] = t ? t.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]),
                        i[1] = parseInt(r[0]) + i[0],
                        this._byteRange = i
                    }
                    ,
                    s()(e, [{
                        key: "byteRange",
                        get: function() {
                            return this._byteRange ? this._byteRange : []
                        }
                    }, {
                        key: "byteRangeStartOffset",
                        get: function() {
                            return this.byteRange[0]
                        }
                    }, {
                        key: "byteRangeEndOffset",
                        get: function() {
                            return this.byteRange[1]
                        }
                    }, {
                        key: "url",
                        get: function() {
                            return !this._url && this.baseurl && this.relurl && (this._url = Object(l.buildAbsoluteURL)(this.baseurl, this.relurl, {
                                alwaysNormalize: !0
                            })),
                            this._url || ""
                        },
                        set: function(e) {
                            this._url = e
                        }
                    }])
                }()
                  , p = function(e) {
                    function t(t, r) {
                        var i;
                        return (i = e.call(this, r) || this)._decryptdata = null,
                        i.rawProgramDateTime = null,
                        i.programDateTime = null,
                        i.tagList = [],
                        i.duration = 0,
                        i.sn = 0,
                        i.levelkey = void 0,
                        i.type = void 0,
                        i.loader = null,
                        i.level = -1,
                        i.cc = 0,
                        i.startPTS = void 0,
                        i.endPTS = void 0,
                        i.appendedPTS = void 0,
                        i.startDTS = void 0,
                        i.endDTS = void 0,
                        i.start = 0,
                        i.deltaPTS = void 0,
                        i.maxStartPTS = void 0,
                        i.minEndPTS = void 0,
                        i.stats = new u.a,
                        i.urlId = 0,
                        i.data = void 0,
                        i.bitrateTest = !1,
                        i.title = null,
                        i.initSegment = null,
                        i.ext = {},
                        i.type = t,
                        i
                    }
                    a()(t, e);
                    var r = t.prototype;
                    return r.createInitializationVector = function(e) {
                        for (var t = new Uint8Array(16), r = 12; r < 16; r++)
                            t[r] = e >> 8 * (15 - r) & 255;
                        return t
                    }
                    ,
                    r.setDecryptDataFromLevelKey = function(e, t) {
                        var r = e;
                        return "AES-128" === (null == e ? void 0 : e.method) && e.uri && !e.iv && ((r = h.a.fromURI(e.uri)).method = e.method,
                        r.iv = this.createInitializationVector(t),
                        r.keyFormat = "identity"),
                        r
                    }
                    ,
                    r.setElementaryStreamInfo = function(e, t, r, i, n, a) {
                        void 0 === a && (a = !1);
                        var o = this.elementaryStreams
                          , s = o[e];
                        s ? (s.startPTS = Math.min(s.startPTS, t),
                        s.endPTS = Math.max(s.endPTS, r),
                        s.startDTS = Math.min(s.startDTS, i),
                        s.endDTS = Math.max(s.endDTS, n)) : o[e] = {
                            startPTS: t,
                            endPTS: r,
                            startDTS: i,
                            endDTS: n,
                            partial: a
                        }
                    }
                    ,
                    r.clearElementaryStreamInfo = function() {
                        var e = this.elementaryStreams;
                        e[d.AUDIO] = null,
                        e[d.VIDEO] = null,
                        e[d.AUDIOVIDEO] = null
                    }
                    ,
                    s()(t, [{
                        key: "decryptdata",
                        get: function() {
                            if (!this.levelkey && !this._decryptdata)
                                return null;
                            if (!this._decryptdata && this.levelkey) {
                                var e = this.sn;
                                "number" != typeof e && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && c.b.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'),
                                e = 0),
                                this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e)
                            }
                            return this._decryptdata
                        }
                    }, {
                        key: "end",
                        get: function() {
                            return this.start + this.duration
                        }
                    }, {
                        key: "endProgramDateTime",
                        get: function() {
                            if (null === this.programDateTime)
                                return null;
                            if (!Object(i.a)(this.programDateTime))
                                return null;
                            var e = Object(i.a)(this.duration) ? this.duration : 0;
                            return this.programDateTime + 1e3 * e
                        }
                    }, {
                        key: "encrypted",
                        get: function() {
                            var e;
                            return !(null === (e = this.decryptdata) || void 0 === e || !e.keyFormat || !this.decryptdata.uri)
                        }
                    }])
                }(f)
                  , g = function(e) {
                    function t(t, r, i, n, a) {
                        var o;
                        (o = e.call(this, i) || this).fragOffset = 0,
                        o.duration = 0,
                        o.gap = !1,
                        o.independent = !1,
                        o.relurl = void 0,
                        o.fragment = void 0,
                        o.index = void 0,
                        o.stats = new u.a,
                        o.duration = t.decimalFloatingPoint("DURATION"),
                        o.gap = t.bool("GAP"),
                        o.independent = t.bool("INDEPENDENT"),
                        o.relurl = t.enumeratedString("URI"),
                        o.fragment = r,
                        o.index = n;
                        var s = t.enumeratedString("BYTERANGE");
                        return s && o.setByteRange(s, a),
                        a && (o.fragOffset = a.fragOffset + a.duration),
                        o
                    }
                    return a()(t, e),
                    s()(t, [{
                        key: "start",
                        get: function() {
                            return this.fragment.start + this.fragOffset
                        }
                    }, {
                        key: "end",
                        get: function() {
                            return this.start + this.duration
                        }
                    }, {
                        key: "loaded",
                        get: function() {
                            var e = this.elementaryStreams;
                            return !!(e.audio || e.video || e.audiovideo)
                        }
                    }])
                }(f)
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "b", (function() {
                    return d
                }
                )),
                r.d(t, "h", (function() {
                    return f
                }
                )),
                r.d(t, "f", (function() {
                    return p
                }
                )),
                r.d(t, "d", (function() {
                    return g
                }
                )),
                r.d(t, "c", (function() {
                    return v
                }
                )),
                r.d(t, "e", (function() {
                    return m
                }
                )),
                r.d(t, "i", (function() {
                    return T
                }
                )),
                r.d(t, "g", (function() {
                    return S
                }
                )),
                r.d(t, "a", (function() {
                    return I
                }
                ));
                var i = r(13)
                  , n = r(6)
                  , a = r(1)
                  , o = Math.pow(2, 32) - 1
                  , s = [].push;
                function l(e) {
                    return String.fromCharCode.apply(null, e)
                }
                function c(e, t) {
                    "data"in e && (t += e.start,
                    e = e.data);
                    var r = e[t] << 8 | e[t + 1];
                    return r < 0 ? 65536 + r : r
                }
                function h(e, t) {
                    "data"in e && (t += e.start,
                    e = e.data);
                    var r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
                    return r < 0 ? 4294967296 + r : r
                }
                function u(e, t, r) {
                    "data"in e && (t += e.start,
                    e = e.data),
                    e[t] = r >> 24,
                    e[t + 1] = r >> 16 & 255,
                    e[t + 2] = r >> 8 & 255,
                    e[t + 3] = 255 & r
                }
                function d(e, t) {
                    var r, i, n, a = [];
                    if (!t.length)
                        return a;
                    "data"in e ? (r = e.data,
                    i = e.start,
                    n = e.end) : (i = 0,
                    n = (r = e).byteLength);
                    for (var o = i; o < n; ) {
                        var c = h(r, o)
                          , u = c > 1 ? o + c : n;
                        if (l(r.subarray(o + 4, o + 8)) === t[0])
                            if (1 === t.length)
                                a.push({
                                    data: r,
                                    start: o + 8,
                                    end: u
                                });
                            else {
                                var f = d({
                                    data: r,
                                    start: o + 8,
                                    end: u
                                }, t.slice(1));
                                f.length && s.apply(a, f)
                            }
                        o = u
                    }
                    return a
                }
                function f(e) {
                    var t = d(e, ["moov"])[0]
                      , r = t ? t.end : null
                      , i = d(e, ["sidx"]);
                    if (!i || !i[0])
                        return null;
                    var n = []
                      , a = i[0]
                      , o = a.data[0]
                      , s = 0 === o ? 8 : 16
                      , l = h(a, s);
                    s += 4,
                    s += 0 === o ? 8 : 16,
                    s += 2;
                    var u = a.end + 0
                      , f = c(a, s);
                    s += 2;
                    for (var p = 0; p < f; p++) {
                        var g = s
                          , v = h(a, g);
                        g += 4;
                        var y = 2147483647 & v;
                        if (1 == (2147483648 & v) >>> 31)
                            return console.warn("SIDX has hierarchical references (not supported)"),
                            null;
                        var m = h(a, g);
                        g += 4,
                        n.push({
                            referenceSize: y,
                            subsegmentDuration: m,
                            info: {
                                duration: m / l,
                                start: u,
                                end: u + y - 1
                            }
                        }),
                        u += y,
                        s = g += 4
                    }
                    return {
                        earliestPresentationTime: 0,
                        timescale: l,
                        version: o,
                        referencesCount: f,
                        references: n,
                        moovEndOffset: r
                    }
                }
                function p(e) {
                    for (var t = [], r = d(e, ["moov", "trak"]), i = function() {
                        var e = r[a]
                          , i = d(e, ["tkhd"])[0];
                        if (i) {
                            var o = i.data[i.start]
                              , s = 0 === o ? 12 : 20
                              , c = h(i, s)
                              , u = d(e, ["mdia", "mdhd"])[0];
                            if (u) {
                                var f = h(u, s = 0 === (o = u.data[u.start]) ? 12 : 20)
                                  , p = d(e, ["mdia", "hdlr"])[0];
                                if (p) {
                                    var g = l(p.data.subarray(p.start + 8, p.start + 12))
                                      , v = {
                                        soun: n.a.AUDIO,
                                        vide: n.a.VIDEO
                                    }[g];
                                    if (v) {
                                        var y, m = d(e, ["mdia", "minf", "stbl", "stsd"])[0];
                                        if (m && ("enca" === (y = l(m.data.subarray(m.start + 12, m.start + 16))) || "encv" === y)) {
                                            var T = d(m.data.subarray(m.start + 8), [y])[0];
                                            d(T.data.subarray(T.start + ("enca" === y ? 28 : 78)), ["sinf"]).forEach((function(e) {
                                                var t = d(e, ["schm"])[0];
                                                if (t) {
                                                    var r = l(t.data.subarray(t.start + 4, t.start + 8));
                                                    if ("cbcs" === r || "cenc" === r) {
                                                        var i = d(e, ["frma"])[0];
                                                        i && (y = l(i.data.subarray(i.start, i.start + 4)))
                                                    }
                                                }
                                            }
                                            ))
                                        }
                                        t[c] = {
                                            timescale: f,
                                            type: v
                                        },
                                        t[v] = {
                                            timescale: f,
                                            id: c,
                                            codec: y
                                        }
                                    }
                                }
                            }
                        }
                    }, a = 0; a < r.length; a++)
                        i();
                    return d(e, ["moov", "mvex", "trex"]).forEach((function(e) {
                        var r = h(e, 4)
                          , i = t[r];
                        i && (i.default = {
                            duration: h(e, 12),
                            flags: h(e, 20)
                        })
                    }
                    )),
                    t
                }
                function g(e, t) {
                    return d(t, ["moof", "traf"]).reduce((function(t, r) {
                        var i = d(r, ["tfdt"])[0]
                          , n = i.data[i.start]
                          , a = d(r, ["tfhd"]).reduce((function(t, r) {
                            var a = h(r, 4)
                              , o = e[a];
                            if (o) {
                                var s = h(i, 4);
                                1 === n && (s *= Math.pow(2, 32),
                                s += h(i, 8));
                                var l = s / (o.timescale || 9e4);
                                if (isFinite(l) && (null === t || l < t))
                                    return l
                            }
                            return t
                        }
                        ), null);
                        return null !== a && isFinite(a) && (null === t || a < t) ? a : t
                    }
                    ), null) || 0
                }
                function v(e, t) {
                    for (var r = 0, i = 0, a = 0, o = d(e, ["moof", "traf"]), s = 0; s < o.length; s++) {
                        var l = o[s]
                          , c = d(l, ["tfhd"])[0]
                          , u = t[h(c, 4)];
                        if (u) {
                            var p = u.default
                              , g = h(c, 0) | (null == p ? void 0 : p.flags)
                              , v = null == p ? void 0 : p.duration;
                            8 & g && (v = h(c, 2 & g ? 12 : 8));
                            for (var m = u.timescale || 9e4, T = d(l, ["trun"]), S = 0; S < T.length; S++) {
                                var I = h(T[S], 0);
                                r = !v || 256 & I ? y(T[S]) : v * h(T[S], 4),
                                u.type === n.a.VIDEO ? i += r / m : u.type === n.a.AUDIO && (a += r / m)
                            }
                        }
                    }
                    if (0 === i && 0 === a) {
                        var P = f(e);
                        if (null != P && P.references)
                            return P.references.reduce((function(e, t) {
                                return e + t.info.duration || 0
                            }
                            ), 0)
                    }
                    return i || a
                }
                function y(e) {
                    var t = h(e, 0)
                      , r = 8;
                    1 & t && (r += 4),
                    4 & t && (r += 4);
                    for (var i = 0, n = h(e, 4), a = 0; a < n; a++)
                        256 & t && (i += h(e, r),
                        r += 4),
                        512 & t && (r += 4),
                        1024 & t && (r += 4),
                        2048 & t && (r += 4);
                    return i
                }
                function m(e, t, r) {
                    d(t, ["moof", "traf"]).forEach((function(t) {
                        d(t, ["tfhd"]).forEach((function(i) {
                            var n = h(i, 4)
                              , a = e[n];
                            if (a) {
                                var s = a.timescale || 9e4;
                                d(t, ["tfdt"]).forEach((function(e) {
                                    var t = e.data[e.start]
                                      , i = h(e, 4);
                                    if (0 === t)
                                        i -= r * s,
                                        i = Math.max(i, 0),
                                        u(e, 4, i = Math.ceil(i));
                                    else {
                                        i *= Math.pow(2, 32),
                                        i += h(e, 8),
                                        i -= r * s,
                                        i = Math.max(i, 0);
                                        var n = Math.floor(i / (o + 1))
                                          , a = Math.floor(i % (o + 1));
                                        u(e, 4, n),
                                        u(e, 8, a)
                                    }
                                }
                                ))
                            }
                        }
                        ))
                    }
                    ))
                }
                function T(e) {
                    var t = {
                        valid: null,
                        remainder: null
                    }
                      , r = d(e, ["moof"]);
                    if (!r)
                        return t;
                    if (r.length < 2)
                        return t.remainder = e,
                        t;
                    var n = r[r.length - 1];
                    return t.valid = Object(i.a)(e, 0, n.start - 8),
                    t.remainder = Object(i.a)(e, n.start - 8),
                    t
                }
                function S(e, t, r, i) {
                    var n = 0;
                    n += t;
                    for (var o = 0, s = 0, l = 0; n < e.length; ) {
                        o = 0;
                        do {
                            if (n >= e.length)
                                break;
                            o += l = e[n++]
                        } while (255 === l);
                        s = 0;
                        do {
                            if (n >= e.length)
                                break;
                            s += l = e[n++]
                        } while (255 === l);
                        var u = e.length - n
                          , d = n;
                        if (s < u)
                            n += s;
                        else if (s > u) {
                            a.b.error("Malformed SEI payload. " + s + " is too small, only " + u + " bytes left to parse.");
                            break
                        }
                        if (4 === o) {
                            if (181 === e[d++]) {
                                var f = c(e, d);
                                if (d += 2,
                                49 === f) {
                                    var p = h(e, d);
                                    if (d += 4,
                                    1195456820 === p && 3 === e[d++]) {
                                        var g = e[d++]
                                          , v = 64 & g
                                          , y = v ? 2 + 3 * (31 & g) : 0
                                          , m = new Uint8Array(y);
                                        if (v) {
                                            m[0] = g;
                                            for (var T = 1; T < y; T++)
                                                m[T] = e[d++]
                                        }
                                        i.push({
                                            payloadType: o,
                                            pts: r,
                                            bytes: m
                                        })
                                    }
                                }
                            }
                        } else if (5 === o && s > 16) {
                            for (var S = [], I = 0; I < 16; I++) {
                                var P = e[d++].toString(16);
                                S.push(1 == P.length ? "0" + P : P),
                                3 !== I && 5 !== I && 7 !== I && 9 !== I || S.push("-")
                            }
                            for (var b = s - 16, E = new Uint8Array(b), D = 0; D < b; D++)
                                E[D] = e[d++];
                            i.push({
                                pts: r,
                                payloadType: o,
                                uuid: S.join(""),
                                bytes: E
                            })
                        }
                    }
                }
                function I(e, t) {
                    var r = new Uint8Array(e.length + t.length);
                    return r.set(e),
                    r.set(t, e.length),
                    r
                }
            }
            , function(e, t, r) {
                var i = r(27);
                e.exports = function(e, t) {
                    e.prototype = Object.create(t.prototype),
                    e.prototype.constructor = e,
                    i(e, t)
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "c", (function() {
                    return Ge
                }
                )),
                r.d(t, "d", (function() {
                    return qe
                }
                )),
                r.d(t, "a", (function() {
                    return ze
                }
                )),
                r.d(t, "b", (function() {
                    return Ke
                }
                ));
                var i = r(0)
                  , n = r(2)
                  , a = r(21)
                  , o = r(8)
                  , s = r.n(o)
                  , l = r(3)
                  , c = r(11)
                  , h = r(7)
                  , u = r(13)
                  , d = function() {
                    function e() {
                        this._audioTrack = void 0,
                        this._id3Track = void 0,
                        this.frameIndex = 0,
                        this.cachedData = null,
                        this.initPTS = null
                    }
                    var t = e.prototype;
                    return t.resetInitSegment = function(e, t, r) {
                        this._id3Track = {
                            type: "id3",
                            id: 0,
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: 0,
                            samples: [],
                            dropped: 0
                        }
                    }
                    ,
                    t.abort = function() {}
                    ,
                    t.resetTimeStamp = function() {}
                    ,
                    t.resetContiguity = function() {}
                    ,
                    t.canParse = function(e, t) {
                        return !1
                    }
                    ,
                    t.appendFrame = function(e, t, r) {}
                    ,
                    t.demux = function(e, t) {
                        this.cachedData && (e = Object(h.a)(this.cachedData, e),
                        this.cachedData = null);
                        var r, i, n = c.b(e, 0), a = n ? n.length : 0, o = this._audioTrack, s = this._id3Track, l = n ? c.d(n) : void 0, d = e.length;
                        for (0 !== this.frameIndex && null !== this.initPTS || (this.initPTS = f(l, t)),
                        n && n.length > 0 && s.samples.push({
                            pts: this.initPTS,
                            dts: this.initPTS,
                            data: n
                        }),
                        i = this.initPTS; a < d; ) {
                            if (this.canParse(e, a)) {
                                var p = this.appendFrame(o, e, a);
                                p ? (this.frameIndex++,
                                i = p.sample.pts,
                                r = a += p.length) : a = d
                            } else
                                c.a(e, a) ? (n = c.b(e, a),
                                s.samples.push({
                                    pts: i,
                                    dts: i,
                                    data: n
                                }),
                                r = a += n.length) : a++;
                            if (a === d && r !== d) {
                                var g = Object(u.a)(e, r);
                                this.cachedData ? this.cachedData = Object(h.a)(this.cachedData, g) : this.cachedData = g
                            }
                        }
                        return {
                            audioTrack: o,
                            avcTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            },
                            id3Track: s,
                            textTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            }
                        }
                    }
                    ,
                    t.demuxSampleAes = function(e, t, r) {
                        return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"))
                    }
                    ,
                    t.flush = function(e) {
                        var t = this.cachedData;
                        return t && (this.cachedData = null,
                        this.demux(t, 0)),
                        this.frameIndex = 0,
                        {
                            audioTrack: this._audioTrack,
                            avcTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            },
                            id3Track: this._id3Track,
                            textTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            }
                        }
                    }
                    ,
                    t.destroy = function() {}
                    ,
                    e
                }()
                  , f = function(e, t) {
                    return Object(l.a)(e) ? 90 * e : 9e4 * t
                }
                  , p = d
                  , g = r(1);
                function v(e, t) {
                    return 255 === e[t] && 240 == (246 & e[t + 1])
                }
                function y(e, t) {
                    return 1 & e[t + 1] ? 7 : 9
                }
                function m(e, t) {
                    return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
                }
                function T(e, t) {
                    return t + 1 < e.length && v(e, t)
                }
                function S(e, t) {
                    if (T(e, t)) {
                        var r = y(e, t);
                        if (t + r >= e.length)
                            return !1;
                        var i = m(e, t);
                        if (i <= r)
                            return !1;
                        var n = t + i;
                        return n === e.length || T(e, n)
                    }
                    return !1
                }
                function I(e, t, r, a, o, s) {
                    if (void 0 === s && (s = !1),
                    !e.samplerate) {
                        var l = function(e, t, r, a, o) {
                            var s;
                            void 0 === o && (o = !1);
                            var l = a
                              , c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]
                              , h = t[r + 2]
                              , u = h >> 2 & 15;
                            if (!(u > c.length - 1)) {
                                var d = 1 + (h >> 6 & 3)
                                  , f = t[r + 3] >> 6 & 3 | (1 & h) << 2
                                  , p = u
                                  , v = !1;
                                5 !== d && 29 !== d || (g.b.log("HE-AAC v2 (SBR / PS) detected, sampling index:" + p + " -> " + (p - 3)),
                                p -= 3);
                                var y = p;
                                o && p >= 6 && 1 !== f && (g.b.log("possible AAC LC with SBR detected, sampling index:" + y + " -> " + (y - 3)),
                                y -= 3,
                                v = !0,
                                d = 5);
                                var m = [d << 3 | (14 & p) >> 1, (1 & p) << 7 | f << 3, 0, 0];
                                v && (m[1] |= (14 & y) >> 1,
                                m[2] = (1 & y) << 7,
                                m[2] |= 8,
                                m[3] = 0);
                                var T = "mp4a.40." + (null != (s = d) ? s : 2);
                                return g.b.log("parsed codec:" + T + ", rate:" + c[p] + ", channels:" + f),
                                {
                                    config: m,
                                    samplerate: c[p],
                                    channelCount: f,
                                    codec: T,
                                    manifestCodec: l
                                }
                            }
                            e.trigger(i.a.ERROR, {
                                type: n.b.MEDIA_ERROR,
                                details: n.a.FRAG_PARSING_ERROR,
                                fatal: !0,
                                reason: "invalid ADTS sampling index:" + u
                            })
                        }(t, r, a, o, s);
                        if (!l)
                            return;
                        e.config = l.config,
                        e.samplerate = l.samplerate,
                        e.channelCount = l.channelCount,
                        e.codec = l.codec,
                        e.manifestCodec = l.manifestCodec,
                        g.b.log("parsed codec:" + e.codec + ", rate:" + l.samplerate + ", channels:" + l.channelCount)
                    }
                }
                function P(e) {
                    return 9216e4 / e
                }
                function b(e, t, r, i, n) {
                    var a = function(e, t, r, i, n) {
                        var a = y(e, t)
                          , o = m(e, t);
                        if ((o -= a) > 0)
                            return {
                                headerLength: a,
                                frameLength: o,
                                stamp: r + i * n
                            }
                    }(t, r, i, n, P(e.samplerate));
                    if (a) {
                        var o, s = a.frameLength, l = a.headerLength, c = a.stamp, h = l + s, u = Math.max(0, r + h - t.length);
                        u ? (o = new Uint8Array(h - l)).set(t.subarray(r + l, t.length), 0) : o = t.subarray(r + l, r + h);
                        var d = {
                            unit: o,
                            pts: c
                        };
                        return u || e.samples.push(d),
                        {
                            sample: d,
                            length: h,
                            missing: u
                        }
                    }
                }
                var E = function(e) {
                    function t(t, r) {
                        var i;
                        return (i = e.call(this) || this).observer = void 0,
                        i.config = void 0,
                        i.observer = t,
                        i.config = r,
                        i
                    }
                    s()(t, e);
                    var r = t.prototype;
                    return r.abort = function() {}
                    ,
                    r.resetInitSegment = function(t, r, i) {
                        e.prototype.resetInitSegment.call(this, t, r, i),
                        this._audioTrack = {
                            container: "audio/adts",
                            type: "audio",
                            id: 0,
                            pid: -1,
                            sequenceNumber: 0,
                            isAAC: !0,
                            samples: [],
                            manifestCodec: t,
                            duration: i,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    ,
                    t.probe = function(e) {
                        if (!e)
                            return !1;
                        for (var t = (c.b(e, 0) || []).length, r = e.length; t < r; t++)
                            if (S(e, t))
                                return g.b.log("ADTS sync word found !"),
                                !0;
                        return !1
                    }
                    ,
                    r.canParse = function(e, t) {
                        return function(e, t) {
                            return function(e, t) {
                                return t + 5 < e.length
                            }(e, t) && v(e, t) && m(e, t) <= e.length - t
                        }(e, t)
                    }
                    ,
                    r.appendFrame = function(e, t, r) {
                        I(e, this.observer, t, r, e.manifestCodec, this.config.useSBRWorkaround);
                        var i = b(e, t, r, this.initPTS, this.frameIndex);
                        if (i && 0 === i.missing)
                            return i
                    }
                    ,
                    t
                }(p);
                E.minProbeByteLength = 9;
                var D = E
                  , k = function() {
                    function e(e, t) {
                        this.remainderData = null,
                        this.config = void 0,
                        this.config = t
                    }
                    var t = e.prototype;
                    return t.resetTimeStamp = function() {}
                    ,
                    t.resetInitSegment = function() {}
                    ,
                    t.resetContiguity = function() {
                        this.remainderData = null
                    }
                    ,
                    e.probe = function(e) {
                        return Object(h.b)({
                            data: e,
                            start: 0,
                            end: Math.min(e.length, 16384)
                        }, ["moof"]).length > 0
                    }
                    ,
                    t.abort = function() {
                        this.remainderData = null
                    }
                    ,
                    t.demux = function(e) {
                        var t = e
                          , r = {
                            type: "",
                            id: -1,
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: -1,
                            samples: [],
                            dropped: 0
                        };
                        if (this.config.progressive) {
                            this.remainderData && (t = Object(h.a)(this.remainderData, e));
                            var i = Object(h.i)(t);
                            this.remainderData = i.remainder,
                            r.samples = i.valid || new Uint8Array
                        } else
                            r.samples = t;
                        return {
                            audioTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            },
                            avcTrack: r,
                            id3Track: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            },
                            textTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            }
                        }
                    }
                    ,
                    t.flush = function() {
                        var e = {
                            type: "",
                            id: -1,
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: -1,
                            samples: [],
                            dropped: 0
                        };
                        return e.samples = this.remainderData || new Uint8Array,
                        this.remainderData = null,
                        {
                            audioTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            },
                            avcTrack: e,
                            id3Track: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            },
                            textTrack: {
                                type: "",
                                id: -1,
                                pid: -1,
                                inputTimeScale: 9e4,
                                sequenceNumber: -1,
                                samples: [],
                                dropped: 0
                            }
                        }
                    }
                    ,
                    t.demuxSampleAes = function(e, t, r) {
                        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                    }
                    ,
                    t.destroy = function() {}
                    ,
                    e
                }();
                k.minProbeByteLength = 1024;
                var C = k
                  , L = null
                  , w = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160]
                  , R = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3]
                  , A = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]]
                  , _ = [0, 1, 1, 4];
                function x(e, t, r, i, n) {
                    if (!(r + 24 > t.length)) {
                        var a = O(t, r);
                        if (a && r + a.frameLength <= t.length) {
                            var o = i + n * (9e4 * a.samplesPerFrame / a.sampleRate)
                              , s = {
                                unit: t.subarray(r, r + a.frameLength),
                                pts: o,
                                dts: o
                            };
                            return e.config = [],
                            e.channelCount = a.channelCount,
                            e.samplerate = a.sampleRate,
                            e.samples.push(s),
                            {
                                sample: s,
                                length: a.frameLength,
                                missing: 0
                            }
                        }
                    }
                }
                function O(e, t) {
                    var r = e[t + 1] >> 3 & 3
                      , i = e[t + 1] >> 1 & 3
                      , n = e[t + 2] >> 4 & 15
                      , a = e[t + 2] >> 2 & 3;
                    if (1 !== r && 0 !== n && 15 !== n && 3 !== a) {
                        var o = e[t + 2] >> 1 & 1
                          , s = e[t + 3] >> 6
                          , l = 1e3 * w[14 * (3 === r ? 3 - i : 3 === i ? 3 : 4) + n - 1]
                          , c = R[3 * (3 === r ? 0 : 2 === r ? 1 : 2) + a]
                          , h = 3 === s ? 1 : 2
                          , u = A[r][i]
                          , d = _[i]
                          , f = 8 * u * d
                          , p = Math.floor(u * l / c + o) * d;
                        if (null === L) {
                            var g = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                            L = g ? parseInt(g[1]) : 0
                        }
                        return !!L && L <= 87 && 2 === i && l >= 224e3 && 0 === s && (e[t + 3] = 128 | e[t + 3]),
                        {
                            sampleRate: c,
                            channelCount: h,
                            frameLength: p,
                            samplesPerFrame: f
                        }
                    }
                }
                function F(e, t) {
                    return !(255 !== e[t] || 224 & ~e[t + 1] || !(6 & e[t + 1]))
                }
                function B(e, t) {
                    return t + 1 < e.length && F(e, t)
                }
                function M(e, t) {
                    if (t + 1 < e.length && F(e, t)) {
                        var r = O(e, t)
                          , i = 4;
                        null != r && r.frameLength && (i = r.frameLength);
                        var n = t + i;
                        return n === e.length || B(e, n)
                    }
                    return !1
                }
                var U, N = r(12), G = function() {
                    function e(e) {
                        this.data = void 0,
                        this.bytesAvailable = void 0,
                        this.word = void 0,
                        this.bitsAvailable = void 0,
                        this.data = e,
                        this.bytesAvailable = e.byteLength,
                        this.word = 0,
                        this.bitsAvailable = 0
                    }
                    var t = e.prototype;
                    return t.loadWord = function() {
                        var e = this.data.byteLength - this.bytesAvailable
                          , t = new Uint8Array(4)
                          , r = Math.min(4, this.bytesAvailable);
                        if (0 === r)
                            throw new Error("no bytes available");
                        t.set(this.data.subarray(e, e + r)),
                        this.word = new DataView(t.buffer).getUint32(0),
                        this.bitsAvailable = 8 * r,
                        this.bytesAvailable -= r
                    }
                    ,
                    t.skipBits = function(e) {
                        var t;
                        this.bitsAvailable > e ? (this.word <<= e,
                        this.bitsAvailable -= e) : (e -= this.bitsAvailable,
                        e -= (t = e >> 3) >> 3,
                        this.bytesAvailable -= t,
                        this.loadWord(),
                        this.word <<= e,
                        this.bitsAvailable -= e)
                    }
                    ,
                    t.readBits = function(e) {
                        var t = Math.min(this.bitsAvailable, e)
                          , r = this.word >>> 32 - t;
                        return e > 32 && g.b.error("Cannot read more than 32 bits at a time"),
                        this.bitsAvailable -= t,
                        this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(),
                        (t = e - t) > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r
                    }
                    ,
                    t.skipLZ = function() {
                        var e;
                        for (e = 0; e < this.bitsAvailable; ++e)
                            if (this.word & 2147483648 >>> e)
                                return this.word <<= e,
                                this.bitsAvailable -= e,
                                e;
                        return this.loadWord(),
                        e + this.skipLZ()
                    }
                    ,
                    t.skipUEG = function() {
                        this.skipBits(1 + this.skipLZ())
                    }
                    ,
                    t.skipEG = function() {
                        this.skipBits(1 + this.skipLZ())
                    }
                    ,
                    t.readUEG = function() {
                        var e = this.skipLZ();
                        return this.readBits(e + 1) - 1
                    }
                    ,
                    t.readEG = function() {
                        var e = this.readUEG();
                        return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
                    }
                    ,
                    t.readBoolean = function() {
                        return 1 === this.readBits(1)
                    }
                    ,
                    t.readUByte = function() {
                        return this.readBits(8)
                    }
                    ,
                    t.readUShort = function() {
                        return this.readBits(16)
                    }
                    ,
                    t.readUInt = function() {
                        return this.readBits(32)
                    }
                    ,
                    t.skipScalingList = function(e) {
                        for (var t = 8, r = 8, i = 0; i < e; i++)
                            0 !== r && (r = (t + this.readEG() + 256) % 256),
                            t = 0 === r ? t : r
                    }
                    ,
                    t.readSPS = function() {
                        var e, t, r, i = 0, n = 0, a = 0, o = 0, s = null, l = null, c = null, h = null, u = null, d = this.readUByte.bind(this), f = this.readBits.bind(this), p = this.readUEG.bind(this), g = this.readBoolean.bind(this), v = this.skipBits.bind(this), y = this.skipEG.bind(this), m = this.skipUEG.bind(this), T = this.skipScalingList.bind(this);
                        this.readUInt.bind(this),
                        d();
                        var S = d();
                        if (f(5),
                        v(3),
                        d(),
                        m(),
                        (100 === S || 110 === S || 122 === S || 244 === S || 44 === S || 83 === S || 86 === S || 118 === S || 128 === S) && (3 === (s = p()) && v(1),
                        m(),
                        l = p() + 8,
                        v(1),
                        g()))
                            for (t = 3 !== s ? 8 : 12,
                            r = 0; r < t; r++)
                                g() && T(r < 6 ? 16 : 64);
                        m();
                        var I = p();
                        if (0 === I)
                            p();
                        else if (1 === I)
                            for (v(1),
                            y(),
                            y(),
                            e = p(),
                            r = 0; r < e; r++)
                                y();
                        m(),
                        v(1);
                        var P = p()
                          , b = p()
                          , E = f(1);
                        0 === E && v(1),
                        v(1),
                        g() && (i = p(),
                        n = p(),
                        a = p(),
                        o = p());
                        var D = [1, 1];
                        if (g()) {
                            if (g())
                                switch (d()) {
                                case 1:
                                    D = [1, 1];
                                    break;
                                case 2:
                                    D = [12, 11];
                                    break;
                                case 3:
                                    D = [10, 11];
                                    break;
                                case 4:
                                    D = [16, 11];
                                    break;
                                case 5:
                                    D = [40, 33];
                                    break;
                                case 6:
                                    D = [24, 11];
                                    break;
                                case 7:
                                    D = [20, 11];
                                    break;
                                case 8:
                                    D = [32, 11];
                                    break;
                                case 9:
                                    D = [80, 33];
                                    break;
                                case 10:
                                    D = [18, 11];
                                    break;
                                case 11:
                                    D = [15, 11];
                                    break;
                                case 12:
                                    D = [64, 33];
                                    break;
                                case 13:
                                    D = [160, 99];
                                    break;
                                case 14:
                                    D = [4, 3];
                                    break;
                                case 15:
                                    D = [3, 2];
                                    break;
                                case 16:
                                    D = [2, 1];
                                    break;
                                case 255:
                                    D = [d() << 8 | d(), d() << 8 | d()]
                                }
                            if (g() && g(),
                            g() && (v(4),
                            g() && (c = N.b[f(8)],
                            h = N.c[f(8)],
                            f(8))),
                            g() && (m(),
                            m()),
                            g()) {
                                var k = f(32)
                                  , C = f(32);
                                g(),
                                u = C / (2 * k)
                            }
                        }
                        return {
                            width: Math.ceil(16 * (P + 1) - 2 * i - 2 * n),
                            height: (2 - E) * (b + 1) * 16 - (E ? 2 : 4) * (a + o),
                            pixelRatio: D,
                            chromaFormat: s ? N.a[s] : null,
                            bitDepth: l,
                            colorSpace: c,
                            transfer: h,
                            framerate: u
                        }
                    }
                    ,
                    t.readSliceType = function() {
                        return this.readUByte(),
                        this.readUEG(),
                        this.readUEG()
                    }
                    ,
                    e
                }(), H = function() {
                    function e(e, t, r) {
                        this.keyData = void 0,
                        this.decrypter = void 0,
                        this.keyData = r,
                        this.decrypter = new a.a(e,t,{
                            removePKCS7Padding: !1
                        })
                    }
                    var t = e.prototype;
                    return t.decryptBuffer = function(e, t) {
                        this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, t)
                    }
                    ,
                    t.decryptAacSample = function(e, t, r, i) {
                        var n = e[t].unit
                          , a = n.subarray(16, n.length - n.length % 16)
                          , o = a.buffer.slice(a.byteOffset, a.byteOffset + a.length)
                          , s = this;
                        this.decryptBuffer(o, (function(a) {
                            var o = new Uint8Array(a);
                            n.set(o, 16),
                            i || s.decryptAacSamples(e, t + 1, r)
                        }
                        ))
                    }
                    ,
                    t.decryptAacSamples = function(e, t, r) {
                        for (; ; t++) {
                            if (t >= e.length)
                                return void r();
                            if (!(e[t].unit.length < 32)) {
                                var i = this.decrypter.isSync();
                                if (this.decryptAacSample(e, t, r, i),
                                !i)
                                    return
                            }
                        }
                    }
                    ,
                    t.getAvcEncryptedData = function(e) {
                        for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), i = 0, n = 32; n <= e.length - 16; n += 160,
                        i += 16)
                            r.set(e.subarray(n, n + 16), i);
                        return r
                    }
                    ,
                    t.getAvcDecryptedUnit = function(e, t) {
                        for (var r = new Uint8Array(t), i = 0, n = 32; n <= e.length - 16; n += 160,
                        i += 16)
                            e.set(r.subarray(i, i + 16), n);
                        return e
                    }
                    ,
                    t.decryptAvcSample = function(e, t, r, i, n, a) {
                        var o = ce(n.data)
                          , s = this.getAvcEncryptedData(o)
                          , l = this;
                        this.decryptBuffer(s.buffer, (function(s) {
                            n.data = l.getAvcDecryptedUnit(o, s),
                            a || l.decryptAvcSamples(e, t, r + 1, i)
                        }
                        ))
                    }
                    ,
                    t.decryptAvcSamples = function(e, t, r, i) {
                        if (e instanceof Uint8Array)
                            throw new Error("Cannot decrypt samples of type Uint8Array");
                        for (; ; t++,
                        r = 0) {
                            if (t >= e.length)
                                return void i();
                            for (var n = e[t].units; !(r >= n.length); r++) {
                                var a = n[r];
                                if (!(a.data.length <= 48 || 1 !== a.type && 5 !== a.type)) {
                                    var o = this.decrypter.isSync();
                                    if (this.decryptAvcSample(e, t, r, i, a, o),
                                    !o)
                                        return
                                }
                            }
                        }
                    }
                    ,
                    e
                }(), q = function(e) {
                    return e[e.HEVC = 36] = "HEVC",
                    e[e.AVC = 27] = "AVC",
                    e
                }({}), z = r(10), K = r.n(z), V = function(e) {
                    return e[e.SLICE_TRAIL_N = 0] = "SLICE_TRAIL_N",
                    e[e.SLICE_TRAIL_R = 1] = "SLICE_TRAIL_R",
                    e[e.SLICE_TSA_N = 2] = "SLICE_TSA_N",
                    e[e.SLICE_TLA_R = 3] = "SLICE_TLA_R",
                    e[e.SLICE_STSA_N = 4] = "SLICE_STSA_N",
                    e[e.SLICE_STSA_R = 5] = "SLICE_STSA_R",
                    e[e.SLICE_RADL_N = 6] = "SLICE_RADL_N",
                    e[e.SLICE_RADL_R = 7] = "SLICE_RADL_R",
                    e[e.SLICE_RASL_N = 8] = "SLICE_RASL_N",
                    e[e.SLICE_RASL_R = 9] = "SLICE_RASL_R",
                    e[e.SLICE_BLA_W_LP = 16] = "SLICE_BLA_W_LP",
                    e[e.SLICE_BLA_W_RADL = 17] = "SLICE_BLA_W_RADL",
                    e[e.SLICE_BLA_N_LP = 18] = "SLICE_BLA_N_LP",
                    e[e.SLICE_IDR_W_RADL = 19] = "SLICE_IDR_W_RADL",
                    e[e.SLICE_IDR_N_LP = 20] = "SLICE_IDR_N_LP",
                    e[e.SLICE_CRA = 21] = "SLICE_CRA",
                    e[e.SLICE_RSV_IRAP_VCL22 = 22] = "SLICE_RSV_IRAP_VCL22",
                    e[e.SLICE_RSV_IRAP_VCL23 = 23] = "SLICE_RSV_IRAP_VCL23",
                    e[e.VPS = 32] = "VPS",
                    e[e.SPS = 33] = "SPS",
                    e[e.PPS = 34] = "PPS",
                    e[e.DELIMITER = 35] = "DELIMITER",
                    e[e.EOS = 36] = "EOS",
                    e[e.EOB = 37] = "EOB",
                    e[e.FILTER = 38] = "FILTER",
                    e[e.PREFIX_SEI = 39] = "PREFIX_SEI",
                    e[e.SUFFIX_SEI = 40] = "SUFFIX_SEI",
                    e[e.STAP = 48] = "STAP",
                    e[e.FU = 49] = "FU",
                    e[e.PACI = 50] = "PACI",
                    e
                }({}), j = ((U = {})[V.SLICE_IDR_N_LP] = "IDR",
                U[V.SLICE_IDR_W_RADL] = "IDR",
                U[V.PREFIX_SEI] = "SEI",
                U[V.SUFFIX_SEI] = "SEI",
                U[V.VPS] = "VPS",
                U[V.SPS] = "SPS",
                U[V.PPS] = "PPS",
                U[V.SLICE_BLA_W_LP] = "RAP",
                U[V.SLICE_BLA_W_RADL] = "RAP",
                U[V.SLICE_BLA_N_LP] = "RAP",
                U[V.SLICE_CRA] = "RAP",
                U[V.SLICE_RSV_IRAP_VCL22] = "RAP",
                U[V.SLICE_RSV_IRAP_VCL23] = "RAP",
                U[V.DELIMITER] = "AUD",
                U[V.FILTER] = "FILTER",
                U[V.EOS] = "EOS",
                U[V.EOB] = "EOB",
                U[V.SLICE_TRAIL_N] = "NDR",
                U[V.SLICE_TRAIL_R] = "NDR",
                U[V.SLICE_TSA_N] = "NDR",
                U[V.SLICE_TLA_R] = "NDR",
                U[V.SLICE_STSA_N] = "NDR",
                U[V.SLICE_STSA_R] = "NDR",
                U[V.SLICE_RADL_N] = "NDR",
                U[V.SLICE_RADL_R] = "NDR",
                U[V.SLICE_RASL_N] = "NDR",
                U[V.SLICE_RASL_R] = "NDR",
                U), W = r(5), Y = r.n(W), Q = function(e) {
                    function t(t) {
                        var r;
                        return (r = e.call(this, t) || this).loadWord(),
                        r
                    }
                    s()(t, e);
                    var r = t.prototype;
                    return r.skipBits = function(e) {
                        var t;
                        this.bitsAvailable > e ? (this.word <<= e,
                        this.bitsAvailable -= e) : (e -= this.bitsAvailable,
                        e -= 8 * (t = Math.floor(e / 8)),
                        this.bytesAvailable -= t,
                        this.loadWord(),
                        this.word <<= e,
                        this.bitsAvailable -= e)
                    }
                    ,
                    r.readBits = function(e) {
                        var t = Math.min(this.bitsAvailable, e)
                          , r = this.word >>> 32 - t;
                        return e > 32 && g.b.error("Cannot read more than 32 bits at a time"),
                        this.bitsAvailable -= t,
                        this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(),
                        (t = e - t) > 0 ? r << t | this.readBits(t) : r
                    }
                    ,
                    Y()(t, [{
                        key: "bitsLength",
                        get: function() {
                            return 8 * this.bytesAvailable
                        }
                    }, {
                        key: "bitsAvailableLen",
                        get: function() {
                            return this.bitsLength + this.bitsAvailable
                        }
                    }])
                }(G);
                function X(e, t) {
                    for (var r = {
                        space: e.readBits(2),
                        tier: e.readBits(1),
                        idc: e.readBits(5),
                        compatability_flag: []
                    }, i = 0; i < 32; i++)
                        r.compatability_flag.push(e.readBits(1));
                    K()(r, {
                        progressiveSource: e.readBits(1),
                        interlacedSource: e.readBits(1),
                        nonPacked: e.readBits(1),
                        frameOnly: e.readBits(1),
                        reserved: e.skipBits(44),
                        level: e.readBits(8),
                        subLayerProfilePresent: [],
                        subLayerLevelPresent: []
                    });
                    for (var n = 0; n < t; n++)
                        r.subLayerProfilePresent.push(e.readBits(1)),
                        r.subLayerLevelPresent.push(e.readBits(1));
                    if (t > 0)
                        for (var a = t; a < 8; a++)
                            e.skipBits(2);
                    for (var o = 0; o < t; o++)
                        r.subLayerProfilePresent[o] && (e.skipBits(2),
                        e.skipBits(1),
                        e.skipBits(5),
                        e.skipBits(32),
                        e.skipBits(4),
                        e.skipBits(44)),
                        r.subLayerLevelPresent[o] && e.skipBits(8);
                    return r
                }
                function Z(e) {
                    var t = {}
                      , r = new Q(ce(e.subarray(2)));
                    r.skipBits(4);
                    var i = r.readBits(3);
                    r.skipBits(1);
                    var n = X(r, i);
                    t.codec = function(e) {
                        var t = "hvc1.";
                        1 === e.space ? t += "A" : 2 === e.space ? t += "B" : 3 === e.space && (t += "C"),
                        t += e.idc + ".";
                        var r = parseInt(e.compatability_flag.reverse().join(""), 2);
                        r > 255 && (r = parseInt(e.compatability_flag.join(""), 2)),
                        t += r.toString(16) + ".",
                        e.tier ? t += "H" : t += "L",
                        t += e.level;
                        var i = e.progressiveSource << 3 | e.interlacedSource << 2 | e.nonPacked << 1 | e.frameOnly;
                        if (i) {
                            var n = i.toString(16);
                            1 === n.length && (n += "0"),
                            t += "." + n
                        }
                        return t
                    }(n),
                    r.skipUEG();
                    var a = r.readUEG();
                    if (t.chromaFormatIdc = a,
                    3 === a && r.skipBits(1),
                    t.width = r.readUEG(),
                    t.height = r.readUEG(),
                    r.readBoolean()) {
                        var o = $[a]
                          , s = ee[a]
                          , l = r.readUEG()
                          , c = r.readUEG()
                          , h = r.readUEG()
                          , u = r.readUEG();
                        t.width = Math.ceil(t.width - o * (c + l)),
                        t.height = Math.ceil(t.height - s * (u + h))
                    }
                    t.bitDepthLumaMinus8 = r.readUEG(),
                    t.bitDepthChromaMinus8 = r.readUEG();
                    for (var d = r.readUEG(), f = r.readBoolean() ? 0 : i; f <= i; f++)
                        r.skipUEG(),
                        r.skipUEG(),
                        r.skipUEG();
                    if (r.skipUEG(),
                    r.skipUEG(),
                    r.skipUEG(),
                    r.skipUEG(),
                    r.skipUEG(),
                    r.skipUEG(),
                    r.readBoolean() && r.readBoolean())
                        for (var p = 0; p < 4; p++)
                            for (var g = 0; g < (3 === p ? 2 : 6); g++)
                                if (r.readBoolean()) {
                                    p > 1 && r.skipEG();
                                    for (var v = Math.min(64, 1 << 4 + (p << 1)), y = 0; y < v; y++)
                                        r.skipEG()
                                } else
                                    r.skipUEG();
                    r.skipBits(2),
                    r.readBoolean() && (r.skipBits(4),
                    r.skipBits(4),
                    r.skipUEG(),
                    r.skipUEG(),
                    r.skipBits(1));
                    for (var m = r.readUEG(), T = [], S = 0; S < m; S++) {
                        var I = !1;
                        if (0 !== S && (I = r.readBoolean()),
                        I) {
                            var P = 1;
                            S === m && (P = r.readUEG() + 1),
                            r.skipBits(1),
                            r.skipUEG();
                            for (var b = S - P, E = 0; E < T[b] + 1; E++)
                                r.readBoolean() || r.skipBits(1)
                        } else {
                            var D = r.readUEG()
                              , k = r.readUEG();
                            T[S] = D + k;
                            for (var C = 0; C < D; C++)
                                r.skipUEG(),
                                r.skipBits(1);
                            for (var L = 0; L < k; L++)
                                r.skipUEG(),
                                r.skipBits(1)
                        }
                    }
                    if (r.readBoolean())
                        for (var w = r.readUEG(), R = 0; R < w; R++)
                            r.skipBits(d + 4),
                            r.skipBits(1);
                    return r.skipBits(2),
                    r.readBoolean() && (r.readBoolean() && (t.sarRatio = function(e) {
                        var t = [1, 1];
                        switch (e.readUByte()) {
                        case 1:
                            t = [1, 1];
                            break;
                        case 2:
                            t = [12, 11];
                            break;
                        case 3:
                            t = [10, 11];
                            break;
                        case 4:
                            t = [16, 11];
                            break;
                        case 5:
                            t = [40, 33];
                            break;
                        case 6:
                            t = [24, 11];
                            break;
                        case 7:
                            t = [20, 11];
                            break;
                        case 8:
                            t = [32, 11];
                            break;
                        case 9:
                            t = [80, 33];
                            break;
                        case 10:
                            t = [18, 11];
                            break;
                        case 11:
                            t = [15, 11];
                            break;
                        case 12:
                            t = [64, 33];
                            break;
                        case 13:
                            t = [160, 99];
                            break;
                        case 14:
                            t = [4, 3];
                            break;
                        case 15:
                            t = [3, 2];
                            break;
                        case 16:
                            t = [2, 1];
                            break;
                        case 255:
                            t = [e.readUByte() << 8 | e.readUByte(), e.readUByte() << 8 | e.readUByte()]
                        }
                        return t
                    }(r)),
                    r.readBoolean() && r.skipBits(1),
                    r.readBoolean() && (r.skipBits(3),
                    r.skipBits(1),
                    r.readBoolean() && (t.colorSpace = N.b[r.readBits(8)],
                    t.transfer = N.c[r.readBits(8)],
                    r.skipBits(8))),
                    r.readBoolean() && (r.skipUEG(),
                    r.skipUEG()),
                    r.skipBits(3),
                    r.readBoolean() && (r.skipUEG(),
                    r.skipUEG(),
                    r.skipUEG(),
                    r.skipUEG()),
                    r.readBoolean() && (t.numUnitsInTick = r.readUByte() << 24 | r.readUByte() << 16 | r.readUByte() << 8 | r.readUByte(),
                    t.timescale = r.readUByte() << 24 | r.readUByte() << 16 | r.readUByte() << 8 | r.readUByte(),
                    t.framerate = t.timescale / (2 * t.numUnitsInTick),
                    t.timescale *= 1e3 * t.framerate)),
                    t
                }
                function J(e) {
                    return e === V.SLICE_IDR_N_LP || e === V.SLICE_IDR_W_RADL
                }
                var $ = {
                    0: 1,
                    1: 2,
                    2: 2,
                    3: 1
                }
                  , ee = {
                    0: 1,
                    1: 2,
                    2: 1,
                    3: 1
                };
                function te(e) {
                    e.hdrStaticMetadata || (e.hdrStaticMetadata = {
                        displayPrimaries: [[0, 0], [0, 0], [0, 0]],
                        whitePoint: [0, 0],
                        maxDisplayMasteringLuminance: 0,
                        minDisplayMasteringLuminance: 0,
                        maxContentLightLevel: 0,
                        maxPictureAverageLightLevel: 0
                    })
                }
                var re = {
                    video: 1,
                    audio: 2,
                    id3: 3,
                    text: 4
                }
                  , ie = function() {
                    function e(e, t, r) {
                        this.observer = void 0,
                        this.config = void 0,
                        this.typeSupported = void 0,
                        this.sampleAes = null,
                        this.pmtParsed = !1,
                        this.audioCodec = void 0,
                        this.videoCodec = void 0,
                        this._duration = 0,
                        this.aacLastPTS = null,
                        this._initPTS = null,
                        this._initDTS = null,
                        this._pmtId = -1,
                        this._avcTrack = void 0,
                        this._audioTrack = void 0,
                        this._id3Track = void 0,
                        this._txtTrack = void 0,
                        this.aacOverFlow = null,
                        this.avcSample = null,
                        this.remainderData = null,
                        this.observer = e,
                        this.config = t,
                        this.typeSupported = r
                    }
                    e.probe = function(t) {
                        var r = e.syncOffset(t);
                        return !(r < 0 || (r && g.b.warn("MPEG2-TS detected but first sync word found @ offset " + r + ", junk ahead ?"),
                        0))
                    }
                    ,
                    e.syncOffset = function(e) {
                        for (var t = Math.min(1e3, e.length - 564), r = 0; r < t; ) {
                            if (71 === e[r] && 71 === e[r + 188] && 71 === e[r + 376])
                                return r;
                            r++
                        }
                        return -1
                    }
                    ,
                    e.createTrack = function(e, t) {
                        return {
                            container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
                            type: e,
                            id: re[e],
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: 0,
                            samples: [],
                            dropped: 0,
                            duration: "audio" === e ? t : void 0
                        }
                    }
                    ;
                    var t = e.prototype;
                    return t.resetInitSegment = function(t, r, i) {
                        this.pmtParsed = !1,
                        this._pmtId = -1,
                        this._avcTrack = e.createTrack("video", i),
                        this._audioTrack = e.createTrack("audio", i),
                        this._id3Track = e.createTrack("id3", i),
                        this._txtTrack = e.createTrack("text", i),
                        this._audioTrack.isAAC = !0,
                        this.aacOverFlow = null,
                        this.aacLastPTS = null,
                        this.avcSample = null,
                        this.audioCodec = t,
                        this.videoCodec = r,
                        this._duration = i
                    }
                    ,
                    t.abort = function() {
                        this.remainderData = null,
                        this.avcSample = null,
                        this.aacOverFlow = null,
                        this.aacLastPTS = null
                    }
                    ,
                    t.resetTimeStamp = function() {}
                    ,
                    t.resetContiguity = function() {
                        var e = this._audioTrack
                          , t = this._avcTrack
                          , r = this._id3Track;
                        e && (e.pesData = null),
                        t && (t.pesData = null),
                        r && (r.pesData = null),
                        this.aacOverFlow = null,
                        this.aacLastPTS = null
                    }
                    ,
                    t.demux = function(t, r, a, o) {
                        var s;
                        void 0 === a && (a = !1),
                        void 0 === o && (o = !1),
                        a || (this.sampleAes = null);
                        var l = this._avcTrack
                          , c = this._audioTrack
                          , u = this._id3Track
                          , d = l.pid
                          , f = l.streamType
                          , p = l.pesData
                          , v = c.pid
                          , y = u.pid
                          , m = c.pesData
                          , T = u.pesData
                          , S = !1
                          , I = this.pmtParsed
                          , P = this._pmtId
                          , b = t.length;
                        if (this.remainderData && (b = (t = Object(h.a)(this.remainderData, t)).length,
                        this.remainderData = null),
                        b < 188 && !o)
                            return this.remainderData = t,
                            {
                                audioTrack: c,
                                avcTrack: l,
                                id3Track: u,
                                textTrack: this._txtTrack
                            };
                        var E = Math.max(0, e.syncOffset(t));
                        (b -= (b - E) % 188) < t.byteLength && !o && (this.remainderData = new Uint8Array(t.buffer,b,t.buffer.byteLength - b));
                        for (var D = E; D < b; D += 188)
                            if (71 === t[D]) {
                                var k = !!(64 & t[D + 1])
                                  , C = ((31 & t[D + 1]) << 8) + t[D + 2]
                                  , L = void 0;
                                if ((48 & t[D + 3]) >> 4 > 1) {
                                    if ((L = D + 5 + t[D + 4]) === D + 188)
                                        continue
                                } else
                                    L = D + 4;
                                switch (C) {
                                case d:
                                    k && (p && (s = se(p)) && (f === q.HEVC || f === q.AVC ? this.parseVideoPES(s, !1, f) : g.b.error("unsupported video stream type")),
                                    p = {
                                        data: [],
                                        size: 0
                                    }),
                                    p && (p.data.push(t.subarray(L, D + 188)),
                                    p.size += D + 188 - L);
                                    break;
                                case v:
                                    k && (m && (s = se(m)) && (c.isAAC ? this.parseAACPES(s) : this.parseMPEGPES(s)),
                                    m = {
                                        data: [],
                                        size: 0
                                    }),
                                    m && (m.data.push(t.subarray(L, D + 188)),
                                    m.size += D + 188 - L);
                                    break;
                                case y:
                                    k && (T && (s = se(T)) && this.parseID3PES(s),
                                    T = {
                                        data: [],
                                        size: 0
                                    }),
                                    T && (T.data.push(t.subarray(L, D + 188)),
                                    T.size += D + 188 - L);
                                    break;
                                case 0:
                                    k && (L += t[L] + 1),
                                    P = this._pmtId = ae(t, L);
                                    break;
                                case P:
                                    k && (L += t[L] + 1);
                                    var w = oe(t, L, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, a);
                                    f = l.streamType = w.videoStreamType,
                                    (d = w.avc) > 0 && (l.pid = d),
                                    (v = w.audio) > 0 && (c.pid = v,
                                    c.isAAC = w.isAAC),
                                    (y = w.id3) > 0 && (u.pid = y),
                                    S && !I && (g.b.log("reparse from beginning"),
                                    S = !1,
                                    D = E - 188),
                                    I = this.pmtParsed = !0;
                                    break;
                                case 17:
                                case 8191:
                                    break;
                                default:
                                    S = !0
                                }
                            } else
                                this.observer.emit(i.a.ERROR, i.a.ERROR, {
                                    type: n.b.MEDIA_ERROR,
                                    details: n.a.FRAG_PARSING_ERROR,
                                    fatal: !1,
                                    reason: "TS packet did not start with 0x47"
                                });
                        l.pesData = p,
                        c.pesData = m,
                        u.pesData = T;
                        var R = {
                            audioTrack: c,
                            avcTrack: l,
                            id3Track: u,
                            textTrack: this._txtTrack
                        };
                        return o && this.extractRemainingSamples(R),
                        R
                    }
                    ,
                    t.flush = function() {
                        var e, t = this.remainderData;
                        return this.remainderData = null,
                        e = t ? this.demux(t, -1, !1, !0) : {
                            audioTrack: this._audioTrack,
                            avcTrack: this._avcTrack,
                            textTrack: this._txtTrack,
                            id3Track: this._id3Track
                        },
                        this.extractRemainingSamples(e),
                        this.sampleAes ? this.decrypt(e, this.sampleAes) : e
                    }
                    ,
                    t.extractRemainingSamples = function(e) {
                        var t, r = e.audioTrack, i = e.avcTrack, n = e.id3Track, a = i.pesData, o = r.pesData, s = n.pesData, l = i.streamType;
                        a && (t = se(a)) ? (l === q.HEVC || l === q.AVC ? this.parseVideoPES(t, !0, l) : g.b.error("unsupported video stream type"),
                        i.pesData = null) : i.pesData = a,
                        o && (t = se(o)) ? (r.isAAC ? this.parseAACPES(t) : this.parseMPEGPES(t),
                        r.pesData = null) : (null != o && o.size && g.b.log("last AAC PES packet truncated, might overlap between fragments"),
                        r.pesData = o),
                        s && (t = se(s)) ? (this.parseID3PES(t),
                        n.pesData = null) : n.pesData = s
                    }
                    ,
                    t.demuxSampleAes = function(e, t, r) {
                        var i = this.demux(e, r, !0, !this.config.progressive)
                          , n = this.sampleAes = new H(this.observer,this.config,t);
                        return this.decrypt(i, n)
                    }
                    ,
                    t.decrypt = function(e, t) {
                        return new Promise((function(r) {
                            var i = e.audioTrack
                              , n = e.avcTrack;
                            i.samples && i.isAAC ? t.decryptAacSamples(i.samples, 0, (function() {
                                n.samples ? t.decryptAvcSamples(n.samples, 0, 0, (function() {
                                    r(e)
                                }
                                )) : r(e)
                            }
                            )) : n.samples && t.decryptAvcSamples(n.samples, 0, 0, (function() {
                                r(e)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    t.destroy = function() {
                        this._initPTS = this._initDTS = null,
                        this._duration = 0
                    }
                    ,
                    t.parseVideoPES = function(e, t, r) {
                        var i = this._avcTrack
                          , n = this.parseVideoNALu(e.data, r)
                          , a = this.avcSample;
                        e.data = null,
                        a && n.length && !i.audFound && (le(a, i),
                        a = this.avcSample = ne(!1, e.pts, e.dts, "")),
                        r === q.AVC ? this.parseAVCUnitsByType(n, e) : r === q.HEVC && this.parseHEVCUnitsByType(n, e),
                        t && this.avcSample && (le(this.avcSample, i),
                        this.avcSample = null)
                    }
                    ,
                    t.parseAVCUnitsByType = function(e, t) {
                        var r, i = this, n = this._avcTrack, a = this.avcSample, o = !1;
                        e.forEach((function(e) {
                            switch (e.type) {
                            case 1:
                                r = !0,
                                a || (a = i.avcSample = ne(!0, t.pts, t.dts, "")),
                                a.frame = !0;
                                var s = e.data;
                                if (o && s.length > 4) {
                                    var l = new G(s).readSliceType();
                                    2 !== l && 4 !== l && 7 !== l && 9 !== l || (a.key = !0)
                                }
                                break;
                            case 5:
                                r = !0,
                                a || (a = i.avcSample = ne(!0, t.pts, t.dts, "")),
                                a.key = !0,
                                a.frame = !0;
                                break;
                            case 6:
                                r = !0,
                                Object(h.g)(ce(e.data), 1, t.pts, i._txtTrack.samples);
                                break;
                            case 7:
                                if (r = !0,
                                o = !0,
                                !n.sps) {
                                    var c = new G(e.data).readSPS();
                                    n.width = c.width,
                                    n.height = c.height,
                                    n.pixelRatio = c.pixelRatio,
                                    n.sps = [e.data],
                                    n.duration = i._duration,
                                    n.videoMediaInfo = {
                                        colorPrimaries: c.colorSpace,
                                        bitDepth: c.bitDepth,
                                        transferCharacteristics: c.transfer,
                                        pixelFormat: c.chromaFormat
                                    };
                                    for (var u = e.data.subarray(1, 4), d = "avc1.", f = 0; f < 3; f++) {
                                        var p = u[f].toString(16);
                                        p.length < 2 && (p = "0" + p),
                                        d += p
                                    }
                                    n.codec = d
                                }
                                break;
                            case 8:
                                r = !0,
                                n.pps || (n.pps = [e.data]);
                                break;
                            case 9:
                                r = !1,
                                n.audFound = !0,
                                a && le(a, n),
                                a = i.avcSample = ne(!1, t.pts, t.dts, "");
                                break;
                            case 12:
                                r = !0;
                                break;
                            default:
                                r = !1,
                                a && (a.debug += "unknown NAL " + e.type + " ")
                            }
                            a && r && a.units.push(e)
                        }
                        ))
                    }
                    ,
                    t.parseHEVCUnitsByType = function(e, t) {
                        var r, i = this, n = this._avcTrack, a = this.avcSample, o = [];
                        e.forEach((function(e) {
                            switch (e.type) {
                            case V.SLICE_RADL_N:
                            case V.SLICE_RADL_R:
                            case V.SLICE_RASL_N:
                            case V.SLICE_STSA_N:
                            case V.SLICE_STSA_R:
                            case V.SLICE_TLA_R:
                            case V.SLICE_TSA_N:
                            case V.SLICE_TRAIL_N:
                            case V.SLICE_TRAIL_R:
                            case V.SLICE_BLA_W_LP:
                            case V.SLICE_BLA_N_LP:
                            case V.SLICE_BLA_W_RADL:
                            case V.SLICE_IDR_N_LP:
                            case V.SLICE_IDR_W_RADL:
                            case V.SLICE_CRA:
                            case V.SLICE_RSV_IRAP_VCL22:
                            case V.SLICE_RSV_IRAP_VCL23:
                                J(e.type) && (n.firstFound || (n.firstFound = !0),
                                a || (a = i.avcSample = ne(!0, t.pts, t.dts, ""))),
                                r = !!n.firstFound;
                                break;
                            case V.VPS:
                                if (r = !0,
                                !n.vps) {
                                    var s = function(e) {
                                        var t = new Q(ce(e.subarray(2)))
                                          , r = t.readBits(4)
                                          , i = t.readBits(1)
                                          , n = t.readBits(1)
                                          , a = t.readBits(6)
                                          , o = t.readBits(3);
                                        return t.readBits(1),
                                        t.skipBits(16),
                                        {
                                            videoParameterSetId: r,
                                            baseLayerInternalFlag: i,
                                            baseLayerAvailableFlag: n,
                                            maxLayersMinus1: a,
                                            maxSubLayersMinus1: o,
                                            profileTierLevel: X(t, o)
                                        }
                                    }(e.data);
                                    n.vps = [e.data],
                                    n.profile_space = s.profileTierLevel.space,
                                    n.tier_flag = s.profileTierLevel.tier,
                                    n.profile_idc = s.profileTierLevel.idc,
                                    n.level_idc = s.profileTierLevel.level,
                                    n.compatability_flag_hex = function(e) {
                                        for (var t = [], r = 0; r < e.length; r += 8) {
                                            var i = e.slice(r, r + 8)
                                              , n = parseInt(i.join(""), 2);
                                            t.push(n)
                                        }
                                        return t
                                    }(s.profileTierLevel.compatability_flag)
                                }
                                break;
                            case V.SPS:
                                if (r = !0,
                                !n.sps) {
                                    var l = Z(e.data);
                                    n.sps = [e.data],
                                    n.codec = l.codec,
                                    n.width = l.width,
                                    n.height = l.height,
                                    n.duration = i._duration,
                                    n.chromaFormatIdc = l.chromaFormatIdc,
                                    n.bitDepthLumaMinus8 = l.bitDepthLumaMinus8,
                                    n.bitDepthChromaMinus8 = l.bitDepthChromaMinus8,
                                    n.videoMediaInfo = {
                                        colorPrimaries: l.colorSpace,
                                        transferCharacteristics: l.transfer,
                                        bitDepth: l.bitDepthChromaMinus8 + 8,
                                        pixelFormat: N.a[l.chromaFormatIdc]
                                    }
                                }
                                break;
                            case V.PPS:
                                r = !0,
                                o.push(e.data);
                                break;
                            case V.DELIMITER:
                                r = !1,
                                n.audFound = !0,
                                a && le(a, n),
                                a = i.avcSample = ne(!1, t.pts, t.dts, "");
                                break;
                            case V.PREFIX_SEI:
                            case V.SUFFIX_SEI:
                                r = !0;
                                var c = new DataView(e.data.buffer,e.data.byteOffset,e.data.byteLength).getUint8(2);
                                137 === c ? function(e, t) {
                                    e.readBits(16),
                                    e.readBits(16);
                                    for (var r = [[0, 0], [0, 0], [0, 0]], i = 0; i < 3; i += 1)
                                        r[i][0] = e.readBits(16),
                                        r[i][1] = e.readBits(16);
                                    var n = e.readBits(16)
                                      , a = e.readBits(16)
                                      , o = e.readBits(32)
                                      , s = e.readBits(32);
                                    te(t),
                                    t.hdrStaticMetadata.maxDisplayMasteringLuminance = o,
                                    t.hdrStaticMetadata.minDisplayMasteringLuminance = s,
                                    t.hdrStaticMetadata.displayPrimaries = r,
                                    t.hdrStaticMetadata.whitePoint = [n, a]
                                }(new Q(ce(e.data)), n) : 144 === c ? function(e, t) {
                                    e.readBits(16),
                                    e.readBits(16);
                                    var r = e.readBits(16)
                                      , i = e.readBits(16);
                                    te(t),
                                    t.hdrStaticMetadata.maxContentLightLevel = r,
                                    t.hdrStaticMetadata.maxPictureAverageLightLevel = i
                                }(new Q(ce(e.data)), n) : Object(h.g)(ce(e.data), 2, t.pts, i._txtTrack.samples);
                                break;
                            case V.EOS:
                            case V.EOB:
                                r = !1
                            }
                            if (a) {
                                var u = j[e.type];
                                "IDR" !== u && "NDR" !== u || (a.frame = !0),
                                J(e.type) && (a.key = !0,
                                !n.pps && o.length > 0 && (n.pps = o)),
                                r && a.units.push(e)
                            }
                        }
                        ))
                    }
                    ,
                    t.getLastNalUnit = function() {
                        var e, t, r = this.avcSample;
                        if (!r || 0 === r.units.length) {
                            var i = this._avcTrack.samples;
                            r = i[i.length - 1]
                        }
                        if (null !== (e = r) && void 0 !== e && e.units) {
                            var n = r.units;
                            t = n[n.length - 1]
                        }
                        return t
                    }
                    ,
                    t.parseVideoNALu = function(e, t) {
                        var r, i, n, a = e.byteLength, o = this._avcTrack, s = o.naluState || 0, l = s, c = [], h = 0, u = -1, d = 0;
                        for (-1 === s && (u = 0,
                        t === q.AVC ? d = 31 & e[0] : t === q.HEVC && (d = (126 & e[0]) >> 1),
                        s = 0,
                        h = 1); h < a; )
                            if (r = e[h++],
                            s)
                                if (1 !== s)
                                    if (r)
                                        if (1 === r) {
                                            if (u >= 0) {
                                                var f = {
                                                    data: e.subarray(u, h - s - 1),
                                                    type: d
                                                };
                                                c.push(f)
                                            } else {
                                                var p = this.getLastNalUnit();
                                                if (p && (l && h <= 4 - l && p.state && (p.data = p.data.subarray(0, p.data.byteLength - l)),
                                                (i = h - s - 1) > 0)) {
                                                    var g = new Uint8Array(p.data.byteLength + i);
                                                    g.set(p.data, 0),
                                                    g.set(e.subarray(0, i), p.data.byteLength),
                                                    p.data = g,
                                                    p.state = 0
                                                }
                                            }
                                            if (h < a) {
                                                if (t === q.AVC)
                                                    n = 31 & e[h];
                                                else {
                                                    if (t !== q.HEVC)
                                                        throw new Error("error naluType=" + t);
                                                    n = (126 & e[h]) >> 1
                                                }
                                                u = h,
                                                d = n,
                                                s = 0
                                            } else
                                                s = -1
                                        } else
                                            s = 0;
                                    else
                                        s = 3;
                                else
                                    s = r ? 0 : 2;
                            else
                                s = r ? 0 : 1;
                        if (u >= 0 && s >= 0) {
                            var v = {
                                data: e.subarray(u, a),
                                type: d,
                                state: s
                            };
                            c.push(v)
                        }
                        if (0 === c.length) {
                            var y = this.getLastNalUnit();
                            if (y) {
                                var m = new Uint8Array(y.data.byteLength + e.byteLength);
                                m.set(y.data, 0),
                                m.set(e, y.data.byteLength),
                                y.data = m
                            }
                        }
                        return o.naluState = s,
                        c
                    }
                    ,
                    t.parseAACPES = function(e) {
                        var t, r, a, o, s, l = 0, c = this._audioTrack, h = this.aacOverFlow, u = e.data;
                        if (h) {
                            this.aacOverFlow = null;
                            var d = h.sample.unit.byteLength
                              , f = Math.min(h.missing, d)
                              , p = d - f;
                            h.sample.unit.set(u.subarray(0, f), p),
                            c.samples.push(h.sample),
                            l = h.missing
                        }
                        for (t = l,
                        r = u.length; t < r - 1 && !T(u, t); t++)
                            ;
                        if (t === l || (t < r - 1 ? (a = "AAC PES did not start with ADTS header,offset:" + t,
                        o = !1) : (a = "no ADTS header found in AAC PES",
                        o = !0),
                        g.b.warn("parsing error:" + a),
                        this.observer.emit(i.a.ERROR, i.a.ERROR, {
                            type: n.b.MEDIA_ERROR,
                            details: n.a.FRAG_PARSING_ERROR,
                            fatal: o,
                            reason: a
                        }),
                        !o)) {
                            if (I(c, this.observer, u, t, this.audioCodec, this.config.useSBRWorkaround),
                            void 0 !== e.pts)
                                s = e.pts;
                            else {
                                if (!h)
                                    return void g.b.warn("[tsdemuxer]: AAC PES unknown PTS");
                                var v = P(c.samplerate);
                                s = h.sample.pts + v
                            }
                            for (var y = 0; t < r; ) {
                                if (T(u, t)) {
                                    if (t + 5 < r) {
                                        var m = b(c, u, t, s, y);
                                        if (m) {
                                            if (!m.missing) {
                                                t += m.length,
                                                y++;
                                                continue
                                            }
                                            this.aacOverFlow = m
                                        }
                                    }
                                    break
                                }
                                t++
                            }
                        }
                    }
                    ,
                    t.parseMPEGPES = function(e) {
                        var t = e.data
                          , r = t.length
                          , i = 0
                          , n = 0
                          , a = e.pts;
                        if (void 0 !== a)
                            for (; n < r; )
                                if (B(t, n)) {
                                    var o = x(this._audioTrack, t, n, a, i);
                                    if (!o)
                                        break;
                                    n += o.length,
                                    i++
                                } else
                                    n++;
                        else
                            g.b.warn("[tsdemuxer]: MPEG PES unknown PTS")
                    }
                    ,
                    t.parseID3PES = function(e) {
                        void 0 !== e.pts ? this._id3Track.samples.push(e) : g.b.warn("[tsdemuxer]: ID3 PES unknown PTS")
                    }
                    ,
                    e
                }();
                function ne(e, t, r, i) {
                    return {
                        key: e,
                        frame: !1,
                        pts: t,
                        dts: r,
                        units: [],
                        debug: i,
                        length: 0
                    }
                }
                function ae(e, t) {
                    return (31 & e[t + 10]) << 8 | e[t + 11]
                }
                function oe(e, t, r, i) {
                    var n = {
                        audio: -1,
                        avc: -1,
                        id3: -1,
                        isAAC: !0,
                        videoStreamType: -1
                    }
                      , a = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
                    for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < a; ) {
                        var o = (31 & e[t + 1]) << 8 | e[t + 2]
                          , s = e[t];
                        switch (s) {
                        case 207:
                            if (!i) {
                                g.b.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                                break
                            }
                        case 15:
                            -1 === n.audio && (n.audio = o);
                            break;
                        case 21:
                            -1 === n.id3 && (n.id3 = o);
                            break;
                        case 219:
                            if (!i) {
                                g.b.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                                break
                            }
                        case 27:
                            -1 === n.avc && (n.avc = o,
                            n.videoStreamType = s);
                            break;
                        case 3:
                        case 4:
                            r ? -1 === n.audio && (n.audio = o,
                            n.isAAC = !1) : g.b.log("MPEG audio found, not supported in this browser");
                            break;
                        case 36:
                            -1 === n.avc && (n.avc = o,
                            n.videoStreamType = s)
                        }
                        t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
                    }
                    return n
                }
                function se(e) {
                    var t, r, i, n, a, o = 0, s = e.data;
                    if (!e || 0 === e.size)
                        return null;
                    for (; s[0].length < 19 && s.length > 1; ) {
                        var l = new Uint8Array(s[0].length + s[1].length);
                        l.set(s[0]),
                        l.set(s[1], s[0].length),
                        s[0] = l,
                        s.splice(1, 1)
                    }
                    if (1 === ((t = s[0])[0] << 16) + (t[1] << 8) + t[2]) {
                        if ((r = (t[4] << 8) + t[5]) && r > e.size - 6)
                            return null;
                        var c = t[7];
                        192 & c && (n = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2,
                        64 & c ? n - (a = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) > 54e5 && (g.b.warn(Math.round((n - a) / 9e4) + "s delta between PTS and DTS, align them"),
                        n = a) : a = n);
                        var h = (i = t[8]) + 9;
                        if (e.size <= h)
                            return null;
                        e.size -= h;
                        for (var u = new Uint8Array(e.size), d = 0, f = s.length; d < f; d++) {
                            var p = (t = s[d]).byteLength;
                            if (h) {
                                if (h > p) {
                                    h -= p;
                                    continue
                                }
                                t = t.subarray(h),
                                p -= h,
                                h = 0
                            }
                            u.set(t, o),
                            o += p
                        }
                        return r && (r -= i + 3),
                        {
                            data: u,
                            pts: n,
                            dts: a,
                            len: r
                        }
                    }
                    return null
                }
                function le(e, t) {
                    if (e.units.length && e.frame) {
                        if (void 0 === e.pts) {
                            var r = t.samples
                              , i = r.length;
                            if (!i)
                                return void t.dropped++;
                            var n = r[i - 1];
                            e.pts = n.pts,
                            e.dts = n.dts
                        }
                        t.samples.push(e)
                    }
                    e.debug.length && g.b.log(e.pts + "/" + e.dts + ":" + e.debug)
                }
                function ce(e) {
                    for (var t = e.byteLength, r = [], i = 1; i < t - 2; )
                        0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2] ? (r.push(i + 2),
                        i += 2) : i++;
                    if (0 === r.length)
                        return e;
                    var n = t - r.length
                      , a = new Uint8Array(n)
                      , o = 0;
                    for (i = 0; i < n; o++,
                    i++)
                        o === r[0] && (o++,
                        r.shift()),
                        a[i] = e[o];
                    return a
                }
                ie.minProbeByteLength = 188;
                var he = ie
                  , ue = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    s()(t, e);
                    var r = t.prototype;
                    return r.resetInitSegment = function(t, r, i) {
                        e.prototype.resetInitSegment.call(this, t, r, i),
                        this._audioTrack = {
                            container: "audio/mpeg",
                            type: "audio",
                            id: 0,
                            pid: -1,
                            sequenceNumber: 0,
                            isAAC: !1,
                            samples: [],
                            manifestCodec: t,
                            duration: i,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    ,
                    t.probe = function(e) {
                        if (!e)
                            return !1;
                        for (var t = (c.b(e, 0) || []).length, r = e.length; t < r; t++)
                            if (M(e, t))
                                return g.b.log("MPEG Audio sync word found !"),
                                !0;
                        return !1
                    }
                    ,
                    r.abort = function() {}
                    ,
                    r.canParse = function(e, t) {
                        return function(e, t) {
                            return F(e, t) && 4 <= e.length - t
                        }(e, t)
                    }
                    ,
                    r.appendFrame = function(e, t, r) {
                        if (null !== this.initPTS)
                            return x(e, t, r, this.initPTS, this.frameIndex)
                    }
                    ,
                    t
                }(p);
                ue.minProbeByteLength = 4;
                var de = ue
                  , fe = r(16)
                  , pe = r.n(fe)
                  , ge = function() {
                    function e() {}
                    return e.getSilentFrame = function(e, t) {
                        if ("mp4a.40.2" === e) {
                            if (1 === t)
                                return new Uint8Array([0, 200, 0, 128, 35, 128]);
                            if (2 === t)
                                return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                            if (3 === t)
                                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                            if (4 === t)
                                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                            if (5 === t)
                                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                            if (6 === t)
                                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
                        } else {
                            if (1 === t)
                                return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                            if (2 === t)
                                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                            if (3 === t)
                                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
                        }
                    }
                    ,
                    e
                }()
                  , ve = Math.pow(2, 32) - 1
                  , ye = function() {
                    function e() {}
                    return e.init = function() {
                        var t;
                        for (t in e.types = {
                            avc1: [],
                            avcC: [],
                            hvcC: [],
                            hvc1: [],
                            btrt: [],
                            dinf: [],
                            dref: [],
                            esds: [],
                            ftyp: [],
                            hdlr: [],
                            mdat: [],
                            mdhd: [],
                            mdia: [],
                            mfhd: [],
                            minf: [],
                            moof: [],
                            moov: [],
                            mp4a: [],
                            ".mp3": [],
                            mvex: [],
                            mvhd: [],
                            pasp: [],
                            sdtp: [],
                            stbl: [],
                            stco: [],
                            stsc: [],
                            stsd: [],
                            stsz: [],
                            stts: [],
                            tfdt: [],
                            tfhd: [],
                            traf: [],
                            trak: [],
                            trun: [],
                            trex: [],
                            tkhd: [],
                            vmhd: [],
                            smhd: [],
                            mdcv: [],
                            clli: []
                        },
                        e.types)
                            e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                        var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0])
                          , i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                        e.HDLR_TYPES = {
                            video: r,
                            audio: i
                        };
                        var n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])
                          , a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                        e.STTS = e.STSC = e.STCO = a,
                        e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
                        e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]),
                        e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
                        e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                        var o = new Uint8Array([105, 115, 111, 109])
                          , s = new Uint8Array([97, 118, 99, 49])
                          , l = new Uint8Array([0, 0, 0, 1]);
                        e.FTYP = e.box(e.types.ftyp, o, l, o, s),
                        e.FTYP_HVC1 = e.box(e.types.ftyp, new Uint8Array([105, 115, 111, 53, 0, 0, 0, 1, 105, 115, 111, 104, 104, 118, 99, 49, 105, 115, 111, 53, 100, 97, 115, 104])),
                        e.DINF = e.box(e.types.dinf, e.box(e.types.dref, n))
                    }
                    ,
                    e.box = function(e) {
                        for (var t = 8, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)
                            i[n - 1] = arguments[n];
                        for (var a = i.length, o = a; a--; )
                            t += i[a].byteLength;
                        var s = new Uint8Array(t);
                        for (s[0] = t >> 24 & 255,
                        s[1] = t >> 16 & 255,
                        s[2] = t >> 8 & 255,
                        s[3] = 255 & t,
                        s.set(e, 4),
                        a = 0,
                        t = 8; a < o; a++)
                            s.set(i[a], t),
                            t += i[a].byteLength;
                        return s
                    }
                    ,
                    e.hdlr = function(t) {
                        return e.box(e.types.hdlr, e.HDLR_TYPES[t])
                    }
                    ,
                    e.mdat = function(t) {
                        return e.box(e.types.mdat, t)
                    }
                    ,
                    e.mdhd = function(t, r) {
                        r *= t;
                        var i = Math.floor(r / (ve + 1))
                          , n = Math.floor(r % (ve + 1));
                        return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 85, 196, 0, 0]))
                    }
                    ,
                    e.mdia = function(t) {
                        return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t))
                    }
                    ,
                    e.mfhd = function(t) {
                        return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
                    }
                    ,
                    e.minf = function(t) {
                        return "audio" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t))
                    }
                    ,
                    e.moof = function(t, r, i) {
                        return e.box(e.types.moof, e.mfhd(t), e.traf(i, r))
                    }
                    ,
                    e.moov = function(t) {
                        for (var r = t.length, i = []; r--; )
                            i[r] = e.trak(t[r]);
                        return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(e.mvex(t)))
                    }
                    ,
                    e.mvex = function(t) {
                        for (var r = t.length, i = []; r--; )
                            i[r] = e.trex(t[r]);
                        return e.box.apply(null, [e.types.mvex].concat(i))
                    }
                    ,
                    e.mvhd = function(t, r) {
                        r *= t;
                        var i = Math.floor(r / (ve + 1))
                          , n = Math.floor(r % (ve + 1))
                          , a = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                        return e.box(e.types.mvhd, a)
                    }
                    ,
                    e.sdtp = function(t) {
                        var r, i, n = t.samples || [], a = new Uint8Array(4 + n.length);
                        for (r = 0; r < n.length; r++)
                            i = n[r].flags,
                            a[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;
                        return e.box(e.types.sdtp, a)
                    }
                    ,
                    e.stbl = function(t) {
                        return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO))
                    }
                    ,
                    e.hvc1 = function(t) {
                        var r, i, n, a = [], o = [], s = [], l = t.vps.length;
                        for (a.push(160),
                        a.push(l >>> 8 & 255),
                        a.push(255 & l),
                        r = 0; r < l; r++)
                            n = (i = t.vps[r]).byteLength,
                            a.push(n >>> 8 & 255),
                            a.push(255 & n),
                            a = a.concat(Array.prototype.slice.call(i));
                        for (l = t.sps.length,
                        o.push(161),
                        o.push(l >>> 8 & 255),
                        o.push(255 & l),
                        r = 0; r < l; r++)
                            n = (i = t.sps[r]).byteLength,
                            o.push(n >>> 8 & 255),
                            o.push(255 & n),
                            o = o.concat(Array.prototype.slice.call(i));
                        for (l = t.pps.length,
                        s.push(162),
                        s.push(l >>> 8 & 255),
                        s.push(255 & l),
                        r = 0; r < l; r++)
                            n = (i = t.pps[r]).byteLength,
                            s.push(n >>> 8 & 255),
                            s.push(255 & n),
                            s = s.concat(Array.prototype.slice.call(i));
                        var c = e.box(e.types.hvcC, new Uint8Array([1, t.profile_space << 6 | t.tier_flag << 5 | t.profile_idc, t.compatability_flag_hex[0], t.compatability_flag_hex[1], t.compatability_flag_hex[2], t.compatability_flag_hex[3], 0, 0, 0, 0, 0, 0, t.level_idc, 240, 0, 252, 252 | t.chromaFormatIdc, 248 | t.bitDepthLumaMinus8, 248 | t.bitDepthChromaMinus8, 0, 0, 3, 3].concat(a).concat(o).concat(s)))
                          , h = t.width
                          , u = t.height
                          , d = t.hdrStaticMetadata;
                        return new Uint8Array(0),
                        new Uint8Array(0),
                        d && (e.box(e.types.mdcv, new Uint8Array([d.displayPrimaries[0][0] >> 8 & 255, 255 & d.displayPrimaries[0][0], d.displayPrimaries[0][1] >> 8 & 255, 255 & d.displayPrimaries[0][1], d.displayPrimaries[1][0] >> 8 & 255, 255 & d.displayPrimaries[1][0], d.displayPrimaries[1][1] >> 8 & 255, 255 & d.displayPrimaries[1][1], d.displayPrimaries[2][0] >> 8 & 255, 255 & d.displayPrimaries[2][0], d.displayPrimaries[2][1] >> 8 & 255, 255 & d.displayPrimaries[2][1], d.whitePoint[0] >> 8 & 255, 255 & d.whitePoint[0], d.whitePoint[1] >> 8 & 255, 255 & d.whitePoint[1], d.maxDisplayMasteringLuminance >> 24 & 255, d.maxDisplayMasteringLuminance >> 16 & 255, d.maxDisplayMasteringLuminance >> 8 & 255, 255 & d.maxDisplayMasteringLuminance, d.minDisplayMasteringLuminance >> 24 & 255, d.minDisplayMasteringLuminance >> 16 & 255, d.minDisplayMasteringLuminance >> 8 & 255, 255 & d.minDisplayMasteringLuminance])),
                        e.box(e.types.clli, new Uint8Array([d.maxContentLightLevel >> 8 & 255, 255 & d.maxContentLightLevel, d.maxPictureAverageLightLevel >> 8 & 255, 255 & d.maxPictureAverageLightLevel]))),
                        e.box(e.types.hvc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, h >> 8 & 255, 255 & h, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 12, 116, 101, 110, 99, 101, 110, 116, 118, 105, 100, 101, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]), c, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])))
                    }
                    ,
                    e.avc1 = function(t) {
                        var r, i, n, a = [], o = [];
                        for (r = 0; r < t.sps.length; r++)
                            n = (i = t.sps[r]).byteLength,
                            a.push(n >>> 8 & 255),
                            a.push(255 & n),
                            a = a.concat(Array.prototype.slice.call(i));
                        for (r = 0; r < t.pps.length; r++)
                            n = (i = t.pps[r]).byteLength,
                            o.push(n >>> 8 & 255),
                            o.push(255 & n),
                            o = o.concat(Array.prototype.slice.call(i));
                        var s = e.box(e.types.avcC, new Uint8Array([1, a[3], a[4], a[5], 255, 224 | t.sps.length].concat(a).concat([t.pps.length]).concat(o)))
                          , l = t.width
                          , c = t.height
                          , h = t.pixelRatio[0]
                          , u = t.pixelRatio[1];
                        return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, c >> 8 & 255, 255 & c, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), s, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h, u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u])))
                    }
                    ,
                    e.esds = function(e) {
                        var t = e.config;
                        return new Uint8Array([0, 0, 0, 0, 3, 27, 0, 1, 0, 4, 19, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4].concat(t, [6, 1, 2]))
                    }
                    ,
                    e.mp4a = function(t) {
                        var r = t.samplerate;
                        return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t)))
                    }
                    ,
                    e.mp3 = function(t) {
                        var r = t.samplerate;
                        return e.box(e.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]))
                    }
                    ,
                    e.stsd = function(t) {
                        return "audio" === t.type ? t.isAAC || "mp3" !== t.codec ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.mp3(t)) : 36 === t.streamType ? e.box(e.types.stsd, e.STSD, e.hvc1(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t))
                    }
                    ,
                    e.tkhd = function(t) {
                        var r = t.id
                          , i = t.duration * t.timescale
                          , n = t.width
                          , a = t.height
                          , o = Math.floor(i / (ve + 1))
                          , s = Math.floor(i % (ve + 1));
                        return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, n >> 8 & 255, 255 & n, 0, 0, a >> 8 & 255, 255 & a, 0, 0]))
                    }
                    ,
                    e.traf = function(t, r) {
                        var i = e.sdtp(t)
                          , n = t.id;
                        r < 0 && (r = 0);
                        var a = Math.floor(r / (ve + 1))
                          , o = Math.floor(r % (ve + 1));
                        return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o])), e.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
                    }
                    ,
                    e.trak = function(t) {
                        return t.duration = t.duration || 4294967295,
                        e.box(e.types.trak, e.tkhd(t), e.mdia(t))
                    }
                    ,
                    e.trex = function(t) {
                        var r = t.id;
                        return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                    }
                    ,
                    e.trun = function(t, r) {
                        var i, n, a, o, s, l, c = t.samples || [], h = c.length, u = 12 + 16 * h, d = new Uint8Array(u);
                        for (r += 8 + u,
                        d.set([0, 0, 15, 1, h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0),
                        i = 0; i < h; i++)
                            a = (n = c[i]).duration,
                            o = n.size,
                            s = n.flags,
                            l = n.cts,
                            d.set([a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o, s.isLeading << 2 | s.dependsOn, s.isDependedOn << 6 | s.hasRedundancy << 4 | s.paddingValue << 1 | s.isNonSync, 61440 & s.degradPrio, 15 & s.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);
                        return e.box(e.types.trun, d)
                    }
                    ,
                    e.initSegment = function(t) {
                        e.types || e.init();
                        var r, i = e.moov(t);
                        return "video" === t[0].type && 36 === t[0].streamType ? ((r = new Uint8Array(e.FTYP_HVC1.byteLength + i.byteLength)).set(e.FTYP_HVC1),
                        r.set(i, e.FTYP_HVC1.byteLength)) : ((r = new Uint8Array(e.FTYP.byteLength + i.byteLength)).set(e.FTYP),
                        r.set(i, e.FTYP.byteLength)),
                        r
                    }
                    ,
                    e
                }();
                ye.types = void 0,
                ye.HDLR_TYPES = void 0,
                ye.STTS = void 0,
                ye.STSC = void 0,
                ye.STCO = void 0,
                ye.STSZ = void 0,
                ye.VMHD = void 0,
                ye.SMHD = void 0,
                ye.STSD = void 0,
                ye.FTYP = void 0,
                ye.FTYP_HVC1 = void 0,
                ye.DINF = void 0;
                var me = ye
                  , Te = r(4);
                function Se(e, t, r, i) {
                    void 0 === r && (r = 1),
                    void 0 === i && (i = !1);
                    var n = e * t * r;
                    return i ? Math.round(n) : n
                }
                function Ie(e, t) {
                    return void 0 === t && (t = !1),
                    Se(e, 1e3, 1 / 9e4, t)
                }
                function Pe(e, t) {
                    var r = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var i = Object.getOwnPropertySymbols(e);
                        t && (i = i.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }
                        ))),
                        r.push.apply(r, i)
                    }
                    return r
                }
                function be(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var r = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? Pe(Object(r), !0).forEach((function(t) {
                            pe()(e, t, r[t])
                        }
                        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Pe(Object(r)).forEach((function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                        }
                        ))
                    }
                    return e
                }
                var Ee = null
                  , De = null
                  , ke = function() {
                    function e(e, t, r, i) {
                        if (void 0 === i && (i = ""),
                        this.observer = void 0,
                        this.config = void 0,
                        this.typeSupported = void 0,
                        this.ISGenerated = !1,
                        this._initPTS = void 0,
                        this._initDTS = void 0,
                        this.nextAvcDts = null,
                        this.nextAudioPts = null,
                        this.isAudioContiguous = !1,
                        this.isVideoContiguous = !1,
                        this.observer = e,
                        this.config = t,
                        this.typeSupported = r,
                        this.ISGenerated = !1,
                        null === Ee) {
                            var n = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                            Ee = n ? parseInt(n[1]) : 0
                        }
                        if (null === De) {
                            var a = navigator.userAgent.match(/Safari\/(\d+)/i);
                            De = a ? parseInt(a[1]) : 0
                        }
                    }
                    var t = e.prototype;
                    return t.abort = function() {}
                    ,
                    t.destroy = function() {}
                    ,
                    t.resetTimeStamp = function(e) {
                        g.b.log("[mp4-remuxer]: initPTS & initDTS reset", e),
                        this._initPTS = this._initDTS = e
                    }
                    ,
                    t.resetNextTimestamp = function() {
                        g.b.log("[mp4-remuxer]: reset next timestamp"),
                        this.isVideoContiguous = !1,
                        this.isAudioContiguous = !1
                    }
                    ,
                    t.resetInitSegment = function() {
                        g.b.log("[mp4-remuxer]: ISGenerated flag reset"),
                        this.ISGenerated = !1
                    }
                    ,
                    t.getVideoStartPts = function(e) {
                        var t = !1
                          , r = e.reduce((function(e, r) {
                            var i = r.pts - e;
                            return i < -4294967296 ? (t = !0,
                            Ce(e, r.pts)) : i > 0 ? e : r.pts
                        }
                        ), e[0].pts);
                        return t && g.b.debug("PTS rollover detected"),
                        r
                    }
                    ,
                    t.remux = function(e, t, r, i, n, a, o, s) {
                        var l, c, h, u, d, f, p = n, v = n, y = e.pid > -1, m = t.pid > -1, T = t.samples.length, S = e.samples.length > 0, I = T > 1;
                        if ((!y || S) && (!m || I) || this.ISGenerated || o) {
                            this.ISGenerated || (h = this.generateIS(e, t, n));
                            var P = this.isVideoContiguous
                              , b = -1;
                            if (I && (b = function(e) {
                                for (var t = 0; t < e.length; t++)
                                    if (e[t].key)
                                        return t;
                                return -1
                            }(t.samples),
                            !P && this.config.forceKeyFrameOnDiscontinuity))
                                if (f = !0,
                                b > 0) {
                                    g.b.warn("[mp4-remuxer]: Dropped " + b + " out of " + T + " video samples due to a missing keyframe");
                                    var E = this.getVideoStartPts(t.samples);
                                    t.samples = t.samples.slice(b),
                                    t.dropped += b,
                                    v += (t.samples[0].pts - E) / (t.timescale || 9e4)
                                } else
                                    -1 === b && (g.b.warn("[mp4-remuxer]: No keyframe found out of " + T + " video samples"),
                                    f = !1);
                            if (this.ISGenerated) {
                                if (S && I) {
                                    var D = this.getVideoStartPts(t.samples)
                                      , k = (Ce(e.samples[0].pts, D) - D) / t.inputTimeScale;
                                    p += Math.max(0, k),
                                    v += Math.max(0, -k)
                                }
                                if (S) {
                                    if (e.samplerate || (g.b.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"),
                                    h = this.generateIS(e, t, n)),
                                    c = this.remuxAudio(e, p, this.isAudioContiguous, a, m || I || s === Te.b.AUDIO ? v : void 0),
                                    I) {
                                        var C = c ? c.endPTS - c.startPTS : 0;
                                        t.inputTimeScale || (g.b.warn("[mp4-remuxer]: regenerate InitSegment as video detected"),
                                        h = this.generateIS(e, t, n)),
                                        l = this.remuxVideo(t, v, P, C)
                                    }
                                } else
                                    I && (l = this.remuxVideo(t, v, P, 0));
                                l && (l.firstKeyFrame = b,
                                l.independent = -1 !== b)
                            }
                        }
                        return this.ISGenerated && (r.samples.length && (d = this.remuxID3(r, n)),
                        i.samples.length && (u = this.remuxText(i, n))),
                        {
                            audio: c,
                            video: l,
                            initSegment: h,
                            independent: f,
                            text: u,
                            id3: d
                        }
                    }
                    ,
                    t.generateIS = function(e, t, r) {
                        var i, n, a, o, s, c = e.samples, h = t.samples, u = this.typeSupported, d = {}, f = !Object(l.a)(this._initPTS), p = "audio/mp4";
                        if (f && (i = n = 1 / 0),
                        e.config && c.length && (e.timescale = e.samplerate,
                        e.isAAC || (u.mpeg ? (p = "audio/mpeg",
                        e.codec = "") : u.mp3 && (e.codec = "mp3")),
                        d.audio = {
                            id: "audio",
                            container: p,
                            codec: e.codec,
                            initSegment: !e.isAAC && u.mpeg ? new Uint8Array(0) : me.initSegment([e]),
                            metadata: {
                                channelCount: e.channelCount
                            }
                        },
                        f && (a = e.inputTimeScale,
                        i = n = c[0].pts - Math.round(a * r),
                        s = c[0].pts)),
                        t.sps && t.pps && h.length && (t.timescale = t.inputTimeScale,
                        d.video = {
                            id: "main",
                            container: "video/mp4",
                            codec: t.codec,
                            initSegment: me.initSegment([t]),
                            metadata: be({
                                width: t.width,
                                height: t.height
                            }, t.videoMediaInfo)
                        },
                        f)) {
                            a = t.inputTimeScale;
                            var g = o = this.getVideoStartPts(h)
                              , v = Math.round(a * r);
                            n = Math.min(n, Ce(h[0].dts, g) - v),
                            i = Math.min(i, g - v)
                        }
                        if (Object.keys(d).length)
                            return this.ISGenerated = !0,
                            f && (this._initPTS = i,
                            this._initDTS = n),
                            {
                                tracks: d,
                                initPTS: i,
                                videoStartPts: o,
                                audioStartPts: s,
                                timescale: a
                            }
                    }
                    ,
                    t.remuxVideo = function(e, t, r, a) {
                        var o, s, l, c = e.inputTimeScale, h = e.samples, u = [], d = h.length, f = this._initPTS, p = this.nextAvcDts, v = 8, y = Number.POSITIVE_INFINITY, m = Number.NEGATIVE_INFINITY, T = 0, S = !1;
                        r && null !== p || (p = t * c - (h[0].pts - Ce(h[0].dts, h[0].pts)));
                        for (var I = 0; I < d; I++) {
                            var P = h[I];
                            P.pts = Ce(P.pts - f, p),
                            P.dts = Ce(P.dts - f, p),
                            P.dts > P.pts && (T = Math.max(Math.min(T, P.pts - P.dts), -18e3)),
                            P.dts < h[I > 0 ? I - 1 : I].dts && (S = !0)
                        }
                        S && h.sort((function(e, t) {
                            var r = e.dts - t.dts
                              , i = e.pts - t.pts;
                            return r || i
                        }
                        )),
                        s = h[0].dts,
                        l = h[h.length - 1].dts;
                        var b = Math.round((l - s) / (d - 1));
                        if (T < 0) {
                            if (T < -2 * b) {
                                g.b.warn("PTS < DTS detected in video samples, offsetting DTS from PTS by " + Ie(-b, !0) + " ms");
                                for (var E = T, D = 0; D < d; D++)
                                    h[D].dts = E = Math.max(E, h[D].pts - b),
                                    h[D].pts = Math.max(E, h[D].pts)
                            } else {
                                g.b.warn("PTS < DTS detected in video samples, shifting DTS by " + Ie(T, !0) + " ms to overcome this issue");
                                for (var k = 0; k < d; k++)
                                    h[k].dts = h[k].dts + T
                            }
                            s = h[0].dts
                        }
                        if (r) {
                            var C = s - p
                              , L = C > b
                              , w = C < -1;
                            if ((L || w) && (L ? g.b.warn("AVC: " + Ie(C, !0) + " ms (" + C + "dts) hole between fragments detected, filling it") : g.b.warn("AVC: " + Ie(-C, !0) + " ms (" + C + "dts) overlapping between fragments detected"),
                            !w || p >= h[0].pts || Ee)) {
                                s = p;
                                var R = h[0].pts - C;
                                if (L)
                                    h[0].dts = s,
                                    h[0].pts = R;
                                else
                                    for (var A = !0, _ = 0; _ < h.length && !(h[_].dts > R && A); _++) {
                                        var x = h[_].pts;
                                        if (h[_].dts -= C,
                                        h[_].pts -= C,
                                        _ < h.length - 1) {
                                            var O = h[_ + 1].pts;
                                            A = O <= h[_].pts == O <= x
                                        }
                                    }
                                g.b.log("Video: Initial PTS/DTS adjusted: " + Ie(R, !0) + "/" + Ie(s, !0) + ", delta: " + Ie(C, !0) + " ms")
                            }
                        }
                        for (var F = 0, B = 0, M = s = Math.max(0, s), U = 0; U < d; U++) {
                            for (var N = h[U], G = N.units, H = G.length, q = 0, z = 0; z < H; z++)
                                q += G[z].data.length;
                            B += q,
                            F += H,
                            N.length = q,
                            N.dts < M ? (N.dts = M,
                            M += b / 4 | 0 || 1) : M = N.dts,
                            N.pts = Math.max(N.pts, N.dts, 0),
                            y = Math.min(N.pts, y),
                            m = Math.max(N.pts, m)
                        }
                        l = h[d - 1].dts;
                        var V, j = B + 4 * F + 8;
                        try {
                            V = new Uint8Array(j)
                        } catch (e) {
                            return void this.observer.emit(i.a.ERROR, i.a.ERROR, {
                                type: n.b.MUX_ERROR,
                                details: n.a.REMUX_ALLOC_ERROR,
                                fatal: !1,
                                bytes: j,
                                reason: "fail allocating video mdat " + j
                            })
                        }
                        var W = new DataView(V.buffer);
                        W.setUint32(0, j),
                        V.set(me.types.mdat, 4);
                        for (var Y = 0; Y < d; Y++) {
                            for (var Q = h[Y], X = Q.units, Z = 0, J = 0, $ = X.length; J < $; J++) {
                                var ee = X[J]
                                  , te = ee.data
                                  , re = ee.data.byteLength;
                                W.setUint32(v, re),
                                v += 4,
                                V.set(te, v),
                                v += re,
                                Z += 4 + re
                            }
                            if (Y < d - 1)
                                o = h[Y + 1].dts - Q.dts;
                            else {
                                var ie = this.config
                                  , ne = Q.dts - h[Y > 0 ? Y - 1 : Y].dts;
                                if (ie.stretchShortVideoTrack && null !== this.nextAudioPts) {
                                    var ae = Math.floor(ie.maxBufferHole * c)
                                      , oe = (a ? y + a * c : this.nextAudioPts) - Q.pts;
                                    oe > ae ? ((o = oe - ne) < 0 && (o = ne),
                                    g.b.log("[mp4-remuxer]: It is approximately " + oe / 90 + " ms to the next segment; using duration " + o / 90 + " ms for the last video frame.")) : o = ne
                                } else
                                    o = ne
                            }
                            var se = Math.round(Q.pts - Q.dts);
                            u.push(new Le(Q.key,o,Z,se))
                        }
                        if (u.length && Ee && Ee < 70) {
                            var le = u[0].flags;
                            le.dependsOn = 2,
                            le.isNonSync = 0
                        }
                        this.nextAvcDts = p = l + o,
                        this.isVideoContiguous = !0;
                        var ce = {
                            data1: me.moof(e.sequenceNumber++, s, K()({}, e, {
                                samples: u
                            })),
                            data2: V,
                            startPTS: y / c,
                            endPTS: (m + o) / c,
                            startDTS: s / c,
                            endDTS: p / c,
                            type: "video",
                            hasAudio: !1,
                            hasVideo: !0,
                            nb: u.length,
                            dropped: e.dropped
                        };
                        return e.samples = [],
                        e.dropped = 0,
                        ce
                    }
                    ,
                    t.remuxAudio = function(e, t, r, a, o) {
                        var s = e.inputTimeScale
                          , l = s / (e.samplerate ? e.samplerate : s)
                          , c = e.isAAC ? 1024 : 1152
                          , h = c * l
                          , u = this._initPTS
                          , d = !e.isAAC && this.typeSupported.mpeg
                          , f = []
                          , p = void 0 !== o
                          , v = e.samples
                          , y = d ? 0 : 8
                          , m = this.nextAudioPts || -1
                          , T = t * s;
                        if (this.isAudioContiguous = r = r || v.length && m > 0 && (a && Math.abs(T - m) < 9e3 || Math.abs(Ce(v[0].pts - u, T) - m) < 20 * h),
                        v.forEach((function(e) {
                            e.pts = Ce(e.pts - u, T)
                        }
                        )),
                        !r || m < 0) {
                            if (!(v = v.filter((function(e) {
                                return e.pts >= 0
                            }
                            ))).length)
                                return;
                            m = 0 === o ? 0 : a && !p ? Math.max(0, T) : v[0].pts
                        }
                        if (e.isAAC)
                            for (var S = this.config.maxAudioFramesDrift, I = 0, P = m; I < v.length; I++) {
                                var b = v[I]
                                  , E = b.pts
                                  , D = E - P
                                  , k = Math.abs(1e3 * D / s);
                                if (D <= -S * h && p)
                                    0 === I && (g.b.warn("Audio frame @ " + (E / s).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * D / s) + " ms."),
                                    this.nextAudioPts = m = P = E);
                                else if (D >= S * h && k < 1e4 && p) {
                                    var C = Math.round(D / h);
                                    (P = E - C * h) < 0 && (C--,
                                    P += h),
                                    0 === I && (this.nextAudioPts = m = P),
                                    g.b.warn("[mp4-remuxer]: Injecting " + C + " audio frame @ " + (P / s).toFixed(3) + "s due to " + Math.round(1e3 * D / s) + " ms gap.");
                                    for (var L = 0; L < C; L++) {
                                        var w = Math.max(P, 0)
                                          , R = ge.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                                        R || (g.b.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."),
                                        R = b.unit.subarray()),
                                        v.splice(I, 0, {
                                            unit: R,
                                            pts: w
                                        }),
                                        P += h,
                                        I++
                                    }
                                }
                                b.pts = P,
                                P += h
                            }
                        for (var A, _ = null, x = null, O = 0, F = v.length; F--; )
                            O += v[F].unit.byteLength;
                        for (var B = 0, M = v.length; B < M; B++) {
                            var U = v[B]
                              , N = U.unit
                              , G = U.pts;
                            if (null !== x)
                                f[B - 1].duration = Math.round((G - x) / l);
                            else {
                                if (r && e.isAAC && (G = m),
                                _ = G,
                                !(O > 0))
                                    return;
                                O += y;
                                try {
                                    A = new Uint8Array(O)
                                } catch (e) {
                                    return void this.observer.emit(i.a.ERROR, i.a.ERROR, {
                                        type: n.b.MUX_ERROR,
                                        details: n.a.REMUX_ALLOC_ERROR,
                                        fatal: !1,
                                        bytes: O,
                                        reason: "fail allocating audio mdat " + O
                                    })
                                }
                                d || (new DataView(A.buffer).setUint32(0, O),
                                A.set(me.types.mdat, 4))
                            }
                            A.set(N, y);
                            var H = N.byteLength;
                            y += H,
                            f.push(new Le(!0,c,H,0)),
                            x = G
                        }
                        var q = f.length;
                        if (q) {
                            var z = f[f.length - 1];
                            this.nextAudioPts = m = x + l * z.duration;
                            var V = d ? new Uint8Array(0) : me.moof(e.sequenceNumber++, _ / l, K()({}, e, {
                                samples: f
                            }));
                            e.samples = [];
                            var j = _ / s
                              , W = m / s
                              , Y = {
                                data1: V,
                                data2: A,
                                startPTS: j,
                                endPTS: W,
                                startDTS: j,
                                endDTS: W,
                                type: "audio",
                                hasAudio: !0,
                                hasVideo: !1,
                                nb: q
                            };
                            return this.isAudioContiguous = !0,
                            Y
                        }
                    }
                    ,
                    t.remuxEmptyAudio = function(e, t, r, i) {
                        var n = e.inputTimeScale
                          , a = n / (e.samplerate ? e.samplerate : n)
                          , o = this.nextAudioPts
                          , s = (null !== o ? o : i.startDTS * n) + this._initDTS
                          , l = i.endDTS * n + this._initDTS
                          , c = 1024 * a
                          , h = Math.ceil((l - s) / c)
                          , u = ge.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                        if (g.b.warn("[mp4-remuxer]: remux empty Audio"),
                        u) {
                            for (var d = [], f = 0; f < h; f++) {
                                var p = s + f * c;
                                d.push({
                                    unit: u,
                                    pts: p,
                                    dts: p
                                })
                            }
                            return e.samples = d,
                            this.remuxAudio(e, t, r, !1)
                        }
                        g.b.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec")
                    }
                    ,
                    t.remuxID3 = function(e, t) {
                        var r = e.samples.length;
                        if (r) {
                            for (var i = e.inputTimeScale, n = this._initPTS, a = this._initDTS, o = 0; o < r; o++) {
                                var s = e.samples[o];
                                s.pts = Ce(s.pts - n, t * i) / i,
                                s.dts = Ce(s.dts - a, t * i) / i
                            }
                            var l = e.samples;
                            return e.samples = [],
                            {
                                samples: l
                            }
                        }
                    }
                    ,
                    t.remuxText = function(e, t) {
                        var r = e.samples.length;
                        if (r) {
                            for (var i = e.inputTimeScale, n = this._initPTS, a = 0; a < r; a++) {
                                var o = e.samples[a];
                                o.pts = Ce(o.pts - n, t * i) / i
                            }
                            e.samples.sort((function(e, t) {
                                return e.pts - t.pts
                            }
                            ));
                            var s = e.samples;
                            return e.samples = [],
                            {
                                samples: s
                            }
                        }
                    }
                    ,
                    e
                }();
                function Ce(e, t) {
                    var r;
                    if (null === t)
                        return e;
                    for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296; )
                        e += r;
                    return e
                }
                var Le = function(e, t, r, i) {
                    this.size = void 0,
                    this.duration = void 0,
                    this.cts = void 0,
                    this.flags = void 0,
                    this.duration = t,
                    this.size = r,
                    this.cts = i,
                    this.flags = new we(e)
                }
                  , we = function(e) {
                    this.isLeading = 0,
                    this.isDependedOn = 0,
                    this.hasRedundancy = 0,
                    this.degradPrio = 0,
                    this.dependsOn = 1,
                    this.isNonSync = 1,
                    this.dependsOn = e ? 2 : 1,
                    this.isNonSync = e ? 0 : 1
                }
                  , Re = r(6)
                  , Ae = function() {
                    function e() {
                        this.emitInitSegment = !1,
                        this.audioCodec = void 0,
                        this.videoCodec = void 0,
                        this.initData = void 0,
                        this.initPTS = void 0,
                        this.initTracks = void 0,
                        this.lastEndDTS = null
                    }
                    var t = e.prototype;
                    return t.destroy = function() {}
                    ,
                    t.resetTimeStamp = function(e) {
                        g.b.log("[pass-through-remuxer]: initPTS reset", e),
                        this.initPTS = e,
                        this.lastEndDTS = null
                    }
                    ,
                    t.resetNextTimestamp = function() {
                        this.lastEndDTS = null
                    }
                    ,
                    t.resetInitSegment = function(e, t, r) {
                        this.audioCodec = t,
                        this.videoCodec = r,
                        this.generateInitSegment(e),
                        this.emitInitSegment = !0
                    }
                    ,
                    t.abort = function() {}
                    ,
                    t.generateInitSegment = function(e) {
                        var t = this.audioCodec
                          , r = this.videoCodec;
                        if (!e || !e.byteLength)
                            return this.initTracks = void 0,
                            void (this.initData = void 0);
                        var i = this.initData = Object(h.f)(e);
                        t || (t = xe(i.audio, Re.a.AUDIO)),
                        r || (r = xe(i.video, Re.a.VIDEO));
                        var n = {};
                        i.audio && i.video ? n.audiovideo = {
                            container: "video/mp4",
                            codec: t + "," + r,
                            initSegment: e,
                            id: "main"
                        } : i.audio ? n.audio = {
                            container: "audio/mp4",
                            codec: t,
                            initSegment: e,
                            id: "audio"
                        } : i.video ? n.video = {
                            container: "video/mp4",
                            codec: r,
                            initSegment: e,
                            id: "main"
                        } : g.b.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."),
                        this.initTracks = n
                    }
                    ,
                    t.remux = function(e, t, r, i, n) {
                        var a = this.initPTS
                          , o = this.lastEndDTS
                          , s = {
                            audio: void 0,
                            video: void 0,
                            text: i,
                            id3: r,
                            initSegment: void 0
                        };
                        Object(l.a)(o) || (o = this.lastEndDTS = n || 0);
                        var c = t.samples;
                        if (!c || !c.length)
                            return s;
                        var u = {
                            initPTS: void 0,
                            timescale: 1
                        }
                          , d = this.initData;
                        if (d && d.length || (this.generateInitSegment(c),
                        d = this.initData),
                        !d || !d.length)
                            return g.b.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."),
                            s;
                        this.emitInitSegment && (u.tracks = this.initTracks,
                        this.emitInitSegment = !1),
                        Object(l.a)(a) || (this.initPTS = u.initPTS = a = _e(d, c, o));
                        var f = Object(h.c)(c, d)
                          , p = o
                          , v = f + p;
                        Object(h.e)(d, c, a),
                        f > 0 ? this.lastEndDTS = v : (g.b.warn("Duration parsed from mp4 should be greater than zero"),
                        this.resetNextTimestamp());
                        var y = !!d.audio
                          , m = !!d.video
                          , T = "";
                        y && (T += "audio"),
                        m && (T += "video");
                        var S = {
                            data1: c,
                            startPTS: p,
                            startDTS: p,
                            endPTS: v,
                            endDTS: v,
                            type: T,
                            hasAudio: y,
                            hasVideo: m,
                            nb: 1,
                            dropped: 0
                        };
                        return s.audio = "audio" === S.type ? S : void 0,
                        s.video = "audio" !== S.type ? S : void 0,
                        s.text = i,
                        s.id3 = r,
                        s.initSegment = u,
                        s
                    }
                    ,
                    e
                }()
                  , _e = function(e, t, r) {
                    return Object(h.d)(e, t) - r
                };
                function xe(e, t) {
                    var r = null == e ? void 0 : e.codec;
                    return r && r.length > 4 ? r : "hvc1" === r || "hev1" === r ? "hvc1.1.6.L120.90" : "av01" === r ? "av01.0.04M.08" : "avc1" === r || t === Re.a.VIDEO ? "avc1.42e01e" : "mp4a.40.5"
                }
                var Oe, Fe = Ae, Be = r(18), Me = r(14);
                try {
                    Oe = self.performance.now.bind(self.performance)
                } catch (e) {
                    g.b.debug("Unable to use Performance API on this environment"),
                    Oe = self.Date.now
                }
                var Ue = [{
                    demux: C,
                    remux: Fe
                }, {
                    demux: he,
                    remux: ke
                }, {
                    demux: D,
                    remux: ke
                }, {
                    demux: de,
                    remux: ke
                }]
                  , Ne = 1024;
                Ue.forEach((function(e) {
                    var t = e.demux;
                    Ne = Math.max(Ne, t.minProbeByteLength)
                }
                ));
                var Ge = function() {
                    function e(e, t, r, i, n) {
                        this.discontinuities = [],
                        this.observer = void 0,
                        this.typeSupported = void 0,
                        this.config = void 0,
                        this.vendor = void 0,
                        this.id = void 0,
                        this.demuxer = void 0,
                        this.remuxer = void 0,
                        this.decrypter = void 0,
                        this.probe = void 0,
                        this.decryptionPromise = null,
                        this.transmuxConfig = void 0,
                        this.currentTransmuxState = void 0,
                        this.currentChunkMeta = void 0,
                        this.cache = new Be.a,
                        this.remainderChunk = new Be.a,
                        this.observer = e,
                        this.typeSupported = t,
                        this.config = r,
                        this.vendor = i,
                        this.id = n
                    }
                    var t = e.prototype;
                    return t.configure = function(e) {
                        this.transmuxConfig = e,
                        this.decrypter && this.decrypter.reset()
                    }
                    ,
                    t.abort = function() {
                        var e, t;
                        null === (e = this.demuxer) || void 0 === e || e.abort(),
                        null === (t = this.remuxer) || void 0 === t || t.abort()
                    }
                    ,
                    t.push = function(e, t, r, i, n) {
                        var a, o = this, s = r.transmuxing;
                        s.executeStart = Oe();
                        var l = new Uint8Array(e)
                          , c = this.cache
                          , u = this.config
                          , d = this.currentTransmuxState
                          , f = this.transmuxConfig;
                        i && (this.currentTransmuxState = i);
                        var p = function(e, t) {
                            var r = null;
                            return e.byteLength > 0 && null != t && null != t.key && null !== t.iv && null != t.method && (r = t),
                            r
                        }(l, t);
                        if (p && "AES-128" === p.method) {
                            var g = this.getDecrypter();
                            if (!u.enableSoftwareAES)
                                return this.decryptionPromise = g.webCryptoDecrypt(l, p.key.buffer, p.iv.buffer).then((function(e) {
                                    var t = o.push(e, null, r);
                                    return o.decryptionPromise = null,
                                    t
                                }
                                )),
                                this.decryptionPromise;
                            var v = g.softwareDecrypt(l, p.key.buffer, p.iv.buffer);
                            if (!v)
                                return s.executeEnd = Oe(),
                                He(r);
                            l = new Uint8Array(v)
                        } else if (this.config.chachaParam && -1 === (null === (a = this.discontinuities) || void 0 === a ? void 0 : a.indexOf(r.sn))) {
                            var y, m = this.remainderChunk.flush();
                            y = m.length ? Object(h.a)(m, new Uint8Array(e)) : new Uint8Array(e);
                            var T = Object(Me.b)(y, !n && this.config.progressive)
                              , S = T.result
                              , I = T.remainder;
                            null != I && I.length && this.remainderChunk.push(I),
                            l = new Uint8Array(S)
                        }
                        var P, b, E = i || d, D = E.contiguous, k = E.discontinuity, C = E.trackSwitch, L = E.accurateTimeOffset, w = E.timeOffset, R = f.audioCodec, A = f.videoCodec, _ = f.defaultInitPts, x = f.duration, O = f.initSegmentData;
                        if ((k || C) && this.resetInitSegment(O, R, A, x),
                        k && this.resetInitialTimestamp(_),
                        D || this.resetContiguity(),
                        this.needsProbing(l, k, C)) {
                            if (c.dataLength) {
                                var F = c.flush();
                                l = Object(h.a)(F, l)
                            }
                            this.configureTransmuxer(l, f)
                        }
                        this.config.progressive && ((null === (P = this.currentChunkMeta) || void 0 === P ? void 0 : P.sn) !== r.sn && (null === (b = this.demuxer) || void 0 === b || b.flush()),
                        this.currentChunkMeta = r);
                        var B = this.transmux(l, p, w, L, r)
                          , M = this.currentTransmuxState;
                        return M.contiguous = !0,
                        M.discontinuity = !1,
                        M.trackSwitch = !1,
                        s.executeEnd = Oe(),
                        B
                    }
                    ,
                    t.flush = function(e) {
                        var t = this
                          , r = e.transmuxing;
                        r.executeStart = Oe();
                        var a = this.decrypter
                          , o = this.cache
                          , s = this.currentTransmuxState
                          , l = this.decryptionPromise;
                        if (l)
                            return l.then((function() {
                                return t.flush(e)
                            }
                            ));
                        var c = []
                          , h = s.timeOffset;
                        if (a) {
                            var u = a.flush();
                            u && c.push(this.push(u, null, e))
                        } else if (this.config.chachaParam && this.remainderChunk.dataLength) {
                            var d = this.push(this.remainderChunk.flush(), null, e, void 0, !0);
                            c.push(d)
                        }
                        var f = o.dataLength;
                        o.reset();
                        var p = this.demuxer
                          , g = this.remuxer;
                        if (!p || !g)
                            return f >= Ne && this.observer.emit(i.a.ERROR, i.a.ERROR, {
                                type: n.b.MEDIA_ERROR,
                                details: n.a.FRAG_PARSING_ERROR,
                                fatal: !0,
                                reason: "no demux matching with content found"
                            }),
                            r.executeEnd = Oe(),
                            [He(e)];
                        var v = p.flush(h);
                        return qe(v) ? v.then((function(r) {
                            return t.flushRemux(c, r, e),
                            c
                        }
                        )) : (this.flushRemux(c, v, e),
                        c)
                    }
                    ,
                    t.flushRemux = function(e, t, r) {
                        var i = t.audioTrack
                          , n = t.avcTrack
                          , a = t.id3Track
                          , o = t.textTrack
                          , s = this.currentTransmuxState
                          , l = s.accurateTimeOffset
                          , c = s.timeOffset;
                        g.b.log("[transmuxer.ts]: Flushed fragment " + r.sn + (r.part > -1 ? " p: " + r.part : "") + " of level " + r.level);
                        var h = this.remuxer.remux(i, n, a, o, c, l, !0, this.id);
                        e.push({
                            remuxResult: h,
                            chunkMeta: r
                        }),
                        r.transmuxing.executeEnd = Oe()
                    }
                    ,
                    t.resetInitialTimestamp = function(e) {
                        var t = this.demuxer
                          , r = this.remuxer;
                        t && r && (t.resetTimeStamp(e),
                        r.resetTimeStamp(e))
                    }
                    ,
                    t.resetContiguity = function() {
                        var e = this.demuxer
                          , t = this.remuxer;
                        e && t && (e.resetContiguity(),
                        t.resetNextTimestamp())
                    }
                    ,
                    t.resetInitSegment = function(e, t, r, i) {
                        var n = this.demuxer
                          , a = this.remuxer;
                        if (n && a) {
                            var o = e;
                            this.config.chachaParam && e && (o = Object(Me.b)(e, !1).result),
                            n.resetInitSegment(t, r, i),
                            a.resetInitSegment(o, t, r)
                        }
                    }
                    ,
                    t.destroy = function() {
                        this.demuxer && (this.demuxer.destroy(),
                        this.demuxer = void 0),
                        this.remuxer && (this.remuxer.destroy(),
                        this.remuxer = void 0)
                    }
                    ,
                    t.transmux = function(e, t, r, i, n) {
                        return t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, r, i, n) : this.transmuxUnencrypted(e, r, i, n)
                    }
                    ,
                    t.transmuxUnencrypted = function(e, t, r, i) {
                        var n = this.demuxer.demux(e, t, !1, !this.config.progressive)
                          , a = n.audioTrack
                          , o = n.avcTrack
                          , s = n.id3Track
                          , l = n.textTrack;
                        return {
                            remuxResult: this.remuxer.remux(a, o, s, l, t, r, !1, this.id),
                            chunkMeta: i
                        }
                    }
                    ,
                    t.transmuxSampleAes = function(e, t, r, i, n) {
                        var a = this;
                        return this.demuxer.demuxSampleAes(e, t, r).then((function(e) {
                            return {
                                remuxResult: a.remuxer.remux(e.audioTrack, e.avcTrack, e.id3Track, e.textTrack, r, i, !1, a.id),
                                chunkMeta: n
                            }
                        }
                        ))
                    }
                    ,
                    t.configureTransmuxer = function(e, t) {
                        for (var r, i = this.config, n = this.observer, a = this.typeSupported, o = this.vendor, s = t.audioCodec, l = t.defaultInitPts, c = t.duration, h = t.initSegmentData, u = t.videoCodec, d = 0, f = Ue.length; d < f; d++)
                            if (Ue[d].demux.probe(e)) {
                                r = Ue[d];
                                break
                            }
                        r || (g.b.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"),
                        r = {
                            demux: C,
                            remux: Fe
                        });
                        var p = this.demuxer
                          , v = this.remuxer
                          , y = r.remux
                          , m = r.demux;
                        v && v instanceof y || (this.remuxer = new y(n,i,a,o)),
                        p && p instanceof m || (this.demuxer = new m(n,i,a),
                        this.probe = m.probe),
                        this.resetInitSegment(h, s, u, c),
                        this.resetInitialTimestamp(l)
                    }
                    ,
                    t.needsProbing = function(e, t, r) {
                        return !this.demuxer || !this.remuxer || t || r
                    }
                    ,
                    t.getDecrypter = function() {
                        var e = this.decrypter;
                        return e || (e = this.decrypter = new a.a(this.observer,this.config)),
                        e
                    }
                    ,
                    e
                }()
                  , He = function(e) {
                    return {
                        remuxResult: {},
                        chunkMeta: e
                    }
                };
                function qe(e) {
                    return "then"in e && e.then instanceof Function
                }
                var ze = function(e, t, r, i, n) {
                    this.audioCodec = void 0,
                    this.videoCodec = void 0,
                    this.initSegmentData = void 0,
                    this.duration = void 0,
                    this.defaultInitPts = void 0,
                    this.audioCodec = e,
                    this.videoCodec = t,
                    this.initSegmentData = r,
                    this.duration = i,
                    this.defaultInitPts = n
                }
                  , Ke = function(e, t, r, i, n) {
                    this.discontinuity = void 0,
                    this.contiguous = void 0,
                    this.accurateTimeOffset = void 0,
                    this.trackSwitch = void 0,
                    this.timeOffset = void 0,
                    this.discontinuity = e,
                    this.contiguous = t,
                    this.accurateTimeOffset = r,
                    this.trackSwitch = i,
                    this.timeOffset = n
                }
            }
            , function(e, t) {
                function r() {
                    return e.exports = r = Object.assign ? Object.assign.bind() : function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var r = arguments[t];
                            for (var i in r)
                                ({}).hasOwnProperty.call(r, i) && (e[i] = r[i])
                        }
                        return e
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports,
                    r.apply(null, arguments)
                }
                e.exports = r,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "b", (function() {
                    return o
                }
                )),
                r.d(t, "a", (function() {
                    return l
                }
                )),
                r.d(t, "d", (function() {
                    return c
                }
                )),
                r.d(t, "e", (function() {
                    return h
                }
                )),
                r.d(t, "c", (function() {
                    return d
                }
                ));
                var i, n = function(e, t) {
                    return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
                }, a = function(e, t) {
                    return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
                }, o = function(e, t) {
                    for (var r = t, i = 0; n(e, t); )
                        i += 10,
                        i += s(e, t + 6),
                        a(e, t + 10) && (i += 10),
                        t += i;
                    if (i > 0)
                        return e.subarray(r, r + i)
                }, s = function(e, t) {
                    var r = 0;
                    return r = (127 & e[t]) << 21,
                    r |= (127 & e[t + 1]) << 14,
                    (r |= (127 & e[t + 2]) << 7) | 127 & e[t + 3]
                }, l = function(e, t) {
                    return n(e, t) && s(e, t + 6) + 10 <= e.length - t
                }, c = function(e) {
                    for (var t = d(e), r = 0; r < t.length; r++) {
                        var i = t[r];
                        if (h(i))
                            return y(i)
                    }
                }, h = function(e) {
                    return e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info
                }, u = function(e) {
                    var t = String.fromCharCode(e[0], e[1], e[2], e[3])
                      , r = s(e, 4);
                    return {
                        type: t,
                        size: r,
                        data: e.subarray(10, 10 + r)
                    }
                }, d = function(e) {
                    for (var t = 0, r = []; n(e, t); ) {
                        for (var i = s(e, t + 6), o = (t += 10) + i; t + 8 < o; ) {
                            var l = u(e.subarray(t))
                              , c = f(l);
                            c && r.push(c),
                            t += l.size + 10
                        }
                        a(e, t) && (t += 10)
                    }
                    return r
                }, f = function(e) {
                    return "PRIV" === e.type ? p(e) : "W" === e.type[0] ? v(e) : g(e)
                }, p = function(e) {
                    if (!(e.size < 2)) {
                        var t = m(e.data, !0)
                          , r = new Uint8Array(e.data.subarray(t.length + 1));
                        return {
                            key: e.type,
                            info: t,
                            data: r.buffer
                        }
                    }
                }, g = function(e) {
                    if (!(e.size < 2)) {
                        if ("TXXX" === e.type) {
                            var t = 1
                              , r = m(e.data.subarray(t), !0);
                            t += r.length + 1;
                            var i = m(e.data.subarray(t));
                            return {
                                key: e.type,
                                info: r,
                                data: i
                            }
                        }
                        var n = m(e.data.subarray(1));
                        return {
                            key: e.type,
                            data: n
                        }
                    }
                }, v = function(e) {
                    if ("WXXX" === e.type) {
                        if (e.size < 2)
                            return;
                        var t = 1
                          , r = m(e.data.subarray(t), !0);
                        t += r.length + 1;
                        var i = m(e.data.subarray(t));
                        return {
                            key: e.type,
                            info: r,
                            data: i
                        }
                    }
                    var n = m(e.data);
                    return {
                        key: e.type,
                        data: n
                    }
                }, y = function(e) {
                    if (8 === e.data.byteLength) {
                        var t = new Uint8Array(e.data)
                          , r = 1 & t[3]
                          , i = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
                        return i /= 45,
                        r && (i += 47721858.84),
                        Math.round(i)
                    }
                }, m = function(e, t) {
                    void 0 === t && (t = !1);
                    var r = T();
                    if (r) {
                        var i = r.decode(e);
                        if (t) {
                            var n = i.indexOf("\0");
                            return -1 !== n ? i.substring(0, n) : i
                        }
                        return i.replace(/\0/g, "")
                    }
                    for (var a, o, s, l = e.length, c = "", h = 0; h < l; ) {
                        if (0 === (a = e[h++]) && t)
                            return c;
                        if (0 !== a && 3 !== a)
                            switch (a >> 4) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                c += String.fromCharCode(a);
                                break;
                            case 12:
                            case 13:
                                o = e[h++],
                                c += String.fromCharCode((31 & a) << 6 | 63 & o);
                                break;
                            case 14:
                                o = e[h++],
                                s = e[h++],
                                c += String.fromCharCode((15 & a) << 12 | (63 & o) << 6 | 63 & s)
                            }
                    }
                    return c
                };
                function T() {
                    return i || void 0 === self.TextDecoder || (i = new self.TextDecoder("utf-8")),
                    i
                }
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "d", (function() {
                    return i
                }
                )),
                r.d(t, "e", (function() {
                    return n
                }
                )),
                r.d(t, "a", (function() {
                    return a
                }
                )),
                r.d(t, "b", (function() {
                    return o
                }
                )),
                r.d(t, "c", (function() {
                    return s
                }
                ));
                var i = function(e) {
                    return e[e.BT709 = 0] = "BT709",
                    e[e.BT601 = 1] = "BT601",
                    e[e.BT2020 = 2] = "BT2020",
                    e[e.BT2100 = 3] = "BT2100",
                    e
                }({})
                  , n = function(e) {
                    return e[e.BT709 = 0] = "BT709",
                    e[e.BT601 = 1] = "BT601",
                    e[e.GAMMA22 = 2] = "GAMMA22",
                    e[e.GAMMA28 = 3] = "GAMMA28",
                    e[e.SRGB = 4] = "SRGB",
                    e[e.BT2020 = 5] = "BT2020",
                    e[e.BT2100PQ = 6] = "BT2100PQ",
                    e[e.BT2100HLG = 7] = "BT2100HLG",
                    e
                }({})
                  , a = [[0, 0, 0], [4, 2, 0], [4, 2, 2], [4, 4, 4], [4, 4, 4]]
                  , o = {
                    1: i.BT709,
                    5: i.BT601,
                    6: i.BT601,
                    9: i.BT2020
                }
                  , s = {
                    1: n.BT709,
                    4: n.GAMMA22,
                    5: n.GAMMA28,
                    6: n.BT601,
                    13: n.SRGB,
                    14: n.BT2020,
                    15: n.BT2020,
                    16: n.BT2100PQ,
                    18: n.BT2100HLG
                }
            }
            , function(e, t, r) {
                "use strict";
                function i(e, t, r) {
                    return Uint8Array.prototype.slice ? e.slice(t, r) : new Uint8Array(Array.prototype.slice.call(e, t, r))
                }
                r.d(t, "a", (function() {
                    return i
                }
                ))
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "e", (function() {
                    return o
                }
                )),
                r.d(t, "a", (function() {
                    return s
                }
                )),
                r.d(t, "c", (function() {
                    return l
                }
                )),
                r.d(t, "d", (function() {
                    return c
                }
                )),
                r.d(t, "b", (function() {
                    return h
                }
                ));
                var i = r(1);
                function n(e) {
                    var t = self
                      , r = t.Module
                      , i = t.HEAPU8
                      , n = e.length + 64
                      , a = r._malloc(n);
                    return r.stringToUTF8Array(e, i, a, n),
                    a
                }
                function a(e) {
                    var t = self.Module
                      , r = e.byteLength
                      , i = t._malloc(r)
                      , n = t._malloc(r);
                    t.HEAPU8.set(e, n),
                    t._decData(i, n, r);
                    var a = t.HEAPU8.slice(i, i + r);
                    return t._free(n),
                    {
                        buf: a,
                        ptr: i
                    }
                }
                var o = 1
                  , s = "chachaScriptLoadError";
                function l(e) {
                    var t, r = e.linkvid, a = e.base, o = e.appVer, s = e.tm, l = e.platform, c = new Promise((function(e) {
                        t = e
                    }
                    )), h = function() {
                        i.b.log("chacha inited");
                        var e = self.Module
                          , c = n(r)
                          , h = n(a)
                          , u = n(o);
                        e._prepareParam(c, h, u, s, l),
                        e._free(c),
                        e._free(h),
                        e._free(u),
                        t()
                    };
                    return self.Module ? (h(),
                    t()) : self.Module = {
                        onRuntimeInitialized: h
                    },
                    c
                }
                function c(e) {
                    var t, r = e.cnlid, a = e.baseKey, o = e.randoms, s = new Promise((function(e) {
                        t = e
                    }
                    )), l = function() {
                        i.b.log("chacha inited");
                        var e = self.Module
                          , s = n(r)
                          , l = n(a)
                          , c = n(o);
                        e._prepareLiveParam(s, l, c),
                        e._free(s),
                        e._free(l),
                        e._free(c),
                        t()
                    };
                    return self.Module ? (l(),
                    t()) : self.Module = {
                        onRuntimeInitialized: l
                    },
                    s
                }
                function h(e, t) {
                    var r;
                    void 0 === t && (t = !1);
                    var i = null;
                    if (t) {
                        var n = e.byteLength % 1024
                          , o = e.byteLength - n;
                        r = new Uint8Array(o),
                        i = e.slice(o)
                    } else
                        r = new Uint8Array(e.byteLength);
                    for (var s = 0; s < r.length; ) {
                        var l = Math.min(r.length, s + 1024)
                          , c = a(e.slice(s, l))
                          , h = c.buf
                          , u = c.ptr;
                        r.set(h, s),
                        self.Module._free(u),
                        s = l
                    }
                    return {
                        result: r,
                        remainder: i
                    }
                }
            }
            , function(e, t, r) {
                var i, n, a, o, s;
                i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/,
                n = /^([^\/?#]*)([^]*)$/,
                a = /(?:\/|^)\.(?=\/)/g,
                o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,
                s = {
                    buildAbsoluteURL: function(e, t, r) {
                        if (r = r || {},
                        e = e.trim(),
                        !(t = t.trim())) {
                            if (!r.alwaysNormalize)
                                return e;
                            var i = s.parseURL(e);
                            if (!i)
                                throw new Error("Error trying to parse base URL.");
                            return i.path = s.normalizePath(i.path),
                            s.buildURLFromParts(i)
                        }
                        var a = s.parseURL(t);
                        if (!a)
                            throw new Error("Error trying to parse relative URL.");
                        if (a.scheme)
                            return r.alwaysNormalize ? (a.path = s.normalizePath(a.path),
                            s.buildURLFromParts(a)) : t;
                        var o = s.parseURL(e);
                        if (!o)
                            throw new Error("Error trying to parse base URL.");
                        if (!o.netLoc && o.path && "/" !== o.path[0]) {
                            var l = n.exec(o.path);
                            o.netLoc = l[1],
                            o.path = l[2]
                        }
                        o.netLoc && !o.path && (o.path = "/");
                        var c = {
                            scheme: o.scheme,
                            netLoc: a.netLoc,
                            path: null,
                            params: a.params,
                            query: a.query,
                            fragment: a.fragment
                        };
                        if (!a.netLoc && (c.netLoc = o.netLoc,
                        "/" !== a.path[0]))
                            if (a.path) {
                                var h = o.path
                                  , u = h.substring(0, h.lastIndexOf("/") + 1) + a.path;
                                c.path = s.normalizePath(u)
                            } else
                                c.path = o.path,
                                a.params || (c.params = o.params,
                                a.query || (c.query = o.query));
                        return null === c.path && (c.path = r.alwaysNormalize ? s.normalizePath(a.path) : a.path),
                        s.buildURLFromParts(c)
                    },
                    parseURL: function(e) {
                        var t = i.exec(e);
                        return t ? {
                            scheme: t[1] || "",
                            netLoc: t[2] || "",
                            path: t[3] || "",
                            params: t[4] || "",
                            query: t[5] || "",
                            fragment: t[6] || ""
                        } : null
                    },
                    normalizePath: function(e) {
                        for (e = e.split("").reverse().join("").replace(a, ""); e.length !== (e = e.replace(o, "")).length; )
                            ;
                        return e.split("").reverse().join("")
                    },
                    buildURLFromParts: function(e) {
                        return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
                    }
                },
                e.exports = s
            }
            , function(e, t, r) {
                var i = r(28);
                e.exports = function(e, t, r) {
                    return (t = i(t))in e ? Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = r,
                    e
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return i
                }
                ));
                var i = function() {
                    this.aborted = !1,
                    this.loaded = 0,
                    this.retry = 0,
                    this.total = 0,
                    this.chunkCount = 0,
                    this.bwEstimate = 0,
                    this.loading = {
                        start: 0,
                        first: 0,
                        end: 0
                    },
                    this.parsing = {
                        start: 0,
                        end: 0
                    },
                    this.buffering = {
                        start: 0,
                        first: 0,
                        end: 0
                    }
                }
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return i
                }
                ));
                var i = function() {
                    function e() {
                        this.chunks = [],
                        this.dataLength = 0
                    }
                    var t = e.prototype;
                    return t.push = function(e) {
                        this.chunks.push(e),
                        this.dataLength += e.length
                    }
                    ,
                    t.flush = function() {
                        var e, t = this.chunks, r = this.dataLength;
                        return t.length ? (e = 1 === t.length ? t[0] : function(e, t) {
                            for (var r = new Uint8Array(t), i = 0, n = 0; n < e.length; n++) {
                                var a = e[n];
                                r.set(a, i),
                                i += a.length
                            }
                            return r
                        }(t, r),
                        this.reset(),
                        e) : new Uint8Array(0)
                    }
                    ,
                    t.reset = function() {
                        this.chunks.length = 0,
                        this.dataLength = 0
                    }
                    ,
                    e
                }()
            }
            , function(e, t) {
                e.exports = void 0
            }
            , function(e, t, r) {
                "use strict";
                var i = Object.prototype.hasOwnProperty
                  , n = "~";
                function a() {}
                function o(e, t, r) {
                    this.fn = e,
                    this.context = t,
                    this.once = r || !1
                }
                function s(e, t, r, i, a) {
                    if ("function" != typeof r)
                        throw new TypeError("The listener must be a function");
                    var s = new o(r,i || e,a)
                      , l = n ? n + t : t;
                    return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], s] : e._events[l].push(s) : (e._events[l] = s,
                    e._eventsCount++),
                    e
                }
                function l(e, t) {
                    0 == --e._eventsCount ? e._events = new a : delete e._events[t]
                }
                function c() {
                    this._events = new a,
                    this._eventsCount = 0
                }
                Object.create && (a.prototype = Object.create(null),
                (new a).__proto__ || (n = !1)),
                c.prototype.eventNames = function() {
                    var e, t, r = [];
                    if (0 === this._eventsCount)
                        return r;
                    for (t in e = this._events)
                        i.call(e, t) && r.push(n ? t.slice(1) : t);
                    return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r
                }
                ,
                c.prototype.listeners = function(e) {
                    var t = n ? n + e : e
                      , r = this._events[t];
                    if (!r)
                        return [];
                    if (r.fn)
                        return [r.fn];
                    for (var i = 0, a = r.length, o = new Array(a); i < a; i++)
                        o[i] = r[i].fn;
                    return o
                }
                ,
                c.prototype.listenerCount = function(e) {
                    var t = n ? n + e : e
                      , r = this._events[t];
                    return r ? r.fn ? 1 : r.length : 0
                }
                ,
                c.prototype.emit = function(e, t, r, i, a, o) {
                    var s = n ? n + e : e;
                    if (!this._events[s])
                        return !1;
                    var l, c, h = this._events[s], u = arguments.length;
                    if (h.fn) {
                        switch (h.once && this.removeListener(e, h.fn, void 0, !0),
                        u) {
                        case 1:
                            return h.fn.call(h.context),
                            !0;
                        case 2:
                            return h.fn.call(h.context, t),
                            !0;
                        case 3:
                            return h.fn.call(h.context, t, r),
                            !0;
                        case 4:
                            return h.fn.call(h.context, t, r, i),
                            !0;
                        case 5:
                            return h.fn.call(h.context, t, r, i, a),
                            !0;
                        case 6:
                            return h.fn.call(h.context, t, r, i, a, o),
                            !0
                        }
                        for (c = 1,
                        l = new Array(u - 1); c < u; c++)
                            l[c - 1] = arguments[c];
                        h.fn.apply(h.context, l)
                    } else {
                        var d, f = h.length;
                        for (c = 0; c < f; c++)
                            switch (h[c].once && this.removeListener(e, h[c].fn, void 0, !0),
                            u) {
                            case 1:
                                h[c].fn.call(h[c].context);
                                break;
                            case 2:
                                h[c].fn.call(h[c].context, t);
                                break;
                            case 3:
                                h[c].fn.call(h[c].context, t, r);
                                break;
                            case 4:
                                h[c].fn.call(h[c].context, t, r, i);
                                break;
                            default:
                                if (!l)
                                    for (d = 1,
                                    l = new Array(u - 1); d < u; d++)
                                        l[d - 1] = arguments[d];
                                h[c].fn.apply(h[c].context, l)
                            }
                    }
                    return !0
                }
                ,
                c.prototype.on = function(e, t, r) {
                    return s(this, e, t, r, !1)
                }
                ,
                c.prototype.once = function(e, t, r) {
                    return s(this, e, t, r, !0)
                }
                ,
                c.prototype.removeListener = function(e, t, r, i) {
                    var a = n ? n + e : e;
                    if (!this._events[a])
                        return this;
                    if (!t)
                        return l(this, a),
                        this;
                    var o = this._events[a];
                    if (o.fn)
                        o.fn !== t || i && !o.once || r && o.context !== r || l(this, a);
                    else {
                        for (var s = 0, c = [], h = o.length; s < h; s++)
                            (o[s].fn !== t || i && !o[s].once || r && o[s].context !== r) && c.push(o[s]);
                        c.length ? this._events[a] = 1 === c.length ? c[0] : c : l(this, a)
                    }
                    return this
                }
                ,
                c.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = n ? n + e : e,
                    this._events[t] && l(this, t)) : (this._events = new a,
                    this._eventsCount = 0),
                    this
                }
                ,
                c.prototype.off = c.prototype.removeListener,
                c.prototype.addListener = c.prototype.on,
                c.prefixed = n,
                c.EventEmitter = c,
                e.exports = c
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return c
                }
                ));
                var i = function() {
                    function e(e, t) {
                        this.subtle = void 0,
                        this.aesIV = void 0,
                        this.subtle = e,
                        this.aesIV = t
                    }
                    return e.prototype.decrypt = function(e, t) {
                        return this.subtle.decrypt({
                            name: "AES-CBC",
                            iv: this.aesIV
                        }, t, e)
                    }
                    ,
                    e
                }()
                  , n = function() {
                    function e(e, t) {
                        this.subtle = void 0,
                        this.key = void 0,
                        this.subtle = e,
                        this.key = t
                    }
                    return e.prototype.expandKey = function() {
                        return this.subtle.importKey("raw", this.key, {
                            name: "AES-CBC"
                        }, !1, ["encrypt", "decrypt"])
                    }
                    ,
                    e
                }()
                  , a = r(13)
                  , o = function() {
                    function e() {
                        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
                        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
                        this.sBox = new Uint32Array(256),
                        this.invSBox = new Uint32Array(256),
                        this.key = new Uint32Array(0),
                        this.ksRows = 0,
                        this.keySize = 0,
                        this.keySchedule = void 0,
                        this.invKeySchedule = void 0,
                        this.initTable()
                    }
                    var t = e.prototype;
                    return t.uint8ArrayToUint32Array_ = function(e) {
                        for (var t = new DataView(e), r = new Uint32Array(4), i = 0; i < 4; i++)
                            r[i] = t.getUint32(4 * i);
                        return r
                    }
                    ,
                    t.initTable = function() {
                        var e = this.sBox
                          , t = this.invSBox
                          , r = this.subMix
                          , i = r[0]
                          , n = r[1]
                          , a = r[2]
                          , o = r[3]
                          , s = this.invSubMix
                          , l = s[0]
                          , c = s[1]
                          , h = s[2]
                          , u = s[3]
                          , d = new Uint32Array(256)
                          , f = 0
                          , p = 0
                          , g = 0;
                        for (g = 0; g < 256; g++)
                            d[g] = g < 128 ? g << 1 : g << 1 ^ 283;
                        for (g = 0; g < 256; g++) {
                            var v = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4;
                            v = v >>> 8 ^ 255 & v ^ 99,
                            e[f] = v,
                            t[v] = f;
                            var y = d[f]
                              , m = d[y]
                              , T = d[m]
                              , S = 257 * d[v] ^ 16843008 * v;
                            i[f] = S << 24 | S >>> 8,
                            n[f] = S << 16 | S >>> 16,
                            a[f] = S << 8 | S >>> 24,
                            o[f] = S,
                            S = 16843009 * T ^ 65537 * m ^ 257 * y ^ 16843008 * f,
                            l[v] = S << 24 | S >>> 8,
                            c[v] = S << 16 | S >>> 16,
                            h[v] = S << 8 | S >>> 24,
                            u[v] = S,
                            f ? (f = y ^ d[d[d[T ^ y]]],
                            p ^= d[d[p]]) : f = p = 1
                        }
                    }
                    ,
                    t.expandKey = function(e) {
                        for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; i < t.length && r; )
                            r = t[i] === this.key[i],
                            i++;
                        if (!r) {
                            this.key = t;
                            var n = this.keySize = t.length;
                            if (4 !== n && 6 !== n && 8 !== n)
                                throw new Error("Invalid aes key size=" + n);
                            var a, o, s, l, c = this.ksRows = 4 * (n + 6 + 1), h = this.keySchedule = new Uint32Array(c), u = this.invKeySchedule = new Uint32Array(c), d = this.sBox, f = this.rcon, p = this.invSubMix, g = p[0], v = p[1], y = p[2], m = p[3];
                            for (a = 0; a < c; a++)
                                a < n ? s = h[a] = t[a] : (l = s,
                                a % n == 0 ? (l = d[(l = l << 8 | l >>> 24) >>> 24] << 24 | d[l >>> 16 & 255] << 16 | d[l >>> 8 & 255] << 8 | d[255 & l],
                                l ^= f[a / n | 0] << 24) : n > 6 && a % n == 4 && (l = d[l >>> 24] << 24 | d[l >>> 16 & 255] << 16 | d[l >>> 8 & 255] << 8 | d[255 & l]),
                                h[a] = s = (h[a - n] ^ l) >>> 0);
                            for (o = 0; o < c; o++)
                                a = c - o,
                                l = 3 & o ? h[a] : h[a - 4],
                                u[o] = o < 4 || a <= 4 ? l : g[d[l >>> 24]] ^ v[d[l >>> 16 & 255]] ^ y[d[l >>> 8 & 255]] ^ m[d[255 & l]],
                                u[o] = u[o] >>> 0
                        }
                    }
                    ,
                    t.networkToHostOrderSwap = function(e) {
                        return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
                    }
                    ,
                    t.decrypt = function(e, t, r) {
                        for (var i, n, a, o, s, l, c, h, u, d, f, p, g, v, y = this.keySize + 6, m = this.invKeySchedule, T = this.invSBox, S = this.invSubMix, I = S[0], P = S[1], b = S[2], E = S[3], D = this.uint8ArrayToUint32Array_(r), k = D[0], C = D[1], L = D[2], w = D[3], R = new Int32Array(e), A = new Int32Array(R.length), _ = this.networkToHostOrderSwap; t < R.length; ) {
                            for (u = _(R[t]),
                            d = _(R[t + 1]),
                            f = _(R[t + 2]),
                            p = _(R[t + 3]),
                            s = u ^ m[0],
                            l = p ^ m[1],
                            c = f ^ m[2],
                            h = d ^ m[3],
                            g = 4,
                            v = 1; v < y; v++)
                                i = I[s >>> 24] ^ P[l >> 16 & 255] ^ b[c >> 8 & 255] ^ E[255 & h] ^ m[g],
                                n = I[l >>> 24] ^ P[c >> 16 & 255] ^ b[h >> 8 & 255] ^ E[255 & s] ^ m[g + 1],
                                a = I[c >>> 24] ^ P[h >> 16 & 255] ^ b[s >> 8 & 255] ^ E[255 & l] ^ m[g + 2],
                                o = I[h >>> 24] ^ P[s >> 16 & 255] ^ b[l >> 8 & 255] ^ E[255 & c] ^ m[g + 3],
                                s = i,
                                l = n,
                                c = a,
                                h = o,
                                g += 4;
                            i = T[s >>> 24] << 24 ^ T[l >> 16 & 255] << 16 ^ T[c >> 8 & 255] << 8 ^ T[255 & h] ^ m[g],
                            n = T[l >>> 24] << 24 ^ T[c >> 16 & 255] << 16 ^ T[h >> 8 & 255] << 8 ^ T[255 & s] ^ m[g + 1],
                            a = T[c >>> 24] << 24 ^ T[h >> 16 & 255] << 16 ^ T[s >> 8 & 255] << 8 ^ T[255 & l] ^ m[g + 2],
                            o = T[h >>> 24] << 24 ^ T[s >> 16 & 255] << 16 ^ T[l >> 8 & 255] << 8 ^ T[255 & c] ^ m[g + 3],
                            A[t] = _(i ^ k),
                            A[t + 1] = _(o ^ C),
                            A[t + 2] = _(a ^ L),
                            A[t + 3] = _(n ^ w),
                            k = u,
                            C = d,
                            L = f,
                            w = p,
                            t += 4
                        }
                        return A.buffer
                    }
                    ,
                    e
                }()
                  , s = r(1)
                  , l = r(7)
                  , c = function() {
                    function e(e, t, r) {
                        var i = (void 0 === r ? {} : r).removePKCS7Padding
                          , n = void 0 === i || i;
                        if (this.logEnabled = !0,
                        this.observer = void 0,
                        this.config = void 0,
                        this.removePKCS7Padding = void 0,
                        this.subtle = null,
                        this.softwareDecrypter = null,
                        this.key = null,
                        this.fastAesKey = null,
                        this.remainderData = null,
                        this.currentIV = null,
                        this.currentResult = null,
                        this.observer = e,
                        this.config = t,
                        this.removePKCS7Padding = n,
                        n)
                            try {
                                var a = self.crypto;
                                a && (this.subtle = a.subtle || a.webkitSubtle)
                            } catch (e) {}
                        null === this.subtle && (this.config.enableSoftwareAES = !0)
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this.observer = null
                    }
                    ,
                    t.isSync = function() {
                        return this.config.enableSoftwareAES
                    }
                    ,
                    t.flush = function() {
                        var e = this.currentResult;
                        if (e) {
                            var t, r, i, n = new Uint8Array(e);
                            return this.reset(),
                            this.removePKCS7Padding ? (i = (r = (t = n).byteLength) && new DataView(t.buffer).getUint8(r - 1)) ? Object(a.a)(t, 0, r - i) : t : n
                        }
                        this.reset()
                    }
                    ,
                    t.reset = function() {
                        this.currentResult = null,
                        this.currentIV = null,
                        this.remainderData = null,
                        this.softwareDecrypter && (this.softwareDecrypter = null)
                    }
                    ,
                    t.decrypt = function(e, t, r, i) {
                        if (this.config.enableSoftwareAES) {
                            this.softwareDecrypt(new Uint8Array(e), t, r);
                            var n = this.flush();
                            n && i(n.buffer)
                        } else
                            this.webCryptoDecrypt(new Uint8Array(e), t, r).then(i)
                    }
                    ,
                    t.softwareDecrypt = function(e, t, r) {
                        var i = this.currentIV
                          , n = this.currentResult
                          , s = this.remainderData;
                        this.logOnce("JS AES decrypt"),
                        s && (e = Object(l.a)(s, e),
                        this.remainderData = null);
                        var c = this.getValidChunk(e);
                        if (!c.length)
                            return null;
                        i && (r = i);
                        var h = this.softwareDecrypter;
                        h || (h = this.softwareDecrypter = new o),
                        h.expandKey(t);
                        var u = n;
                        return this.currentResult = h.decrypt(c.buffer, 0, r),
                        this.currentIV = Object(a.a)(c, -16).buffer,
                        u || null
                    }
                    ,
                    t.webCryptoDecrypt = function(e, t, r) {
                        var a = this
                          , o = this.subtle;
                        return this.key === t && this.fastAesKey || (this.key = t,
                        this.fastAesKey = new n(o,t)),
                        this.fastAesKey.expandKey().then((function(t) {
                            return o ? new i(o,r).decrypt(e.buffer, t) : Promise.reject(new Error("web crypto not initialized"))
                        }
                        )).catch((function(i) {
                            return a.onWebCryptoError(i, e, t, r)
                        }
                        ))
                    }
                    ,
                    t.onWebCryptoError = function(e, t, r, i) {
                        return s.b.warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:", e),
                        this.config.enableSoftwareAES = !0,
                        this.logEnabled = !0,
                        this.softwareDecrypt(t, r, i)
                    }
                    ,
                    t.getValidChunk = function(e) {
                        var t = e
                          , r = e.length - e.length % 16;
                        return r !== e.length && (t = Object(a.a)(e, 0, r),
                        this.remainderData = Object(a.a)(e, r)),
                        t
                    }
                    ,
                    t.logOnce = function(e) {
                        this.logEnabled && (s.b.log("[decrypter.ts]: " + e),
                        this.logEnabled = !1)
                    }
                    ,
                    e
                }()
            }
            , function(e, t, r) {
                var i = r(36)();
                e.exports = i;
                try {
                    regeneratorRuntime = i
                } catch (e) {
                    "object" == typeof globalThis ? globalThis.regeneratorRuntime = i : Function("r", "regeneratorRuntime = r")(i)
                }
            }
            , function(e, t, r) {
                "use strict";
                r.d(t, "a", (function() {
                    return o
                }
                ));
                var i = r(5)
                  , n = r.n(i)
                  , a = r(15)
                  , o = function() {
                    function e(e, t) {
                        this._uri = null,
                        this.method = null,
                        this.keyFormat = null,
                        this.keyFormatVersions = null,
                        this.keyID = null,
                        this.key = null,
                        this.iv = null,
                        this._uri = t ? Object(a.buildAbsoluteURL)(e, t, {
                            alwaysNormalize: !0
                        }) : e
                    }
                    return e.fromURL = function(t, r) {
                        return new e(t,r)
                    }
                    ,
                    e.fromURI = function(t) {
                        return new e(t)
                    }
                    ,
                    n()(e, [{
                        key: "uri",
                        get: function() {
                            return this._uri
                        }
                    }])
                }()
            }
            , function(e, t, r) {
                var i = r(31)
                  , n = r(27)
                  , a = r(32)
                  , o = r(33);
                function s(t) {
                    var r = "function" == typeof Map ? new Map : void 0;
                    return e.exports = s = function(e) {
                        if (null === e || !a(e))
                            return e;
                        if ("function" != typeof e)
                            throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== r) {
                            if (r.has(e))
                                return r.get(e);
                            r.set(e, t)
                        }
                        function t() {
                            return o(e, arguments, i(this).constructor)
                        }
                        return t.prototype = Object.create(e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }),
                        n(t, e)
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports,
                    s(t)
                }
                e.exports = s,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t) {
                function r(e, t, r, i, n, a, o) {
                    try {
                        var s = e[a](o)
                          , l = s.value
                    } catch (e) {
                        return void r(e)
                    }
                    s.done ? t(l) : Promise.resolve(l).then(i, n)
                }
                e.exports = function(e) {
                    return function() {
                        var t = this
                          , i = arguments;
                        return new Promise((function(n, a) {
                            var o = e.apply(t, i);
                            function s(e) {
                                r(o, n, a, s, l, "next", e)
                            }
                            function l(e) {
                                r(o, n, a, s, l, "throw", e)
                            }
                            s(void 0)
                        }
                        ))
                    }
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t) {
                function r(t) {
                    return e.exports = r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    }
                    : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports,
                    r(t)
                }
                e.exports = r,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t) {
                function r(t, i) {
                    return e.exports = r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                        return e.__proto__ = t,
                        e
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports,
                    r(t, i)
                }
                e.exports = r,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                var i = r(26).default
                  , n = r(30);
                e.exports = function(e) {
                    var t = n(e, "string");
                    return "symbol" == i(t) ? t : t + ""
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                function i(e) {
                    var t = {};
                    function r(i) {
                        if (t[i])
                            return t[i].exports;
                        var n = t[i] = {
                            i: i,
                            l: !1,
                            exports: {}
                        };
                        return e[i].call(n.exports, n, n.exports, r),
                        n.l = !0,
                        n.exports
                    }
                    r.m = e,
                    r.c = t,
                    r.i = function(e) {
                        return e
                    }
                    ,
                    r.d = function(e, t, i) {
                        r.o(e, t) || Object.defineProperty(e, t, {
                            configurable: !1,
                            enumerable: !0,
                            get: i
                        })
                    }
                    ,
                    r.r = function(e) {
                        Object.defineProperty(e, "__esModule", {
                            value: !0
                        })
                    }
                    ,
                    r.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        }
                        : function() {
                            return e
                        }
                        ;
                        return r.d(t, "a", t),
                        t
                    }
                    ,
                    r.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }
                    ,
                    r.p = "/",
                    r.oe = function(e) {
                        throw console.error(e),
                        e
                    }
                    ;
                    var i = r(r.s = ENTRY_MODULE);
                    return i.default || i
                }
                function n(e) {
                    return (e + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
                }
                function a(e, t, i) {
                    var a = {};
                    a[i] = [];
                    var o = t.toString()
                      , s = o.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
                    if (!s)
                        return a;
                    for (var l, c = s[1], h = new RegExp("(\\\\n|\\W)" + n(c) + "\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)","g"); l = h.exec(o); )
                        "dll-reference" !== l[3] && a[i].push(l[3]);
                    for (h = new RegExp("\\(" + n(c) + '\\("(dll-reference\\s([\\.|\\-|\\+|\\w|/|@]+))"\\)\\)\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)',"g"); l = h.exec(o); )
                        e[l[2]] || (a[i].push(l[1]),
                        e[l[2]] = r(l[1]).m),
                        a[l[2]] = a[l[2]] || [],
                        a[l[2]].push(l[4]);
                    for (var u, d = Object.keys(a), f = 0; f < d.length; f++)
                        for (var p = 0; p < a[d[f]].length; p++)
                            u = a[d[f]][p],
                            isNaN(1 * u) || (a[d[f]][p] = 1 * a[d[f]][p]);
                    return a
                }
                function o(e) {
                    return Object.keys(e).reduce((function(t, r) {
                        return t || e[r].length > 0
                    }
                    ), !1)
                }
                e.exports = function(e, t) {
                    t = t || {};
                    var n = {
                        main: r.m
                    }
                      , s = t.all ? {
                        main: Object.keys(n.main)
                    } : function(e, t) {
                        for (var r = {
                            main: [t]
                        }, i = {
                            main: []
                        }, n = {
                            main: {}
                        }; o(r); )
                            for (var s = Object.keys(r), l = 0; l < s.length; l++) {
                                var c = s[l]
                                  , h = r[c].pop();
                                if (n[c] = n[c] || {},
                                !n[c][h] && e[c][h]) {
                                    n[c][h] = !0,
                                    i[c] = i[c] || [],
                                    i[c].push(h);
                                    for (var u = a(e, e[c][h], c), d = Object.keys(u), f = 0; f < d.length; f++)
                                        r[d[f]] = r[d[f]] || [],
                                        r[d[f]] = r[d[f]].concat(u[d[f]])
                                }
                            }
                        return i
                    }(n, e)
                      , l = "";
                    Object.keys(s).filter((function(e) {
                        return "main" !== e
                    }
                    )).forEach((function(e) {
                        for (var t = 0; s[e][t]; )
                            t++;
                        s[e].push(t),
                        n[e][t] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })",
                        l = l + "var " + e + " = (" + i.toString().replace("ENTRY_MODULE", JSON.stringify(t)) + ")({" + s[e].map((function(t) {
                            return JSON.stringify(t) + ": " + n[e][t].toString()
                        }
                        )).join(",") + "});\n"
                    }
                    )),
                    l = l + "new ((" + i.toString().replace("ENTRY_MODULE", JSON.stringify(e)) + ")({" + s.main.map((function(e) {
                        return JSON.stringify(e) + ": " + n.main[e].toString()
                    }
                    )).join(",") + "}))(self);";
                    var c = new window.Blob([l],{
                        type: "text/javascript"
                    });
                    if (t.bare)
                        return c;
                    var h = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(c)
                      , u = new window.Worker(h);
                    return u.objectURL = h,
                    u
                }
            }
            , function(e, t, r) {
                var i = r(26).default;
                e.exports = function(e, t) {
                    if ("object" != i(e) || !e)
                        return e;
                    var r = e[Symbol.toPrimitive];
                    if (void 0 !== r) {
                        var n = r.call(e, t || "default");
                        if ("object" != i(n))
                            return n;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t) {
                function r(t) {
                    return e.exports = r = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e)
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports,
                    r(t)
                }
                e.exports = r,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t) {
                e.exports = function(e) {
                    try {
                        return -1 !== Function.toString.call(e).indexOf("[native code]")
                    } catch (t) {
                        return "function" == typeof e
                    }
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                var i = r(34)
                  , n = r(27);
                e.exports = function(e, t, r) {
                    if (i())
                        return Reflect.construct.apply(null, arguments);
                    var a = [null];
                    a.push.apply(a, t);
                    var o = new (e.bind.apply(e, a));
                    return r && n(o, r.prototype),
                    o
                }
                ,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t) {
                function r() {
                    try {
                        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                        )))
                    } catch (t) {}
                    return (e.exports = r = function() {
                        return !!t
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports)()
                }
                e.exports = r,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                "use strict";
                r.r(t),
                r.d(t, "default", (function() {
                    return l
                }
                ));
                var i = r(9)
                  , n = r(0)
                  , a = r(1)
                  , o = r(20)
                  , s = r(14);
                function l(e) {
                    var t = new o.EventEmitter
                      , r = function(t, r) {
                        e.postMessage({
                            event: t,
                            data: r
                        })
                    }
                      , l = {
                        log: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r("log", {
                                type: "log",
                                msg: t
                            })
                        },
                        warn: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r("log", {
                                type: "warn",
                                msg: t
                            })
                        },
                        error: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r("log", {
                                type: "error",
                                msg: t
                            })
                        },
                        debug: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r("log", {
                                type: "debug",
                                msg: t
                            })
                        },
                        info: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r("log", {
                                type: "info",
                                msg: t
                            })
                        },
                        trace: function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                                t[i] = arguments[i];
                            return r("log", {
                                type: "trace",
                                msg: t
                            })
                        }
                    };
                    t.on(n.a.FRAG_DECRYPTED, r),
                    t.on(n.a.ERROR, r);
                    var h = !1
                      , d = 0
                      , f = ""
                      , p = function t(r) {
                        if (void 0 === r && (r = ""),
                        !h) {
                            h = !0;
                            try {
                                e.importScripts(f + r)
                            } catch (e) {
                                if (h = !1,
                                !(++d <= s.e))
                                    throw new Error(s.a);
                                t(/^blob:/.test(f) ? "" : "?t=" + Date.now())
                            }
                        }
                    }
                      , g = {};
                    e.addEventListener("message", (function(n) {
                        var o = n.data;
                        switch (o.cmd) {
                        case "init":
                            var h = JSON.parse(o.config);
                            if (f = h.decScriptUrl,
                            e.transmuxer = new i.c(t,o.typeSupported,h,o.vendor,o.id),
                            Object(a.a)(l),
                            r("init", null),
                            h.chachaParam) {
                                var d = h.chachaParam.cnlid ? s.d : s.c;
                                g = d(h.chachaParam),
                                p()
                            }
                            break;
                        case "configure":
                            e.transmuxer.configure(o.config);
                            break;
                        case "abort":
                            e.transmuxer.abort();
                            break;
                        case "demux":
                            var v = function() {
                                var t = e.transmuxer.push(o.data, o.decryptdata, o.chunkMeta, o.state);
                                Object(i.d)(t) ? t.then((function(t) {
                                    c(e, t)
                                }
                                )) : c(e, t)
                            };
                            Object(i.d)(g) ? g.then(v) : v();
                            break;
                        case "flush":
                            var y = function() {
                                var t = o.chunkMeta
                                  , r = e.transmuxer.flush(t);
                                Object(i.d)(r) ? r.then((function(r) {
                                    u(e, r, t)
                                }
                                )) : u(e, r, t)
                            };
                            Object(i.d)(g) ? g.then(y) : y();
                            break;
                        case "init-chacha-param":
                            var m = o.param.cnlid ? s.d : s.c;
                            g = m(o.param),
                            p();
                            break;
                        case "set-discontinuities":
                            e.transmuxer.discontinuities = o.param;
                            break;
                        case "clear-chacha-chunk":
                            Object(i.d)(g) && g.then((function() {
                                e.transmuxer.remainderChunk.flush()
                            }
                            ))
                        }
                    }
                    ))
                }
                function c(e, t) {
                    if ((r = t.remuxResult).audio || r.video || r.text || r.id3 || r.initSegment) {
                        var r, i = [], n = t.remuxResult, a = n.audio, o = n.video;
                        a && h(i, a),
                        o && h(i, o),
                        e.postMessage({
                            event: "transmuxComplete",
                            data: t
                        }, i)
                    }
                }
                function h(e, t) {
                    t.data1 && e.push(t.data1.buffer),
                    t.data2 && e.push(t.data2.buffer)
                }
                function u(e, t, r) {
                    t.forEach((function(t) {
                        c(e, t)
                    }
                    )),
                    e.postMessage({
                        event: "flush",
                        data: r
                    })
                }
            }
            , function(e, t, r) {
                var i = r(26).default;
                function n() {
                    "use strict";
                    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
                    e.exports = n = function() {
                        return r
                    }
                    ,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports;
                    var t, r = {}, a = Object.prototype, o = a.hasOwnProperty, s = Object.defineProperty || function(e, t, r) {
                        e[t] = r.value
                    }
                    , l = "function" == typeof Symbol ? Symbol : {}, c = l.iterator || "@@iterator", h = l.asyncIterator || "@@asyncIterator", u = l.toStringTag || "@@toStringTag";
                    function d(e, t, r) {
                        return Object.defineProperty(e, t, {
                            value: r,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }),
                        e[t]
                    }
                    try {
                        d({}, "")
                    } catch (t) {
                        d = function(e, t, r) {
                            return e[t] = r
                        }
                    }
                    function f(e, t, r, i) {
                        var n = t && t.prototype instanceof T ? t : T
                          , a = Object.create(n.prototype)
                          , o = new _(i || []);
                        return s(a, "_invoke", {
                            value: L(e, r, o)
                        }),
                        a
                    }
                    function p(e, t, r) {
                        try {
                            return {
                                type: "normal",
                                arg: e.call(t, r)
                            }
                        } catch (e) {
                            return {
                                type: "throw",
                                arg: e
                            }
                        }
                    }
                    r.wrap = f;
                    var g = "suspendedStart"
                      , v = "executing"
                      , y = "completed"
                      , m = {};
                    function T() {}
                    function S() {}
                    function I() {}
                    var P = {};
                    d(P, c, (function() {
                        return this
                    }
                    ));
                    var b = Object.getPrototypeOf
                      , E = b && b(b(x([])));
                    E && E !== a && o.call(E, c) && (P = E);
                    var D = I.prototype = T.prototype = Object.create(P);
                    function k(e) {
                        ["next", "throw", "return"].forEach((function(t) {
                            d(e, t, (function(e) {
                                return this._invoke(t, e)
                            }
                            ))
                        }
                        ))
                    }
                    function C(e, t) {
                        function r(n, a, s, l) {
                            var c = p(e[n], e, a);
                            if ("throw" !== c.type) {
                                var h = c.arg
                                  , u = h.value;
                                return u && "object" == i(u) && o.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                    r("next", e, s, l)
                                }
                                ), (function(e) {
                                    r("throw", e, s, l)
                                }
                                )) : t.resolve(u).then((function(e) {
                                    h.value = e,
                                    s(h)
                                }
                                ), (function(e) {
                                    return r("throw", e, s, l)
                                }
                                ))
                            }
                            l(c.arg)
                        }
                        var n;
                        s(this, "_invoke", {
                            value: function(e, i) {
                                function a() {
                                    return new t((function(t, n) {
                                        r(e, i, t, n)
                                    }
                                    ))
                                }
                                return n = n ? n.then(a, a) : a()
                            }
                        })
                    }
                    function L(e, r, i) {
                        var n = g;
                        return function(a, o) {
                            if (n === v)
                                throw Error("Generator is already running");
                            if (n === y) {
                                if ("throw" === a)
                                    throw o;
                                return {
                                    value: t,
                                    done: !0
                                }
                            }
                            for (i.method = a,
                            i.arg = o; ; ) {
                                var s = i.delegate;
                                if (s) {
                                    var l = w(s, i);
                                    if (l) {
                                        if (l === m)
                                            continue;
                                        return l
                                    }
                                }
                                if ("next" === i.method)
                                    i.sent = i._sent = i.arg;
                                else if ("throw" === i.method) {
                                    if (n === g)
                                        throw n = y,
                                        i.arg;
                                    i.dispatchException(i.arg)
                                } else
                                    "return" === i.method && i.abrupt("return", i.arg);
                                n = v;
                                var c = p(e, r, i);
                                if ("normal" === c.type) {
                                    if (n = i.done ? y : "suspendedYield",
                                    c.arg === m)
                                        continue;
                                    return {
                                        value: c.arg,
                                        done: i.done
                                    }
                                }
                                "throw" === c.type && (n = y,
                                i.method = "throw",
                                i.arg = c.arg)
                            }
                        }
                    }
                    function w(e, r) {
                        var i = r.method
                          , n = e.iterator[i];
                        if (n === t)
                            return r.delegate = null,
                            "throw" === i && e.iterator.return && (r.method = "return",
                            r.arg = t,
                            w(e, r),
                            "throw" === r.method) || "return" !== i && (r.method = "throw",
                            r.arg = new TypeError("The iterator does not provide a '" + i + "' method")),
                            m;
                        var a = p(n, e.iterator, r.arg);
                        if ("throw" === a.type)
                            return r.method = "throw",
                            r.arg = a.arg,
                            r.delegate = null,
                            m;
                        var o = a.arg;
                        return o ? o.done ? (r[e.resultName] = o.value,
                        r.next = e.nextLoc,
                        "return" !== r.method && (r.method = "next",
                        r.arg = t),
                        r.delegate = null,
                        m) : o : (r.method = "throw",
                        r.arg = new TypeError("iterator result is not an object"),
                        r.delegate = null,
                        m)
                    }
                    function R(e) {
                        var t = {
                            tryLoc: e[0]
                        };
                        1 in e && (t.catchLoc = e[1]),
                        2 in e && (t.finallyLoc = e[2],
                        t.afterLoc = e[3]),
                        this.tryEntries.push(t)
                    }
                    function A(e) {
                        var t = e.completion || {};
                        t.type = "normal",
                        delete t.arg,
                        e.completion = t
                    }
                    function _(e) {
                        this.tryEntries = [{
                            tryLoc: "root"
                        }],
                        e.forEach(R, this),
                        this.reset(!0)
                    }
                    function x(e) {
                        if (e || "" === e) {
                            var r = e[c];
                            if (r)
                                return r.call(e);
                            if ("function" == typeof e.next)
                                return e;
                            if (!isNaN(e.length)) {
                                var n = -1
                                  , a = function r() {
                                    for (; ++n < e.length; )
                                        if (o.call(e, n))
                                            return r.value = e[n],
                                            r.done = !1,
                                            r;
                                    return r.value = t,
                                    r.done = !0,
                                    r
                                };
                                return a.next = a
                            }
                        }
                        throw new TypeError(i(e) + " is not iterable")
                    }
                    return S.prototype = I,
                    s(D, "constructor", {
                        value: I,
                        configurable: !0
                    }),
                    s(I, "constructor", {
                        value: S,
                        configurable: !0
                    }),
                    S.displayName = d(I, u, "GeneratorFunction"),
                    r.isGeneratorFunction = function(e) {
                        var t = "function" == typeof e && e.constructor;
                        return !!t && (t === S || "GeneratorFunction" === (t.displayName || t.name))
                    }
                    ,
                    r.mark = function(e) {
                        return Object.setPrototypeOf ? Object.setPrototypeOf(e, I) : (e.__proto__ = I,
                        d(e, u, "GeneratorFunction")),
                        e.prototype = Object.create(D),
                        e
                    }
                    ,
                    r.awrap = function(e) {
                        return {
                            __await: e
                        }
                    }
                    ,
                    k(C.prototype),
                    d(C.prototype, h, (function() {
                        return this
                    }
                    )),
                    r.AsyncIterator = C,
                    r.async = function(e, t, i, n, a) {
                        void 0 === a && (a = Promise);
                        var o = new C(f(e, t, i, n),a);
                        return r.isGeneratorFunction(t) ? o : o.next().then((function(e) {
                            return e.done ? e.value : o.next()
                        }
                        ))
                    }
                    ,
                    k(D),
                    d(D, u, "Generator"),
                    d(D, c, (function() {
                        return this
                    }
                    )),
                    d(D, "toString", (function() {
                        return "[object Generator]"
                    }
                    )),
                    r.keys = function(e) {
                        var t = Object(e)
                          , r = [];
                        for (var i in t)
                            r.push(i);
                        return r.reverse(),
                        function e() {
                            for (; r.length; ) {
                                var i = r.pop();
                                if (i in t)
                                    return e.value = i,
                                    e.done = !1,
                                    e
                            }
                            return e.done = !0,
                            e
                        }
                    }
                    ,
                    r.values = x,
                    _.prototype = {
                        constructor: _,
                        reset: function(e) {
                            if (this.prev = 0,
                            this.next = 0,
                            this.sent = this._sent = t,
                            this.done = !1,
                            this.delegate = null,
                            this.method = "next",
                            this.arg = t,
                            this.tryEntries.forEach(A),
                            !e)
                                for (var r in this)
                                    "t" === r.charAt(0) && o.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t)
                        },
                        stop: function() {
                            this.done = !0;
                            var e = this.tryEntries[0].completion;
                            if ("throw" === e.type)
                                throw e.arg;
                            return this.rval
                        },
                        dispatchException: function(e) {
                            if (this.done)
                                throw e;
                            var r = this;
                            function i(i, n) {
                                return s.type = "throw",
                                s.arg = e,
                                r.next = i,
                                n && (r.method = "next",
                                r.arg = t),
                                !!n
                            }
                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                var a = this.tryEntries[n]
                                  , s = a.completion;
                                if ("root" === a.tryLoc)
                                    return i("end");
                                if (a.tryLoc <= this.prev) {
                                    var l = o.call(a, "catchLoc")
                                      , c = o.call(a, "finallyLoc");
                                    if (l && c) {
                                        if (this.prev < a.catchLoc)
                                            return i(a.catchLoc, !0);
                                        if (this.prev < a.finallyLoc)
                                            return i(a.finallyLoc)
                                    } else if (l) {
                                        if (this.prev < a.catchLoc)
                                            return i(a.catchLoc, !0)
                                    } else {
                                        if (!c)
                                            throw Error("try statement without catch or finally");
                                        if (this.prev < a.finallyLoc)
                                            return i(a.finallyLoc)
                                    }
                                }
                            }
                        },
                        abrupt: function(e, t) {
                            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                var i = this.tryEntries[r];
                                if (i.tryLoc <= this.prev && o.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                                    var n = i;
                                    break
                                }
                            }
                            n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
                            var a = n ? n.completion : {};
                            return a.type = e,
                            a.arg = t,
                            n ? (this.method = "next",
                            this.next = n.finallyLoc,
                            m) : this.complete(a)
                        },
                        complete: function(e, t) {
                            if ("throw" === e.type)
                                throw e.arg;
                            return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg,
                            this.method = "return",
                            this.next = "end") : "normal" === e.type && t && (this.next = t),
                            m
                        },
                        finish: function(e) {
                            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                var r = this.tryEntries[t];
                                if (r.finallyLoc === e)
                                    return this.complete(r.completion, r.afterLoc),
                                    A(r),
                                    m
                            }
                        },
                        catch: function(e) {
                            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                var r = this.tryEntries[t];
                                if (r.tryLoc === e) {
                                    var i = r.completion;
                                    if ("throw" === i.type) {
                                        var n = i.arg;
                                        A(r)
                                    }
                                    return n
                                }
                            }
                            throw Error("illegal catch attempt")
                        },
                        delegateYield: function(e, r, i) {
                            return this.delegate = {
                                iterator: x(e),
                                resultName: r,
                                nextLoc: i
                            },
                            "next" === this.method && (this.arg = t),
                            m
                        }
                    },
                    r
                }
                e.exports = n,
                e.exports.__esModule = !0,
                e.exports.default = e.exports
            }
            , function(e, t, r) {
                "use strict";
                r.r(t),
                r.d(t, "default", (function() {
                    return _t
                }
                )),
                r.d(t, "EwmaBandWidthEstimator", (function() {
                    return tt
                }
                ));
                var i = r(5)
                  , n = r.n(i)
                  , a = r(15)
                  , o = r(3)
                  , s = r(16)
                  , l = r.n(s)
                  , c = r(0)
                  , h = r(2)
                  , u = r(1)
                  , d = r(7)
                  , f = r(6)
                  , p = function() {
                    function e(e) {
                        this.PTSKnown = !1,
                        this.alignedSliding = !1,
                        this.averagetargetduration = void 0,
                        this.endCC = 0,
                        this.endSN = 0,
                        this.fragments = void 0,
                        this.fragmentHint = void 0,
                        this.partList = null,
                        this.live = !0,
                        this.ageHeader = 0,
                        this.advancedDateTime = void 0,
                        this.updated = !0,
                        this.advanced = !0,
                        this.availabilityDelay = void 0,
                        this.misses = 0,
                        this.needSidxRanges = !1,
                        this.startCC = 0,
                        this.startSN = 0,
                        this.firstLoadSN = 0,
                        this.startTimeOffset = null,
                        this.targetduration = 0,
                        this.totalduration = 0,
                        this.type = null,
                        this.url = void 0,
                        this.m3u8 = "",
                        this.version = null,
                        this.canBlockReload = !1,
                        this.canSkipUntil = 0,
                        this.canSkipDateRanges = !1,
                        this.skippedSegments = 0,
                        this.recentlyRemovedDateranges = void 0,
                        this.partHoldBack = 0,
                        this.holdBack = 0,
                        this.partTarget = 0,
                        this.preloadHint = void 0,
                        this.renditionReports = void 0,
                        this.tuneInGoal = 0,
                        this.deltaUpdateFailed = void 0,
                        this.driftStartTime = 0,
                        this.driftEndTime = 0,
                        this.driftStart = 0,
                        this.driftEnd = 0,
                        this.discontinuityTimeRanges = [],
                        this.fragments = [],
                        this.url = e
                    }
                    return e.prototype.reloaded = function(e) {
                        if (!e)
                            return this.advanced = !0,
                            void (this.updated = !0);
                        var t = this.lastPartSn - e.lastPartSn
                          , r = this.lastPartIndex - e.lastPartIndex;
                        this.updated = this.endSN !== e.endSN || !!r || !!t,
                        this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && r > 0,
                        this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1,
                        this.availabilityDelay = e.availabilityDelay
                    }
                    ,
                    n()(e, [{
                        key: "hasProgramDateTime",
                        get: function() {
                            return !!this.fragments.length && Object(o.a)(this.fragments[this.fragments.length - 1].programDateTime)
                        }
                    }, {
                        key: "levelTargetDuration",
                        get: function() {
                            return this.averagetargetduration || this.targetduration || 10
                        }
                    }, {
                        key: "drift",
                        get: function() {
                            var e = this.driftEndTime - this.driftStartTime;
                            return e > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e : 1
                        }
                    }, {
                        key: "edge",
                        get: function() {
                            return this.partEnd || this.fragmentEnd
                        }
                    }, {
                        key: "partEnd",
                        get: function() {
                            var e;
                            return null !== (e = this.partList) && void 0 !== e && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
                        }
                    }, {
                        key: "fragmentEnd",
                        get: function() {
                            var e;
                            return null !== (e = this.fragments) && void 0 !== e && e.length ? this.fragments[this.fragments.length - 1].end : 0
                        }
                    }, {
                        key: "age",
                        get: function() {
                            return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
                        }
                    }, {
                        key: "lastPartIndex",
                        get: function() {
                            var e;
                            return null !== (e = this.partList) && void 0 !== e && e.length ? this.partList[this.partList.length - 1].index : -1
                        }
                    }, {
                        key: "lastPartSn",
                        get: function() {
                            var e;
                            return null !== (e = this.partList) && void 0 !== e && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                        }
                    }])
                }()
                  , g = r(23)
                  , v = /^(\d+)x(\d+)$/
                  , y = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g
                  , m = function() {
                    function e(t) {
                        for (var r in "string" == typeof t && (t = e.parseAttrList(t)),
                        t)
                            t.hasOwnProperty(r) && (this[r] = t[r])
                    }
                    var t = e.prototype;
                    return t.decimalInteger = function(e) {
                        var t = parseInt(this[e], 10);
                        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
                    }
                    ,
                    t.hexadecimalInteger = function(e) {
                        if (this[e]) {
                            var t = (this[e] || "0x").slice(2);
                            t = (1 & t.length ? "0" : "") + t;
                            for (var r = new Uint8Array(t.length / 2), i = 0; i < t.length / 2; i++)
                                r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16);
                            return r
                        }
                        return null
                    }
                    ,
                    t.hexadecimalIntegerAsNumber = function(e) {
                        var t = parseInt(this[e], 16);
                        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
                    }
                    ,
                    t.decimalFloatingPoint = function(e) {
                        return parseFloat(this[e])
                    }
                    ,
                    t.optionalFloat = function(e, t) {
                        var r = this[e];
                        return r ? parseFloat(r) : t
                    }
                    ,
                    t.enumeratedString = function(e) {
                        return this[e]
                    }
                    ,
                    t.bool = function(e) {
                        return "YES" === this[e]
                    }
                    ,
                    t.decimalResolution = function(e) {
                        var t = v.exec(this[e]);
                        if (null !== t)
                            return {
                                width: parseInt(t[1], 10),
                                height: parseInt(t[2], 10)
                            }
                    }
                    ,
                    e.parseAttrList = function(e) {
                        var t, r = {};
                        for (y.lastIndex = 0; null !== (t = y.exec(e)); ) {
                            var i = t[2];
                            0 === i.indexOf('"') && i.lastIndexOf('"') === i.length - 1 && (i = i.slice(1, -1)),
                            r[t[1]] = i
                        }
                        return r
                    }
                    ,
                    e
                }()
                  , T = {
                    audio: {
                        a3ds: !0,
                        "ac-3": !0,
                        "ac-4": !0,
                        alac: !0,
                        alaw: !0,
                        dra1: !0,
                        "dts+": !0,
                        "dts-": !0,
                        dtsc: !0,
                        dtse: !0,
                        dtsh: !0,
                        "ec-3": !0,
                        enca: !0,
                        g719: !0,
                        g726: !0,
                        m4ae: !0,
                        mha1: !0,
                        mha2: !0,
                        mhm1: !0,
                        mhm2: !0,
                        mlpa: !0,
                        mp4a: !0,
                        "raw ": !0,
                        Opus: !0,
                        samr: !0,
                        sawb: !0,
                        sawp: !0,
                        sevc: !0,
                        sqcp: !0,
                        ssmv: !0,
                        twos: !0,
                        ulaw: !0
                    },
                    video: {
                        avc1: !0,
                        avc2: !0,
                        avc3: !0,
                        avc4: !0,
                        avcp: !0,
                        av01: !0,
                        drac: !0,
                        dvav: !0,
                        dvhe: !0,
                        encv: !0,
                        hev1: !0,
                        hvc1: !0,
                        mjp2: !0,
                        mp4v: !0,
                        mvc1: !0,
                        mvc2: !0,
                        mvc3: !0,
                        mvc4: !0,
                        resv: !0,
                        rv60: !0,
                        s263: !0,
                        svc1: !0,
                        svc2: !0,
                        "vc-1": !0,
                        vp08: !0,
                        vp09: !0
                    },
                    text: {
                        stpp: !0,
                        wvtt: !0
                    }
                };
                function S(e, t) {
                    return MediaSource.isTypeSupported((t || "video") + '/mp4;codecs="' + e + '"')
                }
                function I(e, t) {
                    var r = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var i = Object.getOwnPropertySymbols(e);
                        t && (i = i.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }
                        ))),
                        r.push.apply(r, i)
                    }
                    return r
                }
                function P(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var r = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? I(Object(r), !0).forEach((function(t) {
                            l()(e, t, r[t])
                        }
                        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : I(Object(r)).forEach((function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                        }
                        ))
                    }
                    return e
                }
                var b = /((?:#(?!EXT-X).*:.*[\r\n])*)/g
                  , E = /(?:#)([^:]*):(.*)/
                  , D = /(?:#)(.*)/
                  , k = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+/g
                  , C = /#EXT-X-MEDIA:(.*)/g
                  , L = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"),"g")
                  , w = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\s*(\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"))
                  , R = /\.(mp4|m4s|m4v|m4a)$/i
                  , A = function() {
                    function e() {}
                    return e.findGroup = function(e, t) {
                        for (var r = 0; r < e.length; r++) {
                            var i = e[r];
                            if (i.id === t)
                                return i
                        }
                    }
                    ,
                    e.convertAVC1ToAVCOTI = function(e) {
                        var t = e.split(".");
                        if (t.length > 2) {
                            var r = t.shift() + ".";
                            return (r += parseInt(t.shift()).toString(16)) + ("000" + parseInt(t.shift()).toString(16)).substr(-4)
                        }
                        return e
                    }
                    ,
                    e.resolve = function(e, t) {
                        return a.buildAbsoluteURL(t, e, {
                            alwaysNormalize: !0
                        })
                    }
                    ,
                    e.parseMasterPlaylist = function(t, r) {
                        var i, n = [], a = {}, o = !1;
                        k.lastIndex = 0;
                        for (var s = new RegExp(b.source + k.source,k.flags); null != (i = s.exec(t)); )
                            if (i[2]) {
                                var l = new m(i[2])
                                  , c = {
                                    tags: F(i[1]),
                                    attrs: l,
                                    bitrate: l.decimalInteger("AVERAGE-BANDWIDTH") || l.decimalInteger("BANDWIDTH"),
                                    name: l.NAME,
                                    url: e.resolve(i[3], r)
                                }
                                  , h = l.decimalResolution("RESOLUTION");
                                h && (c.width = h.width,
                                c.height = h.height),
                                _((l.CODECS || "").split(/[ ,]+/).filter((function(e) {
                                    return e
                                }
                                )), c),
                                c.videoCodec && -1 !== c.videoCodec.indexOf("avc1") && (c.videoCodec = e.convertAVC1ToAVCOTI(c.videoCodec)),
                                n.push(c)
                            } else if (i[4]) {
                                var u = new m(i[4]);
                                u["DATA-ID"] && (o = !0,
                                a[u["DATA-ID"]] = u)
                            }
                        return {
                            levels: n,
                            sessionData: o ? a : null
                        }
                    }
                    ,
                    e.parseMasterPlaylistMedia = function(t, r, i, n, a) {
                        var o;
                        void 0 === a && (a = function(e) {
                            return e
                        }
                        );
                        var s = []
                          , l = 0;
                        C.lastIndex = 0;
                        for (var c = new RegExp(b.source + C.source,C.flags); null !== (o = c.exec(t)); ) {
                            var h = new m(o[2]);
                            if (h.TYPE === i) {
                                var u = {
                                    tags: F(o[1]),
                                    attrs: h,
                                    bitrate: 0,
                                    id: l++,
                                    groupId: h["GROUP-ID"],
                                    instreamId: h["INSTREAM-ID"],
                                    name: h.NAME || h.LANGUAGE || "",
                                    type: i,
                                    default: h.bool("DEFAULT"),
                                    autoselect: h.bool("AUTOSELECT"),
                                    forced: h.bool("FORCED"),
                                    lang: h.LANGUAGE,
                                    url: h.URI ? e.resolve(h.URI, r) : ""
                                };
                                if (n.length) {
                                    var d = e.findGroup(n, u.groupId) || n[0];
                                    x(u, d, "audioCodec"),
                                    x(u, d, "textCodec")
                                }
                                s.push(a(u))
                            }
                        }
                        return s
                    }
                    ,
                    e.parseLevelPlaylist = function(e, t, r, i, n, s) {
                        void 0 === s && (s = null);
                        var l, c, h, d = new p(t), v = d.fragments, y = null, T = 0, S = 0, I = 0, b = 0, E = null, D = new f.b(i,t), k = -1, C = !1, A = !1, _ = null, x = [];
                        for (L.lastIndex = 0,
                        d.m3u8 = e; null !== (l = L.exec(e)); ) {
                            C && (C = !1,
                            (D = new f.b(i,t)).start = I,
                            D.sn = T,
                            D.cc = b,
                            D.level = r,
                            y && (D.initSegment = y,
                            D.rawProgramDateTime = y.rawProgramDateTime));
                            var F = l[1];
                            if (F) {
                                D.duration = parseFloat(F);
                                var B = (" " + l[2]).slice(1);
                                D.title = B || null,
                                D.tagList.push(B ? ["INF", F, B] : ["INF", F])
                            } else if (l[3]) {
                                if (Object(o.a)(D.duration)) {
                                    var M, U;
                                    if (D.start = I,
                                    h && (D.levelkey = h),
                                    D.sn = T,
                                    D.level = r,
                                    D.cc = b,
                                    D.urlId = n,
                                    D.relurl = (" " + l[3]).slice(1),
                                    O(D, E),
                                    E = D,
                                    I += D.duration,
                                    T++,
                                    S = 0,
                                    null !== (M = s) && void 0 !== M && M.fragUrlProcessor) {
                                        var N = s.fragUrlProcessor(D)
                                          , G = N.relurl
                                          , H = N.ext;
                                        G && (D.relurl = G),
                                        D.ext = P(P({}, D.ext), H)
                                    }
                                    null !== (U = s) && void 0 !== U && U.fragReplace && (D = s.fragReplace(D)),
                                    v.push(D),
                                    C = !0
                                }
                            } else if (l[4]) {
                                var q = (" " + l[4]).slice(1);
                                E ? D.setByteRange(q, E) : D.setByteRange(q)
                            } else if (l[5])
                                D.rawProgramDateTime = (" " + l[5]).slice(1),
                                D.tagList.push(["PROGRAM-DATE-TIME", D.rawProgramDateTime]),
                                -1 === k && (k = v.length);
                            else {
                                if (!(l = l[0].match(w))) {
                                    u.b.warn("No matches on slow regex match for level playlist!");
                                    continue
                                }
                                for (c = 1; c < l.length && void 0 === l[c]; c++)
                                    ;
                                var z = (" " + l[c]).slice(1)
                                  , K = (" " + l[c + 1]).slice(1)
                                  , V = l[c + 2] ? (" " + l[c + 2]).slice(1) : "";
                                switch (z) {
                                case "PLAYLIST-TYPE":
                                    d.type = K.toUpperCase();
                                    break;
                                case "MEDIA-SEQUENCE":
                                    T = d.startSN = parseInt(K);
                                    break;
                                case "SKIP":
                                    var j = new m(K)
                                      , W = j.decimalInteger("SKIPPED-SEGMENTS");
                                    if (Object(o.a)(W)) {
                                        d.skippedSegments = W;
                                        for (var Y = W; Y--; )
                                            v.unshift(null);
                                        T += W
                                    }
                                    var Q = j.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                                    Q && (d.recentlyRemovedDateranges = Q.split("\t"));
                                    break;
                                case "TARGETDURATION":
                                    d.targetduration = parseFloat(K);
                                    break;
                                case "VERSION":
                                    d.version = parseInt(K);
                                    break;
                                case "EXTM3U":
                                    break;
                                case "ENDLIST":
                                    d.live = !1;
                                    break;
                                case "#":
                                    (K || V) && D.tagList.push(V ? [K, V] : [K]);
                                    break;
                                case "DIS":
                                    b++,
                                    A ? _ && (_.end = I,
                                    A = !1,
                                    x.push(_),
                                    _ = null) : (_ = {
                                        start: I,
                                        end: 0,
                                        cc: b
                                    },
                                    A = !0);
                                case "GAP":
                                    D.tagList.push([z]);
                                    break;
                                case "BITRATE":
                                    D.tagList.push([z, K]);
                                    break;
                                case "DISCONTINUITY-SEQ":
                                    b = parseInt(K);
                                    break;
                                case "KEY":
                                    var X, Z = new m(K), J = Z.enumeratedString("METHOD"), $ = Z.URI, ee = Z.hexadecimalInteger("IV"), te = Z.enumeratedString("KEYFORMATVERSIONS"), re = Z.enumeratedString("KEYID"), ie = null != (X = Z.enumeratedString("KEYFORMAT")) ? X : "identity";
                                    if (["com.apple.streamingkeydelivery", "com.microsoft.playready", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", "com.widevine"].indexOf(ie) > -1) {
                                        u.b.warn("Keyformat " + ie + " is not supported from the manifest");
                                        continue
                                    }
                                    if ("identity" !== ie)
                                        continue;
                                    J && (h = g.a.fromURL(t, $),
                                    $ && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(J) >= 0 && (h.method = J,
                                    h.keyFormat = ie,
                                    re && (h.keyID = re),
                                    te && (h.keyFormatVersions = te),
                                    h.iv = ee));
                                    break;
                                case "START":
                                    var ne = new m(K).decimalFloatingPoint("TIME-OFFSET");
                                    Object(o.a)(ne) && (d.startTimeOffset = ne);
                                    break;
                                case "MAP":
                                    var ae, oe = new m(K);
                                    if (D.relurl = oe.URI,
                                    oe.BYTERANGE && D.setByteRange(oe.BYTERANGE),
                                    D.level = r,
                                    D.sn = "initSegment",
                                    h && (D.levelkey = h),
                                    D.initSegment = null,
                                    y = D,
                                    C = !0,
                                    null !== (ae = s) && void 0 !== ae && ae.fragUrlProcessor) {
                                        var se = s.fragUrlProcessor(D)
                                          , le = se.relurl
                                          , ce = se.ext;
                                        le && (D.relurl = le),
                                        D.ext = P(P({}, D.ext), ce)
                                    }
                                    break;
                                case "SERVER-CONTROL":
                                    var he = new m(K);
                                    d.canBlockReload = he.bool("CAN-BLOCK-RELOAD"),
                                    d.canSkipUntil = he.optionalFloat("CAN-SKIP-UNTIL", 0),
                                    d.canSkipDateRanges = d.canSkipUntil > 0 && he.bool("CAN-SKIP-DATERANGES"),
                                    d.partHoldBack = he.optionalFloat("PART-HOLD-BACK", 0),
                                    d.holdBack = he.optionalFloat("HOLD-BACK", 0);
                                    break;
                                case "PART-INF":
                                    var ue = new m(K);
                                    d.partTarget = ue.decimalFloatingPoint("PART-TARGET");
                                    break;
                                case "PART":
                                    var de = d.partList;
                                    de || (de = d.partList = []);
                                    var fe = S > 0 ? de[de.length - 1] : void 0
                                      , pe = S++
                                      , ge = new f.c(new m(K),D,t,pe,fe);
                                    de.push(ge),
                                    D.duration += ge.duration;
                                    break;
                                case "PRELOAD-HINT":
                                    var ve = new m(K);
                                    d.preloadHint = ve;
                                    break;
                                case "RENDITION-REPORT":
                                    var ye = new m(K);
                                    d.renditionReports = d.renditionReports || [],
                                    d.renditionReports.push(ye);
                                    break;
                                default:
                                    u.b.warn("line parsed but not handled: " + l)
                                }
                            }
                        }
                        _ && (_.end = I,
                        x.push(_)),
                        E && !E.relurl ? (v.pop(),
                        I -= E.duration,
                        d.partList && (d.fragmentHint = E)) : d.partList && (O(D, E),
                        D.cc = b,
                        d.fragmentHint = D);
                        var me = v.length
                          , Te = v[0]
                          , Se = v[me - 1];
                        if ((I += d.skippedSegments * d.targetduration) > 0 && me && Se) {
                            d.averagetargetduration = I / me;
                            var Ie = Se.sn;
                            d.endSN = "initSegment" !== Ie ? Ie : 0,
                            Te && (d.startCC = Te.cc,
                            Te.initSegment || d.fragments.every((function(e) {
                                return e.relurl && (t = e.relurl,
                                R.test(null != (r = null === (i = a.parseURL(t)) || void 0 === i ? void 0 : i.path) ? r : ""));
                                var t, r, i
                            }
                            )) && (u.b.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"),
                            (D = new f.b(i,t)).relurl = Se.relurl,
                            D.level = r,
                            D.sn = "initSegment",
                            Te.initSegment = D,
                            d.needSidxRanges = !0))
                        } else
                            d.endSN = 0,
                            d.startCC = 0;
                        return d.fragmentHint && (I += d.fragmentHint.duration),
                        d.totalduration = I,
                        d.endCC = b,
                        d.discontinuityTimeRanges = x,
                        k > 0 && function(e, t) {
                            for (var r = e[t], i = t; i--; ) {
                                var n = e[i];
                                if (!n)
                                    return;
                                n.programDateTime = r.programDateTime - 1e3 * n.duration,
                                r = n
                            }
                        }(v, k),
                        d.targetduration = Math.min.apply(Math, v.map((function(e) {
                            return (null == e ? void 0 : e.duration) || 0
                        }
                        ))),
                        d
                    }
                    ,
                    e
                }();
                function _(e, t) {
                    ["video", "audio", "text"].forEach((function(r) {
                        var i = e.filter((function(e) {
                            return function(e, t) {
                                var r = T[t];
                                return !!r && !0 === r[e.slice(0, 4)]
                            }(e, r)
                        }
                        ));
                        if (i.length) {
                            var n = i.filter((function(e) {
                                return 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)
                            }
                            ));
                            t[r + "Codec"] = n.length > 0 ? n[0] : i[0],
                            e = e.filter((function(e) {
                                return -1 === i.indexOf(e)
                            }
                            ))
                        }
                    }
                    )),
                    t.unknownCodecs = e
                }
                function x(e, t, r) {
                    var i = t[r];
                    i && (e[r] = i)
                }
                function O(e, t) {
                    e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime),
                    Object(o.a)(e.programDateTime) || (e.programDateTime = null,
                    e.rawProgramDateTime = null)
                }
                function F(e) {
                    var t = [];
                    return e.split(/[\r\n]/).forEach((function(e) {
                        var r = e.match(E) || e.match(D);
                        r && (r[2] ? t.push([r[1], r[2]]) : t.push([r[1]]))
                    }
                    )),
                    t
                }
                var B = r(4);
                function M(e, t) {
                    var r = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var i = Object.getOwnPropertySymbols(e);
                        t && (i = i.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }
                        ))),
                        r.push.apply(r, i)
                    }
                    return r
                }
                function U(e, t) {
                    var r = e.url;
                    return void 0 !== r && 0 !== r.indexOf("data:") || (r = t.url),
                    r
                }
                var N = function() {
                    function e(e) {
                        this.hls = void 0,
                        this.loaders = Object.create(null),
                        this.hls = e,
                        this.registerListeners()
                    }
                    var t = e.prototype;
                    return t.registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.on(c.a.M3U8_DIRECT_LOAD, this.onM3U8DirectLoad, this),
                        e.on(c.a.LEVEL_LOADING, this.onLevelLoading, this),
                        e.on(c.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
                        e.on(c.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                    }
                    ,
                    t.unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.M3U8_DIRECT_LOAD, this.onM3U8DirectLoad, this),
                        e.off(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.off(c.a.LEVEL_LOADING, this.onLevelLoading, this),
                        e.off(c.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
                        e.off(c.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                    }
                    ,
                    t.createInternalLoader = function(e) {
                        var t = this.hls.config
                          , r = t.pLoader
                          , i = t.loader
                          , n = new (r || i)(t);
                        return e.loader = n,
                        this.loaders[e.type] = n,
                        n
                    }
                    ,
                    t.getInternalLoader = function(e) {
                        return this.loaders[e.type]
                    }
                    ,
                    t.resetInternalLoader = function(e) {
                        this.loaders[e] && delete this.loaders[e]
                    }
                    ,
                    t.destroyInternalLoaders = function() {
                        for (var e in this.loaders) {
                            var t = this.loaders[e];
                            t && t.destroy(),
                            this.resetInternalLoader(e)
                        }
                    }
                    ,
                    t.destroy = function() {
                        this.unregisterListeners(),
                        this.destroyInternalLoaders()
                    }
                    ,
                    t.onM3U8DirectLoad = function(e, t) {
                        var r = t.url
                          , i = t.m3u8;
                        this.load({
                            id: null,
                            level: 0,
                            type: B.a.MANIFEST,
                            url: r,
                            groupId: null,
                            responseType: "text",
                            deliveryDirectives: null
                        }, i)
                    }
                    ,
                    t.onManifestLoading = function(e, t) {
                        var r = t.url;
                        this.load({
                            id: null,
                            groupId: null,
                            level: 0,
                            responseType: "text",
                            type: B.a.MANIFEST,
                            url: r,
                            deliveryDirectives: null
                        })
                    }
                    ,
                    t.onLevelLoading = function(e, t) {
                        var r = t.id
                          , i = t.level
                          , n = t.url
                          , a = t.deliveryDirectives
                          , o = t.m3u8;
                        this.load({
                            id: r,
                            groupId: null,
                            level: i,
                            responseType: "text",
                            type: B.a.LEVEL,
                            url: n,
                            deliveryDirectives: a
                        }, o)
                    }
                    ,
                    t.onAudioTrackLoading = function(e, t) {
                        var r = t.id
                          , i = t.groupId
                          , n = t.url
                          , a = t.deliveryDirectives;
                        this.load({
                            id: r,
                            groupId: i,
                            level: null,
                            responseType: "text",
                            type: B.a.AUDIO_TRACK,
                            url: n,
                            deliveryDirectives: a
                        })
                    }
                    ,
                    t.onSubtitleTrackLoading = function(e, t) {
                        var r = t.id
                          , i = t.groupId
                          , n = t.url
                          , a = t.deliveryDirectives;
                        this.load({
                            id: r,
                            groupId: i,
                            level: null,
                            responseType: "text",
                            type: B.a.SUBTITLE_TRACK,
                            url: n,
                            deliveryDirectives: a
                        })
                    }
                    ,
                    t.load = function(e, t) {
                        var r, i, n, a, o, s, l = this.hls.config, c = this.getInternalLoader(e);
                        if (c) {
                            var h = c.context;
                            if (h && h.url === e.url)
                                return void u.b.trace("[playlist-loader]: playlist request ongoing");
                            u.b.log("[playlist-loader]: aborting previous loader for type: " + e.type),
                            c.abort()
                        }
                        switch (e.type) {
                        case B.a.MANIFEST:
                            i = l.manifestLoadingMaxRetry,
                            n = l.manifestLoadingTimeOut,
                            a = l.manifestLoadingRetryDelay,
                            o = l.manifestLoadingMaxRetryTimeout;
                            break;
                        case B.a.LEVEL:
                        case B.a.AUDIO_TRACK:
                        case B.a.SUBTITLE_TRACK:
                            i = 0,
                            n = l.levelLoadingTimeOut;
                            break;
                        default:
                            i = l.levelLoadingMaxRetry,
                            n = l.levelLoadingTimeOut,
                            a = l.levelLoadingRetryDelay,
                            o = l.levelLoadingMaxRetryTimeout
                        }
                        if (c = this.createInternalLoader(e),
                        null !== (r = e.deliveryDirectives) && void 0 !== r && r.part && (e.type === B.a.LEVEL && null !== e.level ? s = this.hls.levels[e.level].details : e.type === B.a.AUDIO_TRACK && null !== e.id ? s = this.hls.audioTracks[e.id].details : e.type === B.a.SUBTITLE_TRACK && null !== e.id && (s = this.hls.subtitleTracks[e.id].details),
                        s)) {
                            var d = s.partTarget
                              , f = s.targetduration;
                            d && f && (n = Math.min(1e3 * Math.max(3 * d, .8 * f), n))
                        }
                        var p = {
                            timeout: n,
                            maxRetry: i,
                            retryDelay: a,
                            maxRetryDelay: o,
                            highWaterMark: 0,
                            proxy: this.hls.config.pProxy
                        }
                          , g = {
                            onSuccess: this.loadsuccess.bind(this),
                            onError: this.loaderror.bind(this),
                            onTimeout: this.loadtimeout.bind(this)
                        };
                        if (t) {
                            u.b.log("[playlist-loader] loading direct M3U8 playlist, no need to fetch any additional data");
                            var v = {
                                url: e.url,
                                data: t
                            };
                            self.setTimeout((function() {
                                g.onSuccess(v, {
                                    loading: {}
                                }, e)
                            }
                            ))
                        } else
                            c.load(e, p, g)
                    }
                    ,
                    t.loadsuccess = function(e, t, r, i) {
                        if (void 0 === i && (i = null),
                        r.isSidxRequest)
                            return this.handleSidxRequest(e, r),
                            void this.handlePlaylistLoaded(e, t, r, i);
                        this.resetInternalLoader(r.type);
                        var n = e.data;
                        t.parsing && (t.parsing.start = performance.now()),
                        0 === n.indexOf("#EXTM3U") ? n.indexOf("#EXTINF:") > 0 || n.indexOf("#EXT-X-TARGETDURATION:") > 0 ? this.handleTrackOrLevelPlaylist(e, t, r, i) : this.handleMasterPlaylist(e, t, r, i) : this.handleManifestParsingError(e, r, "no EXTM3U delimiter", i)
                    }
                    ,
                    t.loaderror = function(e, t, r) {
                        void 0 === r && (r = null),
                        this.handleNetworkError(t, r, !1, e)
                    }
                    ,
                    t.loadtimeout = function(e, t, r) {
                        void 0 === r && (r = null),
                        this.handleNetworkError(t, r, !0)
                    }
                    ,
                    t.handleMasterPlaylist = function(e, t, r, i) {
                        var n, a, o, s = this.hls, h = e.data, d = s.config.externalRedundantUrls, f = U(e, r), p = A.parseMasterPlaylist(h, f), g = p.levels, v = p.sessionData;
                        if (g.length) {
                            var y = g[0];
                            d && d.forEach((function(e) {
                                if (e !== y.url) {
                                    var t = function(e) {
                                        for (var t = 1; t < arguments.length; t++) {
                                            var r = null != arguments[t] ? arguments[t] : {};
                                            t % 2 ? M(Object(r), !0).forEach((function(t) {
                                                l()(e, t, r[t])
                                            }
                                            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : M(Object(r)).forEach((function(t) {
                                                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                                            }
                                            ))
                                        }
                                        return e
                                    }({}, y);
                                    t.url = e,
                                    g.push(t)
                                }
                            }
                            ));
                            var T = g.map((function(e) {
                                return {
                                    id: e.attrs.AUDIO,
                                    audioCodec: e.audioCodec
                                }
                            }
                            ))
                              , S = g.map((function(e) {
                                return {
                                    id: e.attrs.SUBTITLES,
                                    textCodec: e.textCodec
                                }
                            }
                            ))
                              , I = A.parseMasterPlaylistMedia(h, f, "AUDIO", T, null === (n = s.config.m3u8PostProcessor) || void 0 === n ? void 0 : n.mediaReplace)
                              , P = A.parseMasterPlaylistMedia(h, f, "SUBTITLES", S, null === (a = s.config.m3u8PostProcessor) || void 0 === a ? void 0 : a.mediaReplace)
                              , b = A.parseMasterPlaylistMedia(h, f, "CLOSED-CAPTIONS", [], null === (o = s.config.m3u8PostProcessor) || void 0 === o ? void 0 : o.mediaReplace);
                            I.length && (I.some((function(e) {
                                return !e.url
                            }
                            )) || !g[0].audioCodec || g[0].attrs.AUDIO || (u.b.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"),
                            I.unshift({
                                type: "main",
                                name: "main",
                                default: !1,
                                autoselect: !1,
                                forced: !1,
                                id: -1,
                                attrs: new m({}),
                                bitrate: 0,
                                url: "",
                                tags: []
                            }))),
                            s.trigger(c.a.MANIFEST_LOADED, {
                                levels: g,
                                audioTracks: I,
                                subtitles: P,
                                captions: b,
                                url: f,
                                stats: t,
                                networkDetails: i,
                                sessionData: v
                            })
                        } else
                            this.handleManifestParsingError(e, r, "no level found in manifest", i)
                    }
                    ,
                    t.handleTrackOrLevelPlaylist = function(e, t, r, i) {
                        var n = this.hls
                          , a = n.config.externalRedundantUrls
                          , s = r.id
                          , l = r.level
                          , u = r.type
                          , d = U(e, r)
                          , f = Object(o.a)(s) ? s : 0
                          , p = Object(o.a)(l) ? l : f
                          , g = function(e) {
                            switch (e.type) {
                            case B.a.AUDIO_TRACK:
                                return B.b.AUDIO;
                            case B.a.SUBTITLE_TRACK:
                                return B.b.SUBTITLE;
                            default:
                                return B.b.MAIN
                            }
                        }(r)
                          , v = A.parseLevelPlaylist(e.data, d, p, g, f, n.config.m3u8PostProcessor)
                          , y = [];
                        if (null == a || a.forEach((function(t) {
                            t !== d && y.push(A.parseLevelPlaylist(e.data, t, p, g, f, n.config.m3u8PostProcessor))
                        }
                        )),
                        v.fragments.length) {
                            if (u === B.a.MANIFEST) {
                                var T = {
                                    tags: [],
                                    attrs: new m({}),
                                    bitrate: 0,
                                    details: v,
                                    name: "",
                                    url: d
                                }
                                  , S = y.map((function(e) {
                                    return {
                                        tags: [],
                                        attrs: new m({}),
                                        bitrate: 0,
                                        details: e,
                                        name: "",
                                        url: e.url
                                    }
                                }
                                ));
                                n.trigger(c.a.MANIFEST_LOADED, {
                                    levels: [T].concat(S),
                                    audioTracks: [],
                                    url: d,
                                    stats: t,
                                    networkDetails: i,
                                    sessionData: null
                                })
                            }
                            if (t.parsing && (t.parsing.end = performance.now()),
                            v.needSidxRanges) {
                                var I, P = null === (I = v.fragments[0].initSegment) || void 0 === I ? void 0 : I.url;
                                this.load({
                                    url: P,
                                    isSidxRequest: !0,
                                    type: u,
                                    level: l,
                                    levelDetails: v,
                                    id: s,
                                    groupId: null,
                                    rangeStart: 0,
                                    rangeEnd: 2048,
                                    responseType: "arraybuffer",
                                    deliveryDirectives: null
                                })
                            } else
                                r.levelDetails = v,
                                this.handlePlaylistLoaded(e, t, r, i)
                        } else
                            n.trigger(c.a.ERROR, {
                                type: h.b.NETWORK_ERROR,
                                details: h.a.LEVEL_EMPTY_ERROR,
                                fatal: !1,
                                url: d,
                                reason: "no fragments found in level",
                                level: "number" == typeof r.level ? r.level : void 0
                            })
                    }
                    ,
                    t.handleSidxRequest = function(e, t) {
                        var r = Object(d.h)(new Uint8Array(e.data));
                        if (r) {
                            var i = r.references
                              , n = t.levelDetails;
                            i.forEach((function(e, t) {
                                var i = e.info
                                  , a = n.fragments[t];
                                0 === a.byteRange.length && a.setByteRange(String(1 + i.end - i.start) + "@" + String(i.start)),
                                a.initSegment && a.initSegment.setByteRange(String(r.moovEndOffset) + "@0")
                            }
                            ))
                        }
                    }
                    ,
                    t.handleManifestParsingError = function(e, t, r, i) {
                        this.hls.trigger(c.a.ERROR, {
                            type: h.b.NETWORK_ERROR,
                            details: h.a.MANIFEST_PARSING_ERROR,
                            fatal: t.type === B.a.MANIFEST,
                            url: e.url,
                            reason: r,
                            response: e,
                            context: t,
                            networkDetails: i
                        })
                    }
                    ,
                    t.handleNetworkError = function(e, t, r, i) {
                        void 0 === r && (r = !1),
                        u.b.warn("[playlist-loader]: A network " + (r ? "timeout" : "error") + " occurred while loading " + e.type + " level: " + e.level + " id: " + e.id + ' group-id: "' + e.groupId + '"');
                        var n = h.a.UNKNOWN
                          , a = !1
                          , o = this.getInternalLoader(e);
                        switch (e.type) {
                        case B.a.MANIFEST:
                            n = r ? h.a.MANIFEST_LOAD_TIMEOUT : h.a.MANIFEST_LOAD_ERROR,
                            a = !0;
                            break;
                        case B.a.LEVEL:
                            n = r ? h.a.LEVEL_LOAD_TIMEOUT : h.a.LEVEL_LOAD_ERROR,
                            a = !1;
                            break;
                        case B.a.AUDIO_TRACK:
                            n = r ? h.a.AUDIO_TRACK_LOAD_TIMEOUT : h.a.AUDIO_TRACK_LOAD_ERROR,
                            a = !1;
                            break;
                        case B.a.SUBTITLE_TRACK:
                            n = r ? h.a.SUBTITLE_TRACK_LOAD_TIMEOUT : h.a.SUBTITLE_LOAD_ERROR,
                            a = !1
                        }
                        o && this.resetInternalLoader(e.type);
                        var s = {
                            type: h.b.NETWORK_ERROR,
                            details: n,
                            fatal: a,
                            url: e.url,
                            loader: o,
                            context: e,
                            networkDetails: t
                        };
                        i && (s.response = i),
                        this.hls.trigger(c.a.ERROR, s)
                    }
                    ,
                    t.handlePlaylistLoaded = function(e, t, r, i) {
                        var n = r.type
                          , a = r.level
                          , o = r.id
                          , s = r.groupId
                          , l = r.loader
                          , h = r.levelDetails
                          , u = r.deliveryDirectives;
                        if (null != h && h.targetduration) {
                            if (l)
                                switch (h.live && (l.getCacheAge && (h.ageHeader = l.getCacheAge() || 0),
                                l.getCacheAge && !isNaN(h.ageHeader) || (h.ageHeader = 0)),
                                n) {
                                case B.a.MANIFEST:
                                case B.a.LEVEL:
                                    this.hls.trigger(c.a.LEVEL_LOADED, {
                                        details: h,
                                        level: a || 0,
                                        id: o || 0,
                                        stats: t,
                                        networkDetails: i,
                                        deliveryDirectives: u
                                    });
                                    break;
                                case B.a.AUDIO_TRACK:
                                    this.hls.trigger(c.a.AUDIO_TRACK_LOADED, {
                                        details: h,
                                        id: o || 0,
                                        groupId: s || "",
                                        stats: t,
                                        networkDetails: i,
                                        deliveryDirectives: u
                                    });
                                    break;
                                case B.a.SUBTITLE_TRACK:
                                    this.hls.trigger(c.a.SUBTITLE_TRACK_LOADED, {
                                        details: h,
                                        id: o || 0,
                                        groupId: s || "",
                                        stats: t,
                                        networkDetails: i,
                                        deliveryDirectives: u
                                    })
                                }
                        } else
                            this.handleManifestParsingError(e, r, "invalid target duration", i)
                    }
                    ,
                    e
                }()
                  , G = function() {
                    function e(e) {
                        this.hls = void 0,
                        this.loaders = {},
                        this.decryptkey = null,
                        this.decrypturl = null,
                        this.hls = e,
                        this._registerListeners()
                    }
                    var t = e.prototype;
                    return t._registerListeners = function() {
                        this.hls.on(c.a.KEY_LOADING, this.onKeyLoading, this)
                    }
                    ,
                    t._unregisterListeners = function() {
                        this.hls.off(c.a.KEY_LOADING, this.onKeyLoading)
                    }
                    ,
                    t.destroy = function() {
                        for (var e in this._unregisterListeners(),
                        this.loaders) {
                            var t = this.loaders[e];
                            t && t.destroy()
                        }
                        this.loaders = {}
                    }
                    ,
                    t.onKeyLoading = function(e, t) {
                        var r = t.frag
                          , i = r.type
                          , n = this.loaders[i];
                        if (r.decryptdata) {
                            var a = r.decryptdata.uri;
                            if (a !== this.decrypturl || null === this.decryptkey) {
                                var o = this.hls.config;
                                if (n && (u.b.warn("abort previous key loader for type:" + i),
                                n.abort()),
                                !a)
                                    return void u.b.warn("key uri is falsy");
                                var s = o.loader
                                  , l = r.loader = this.loaders[i] = new s(o);
                                this.decrypturl = a,
                                this.decryptkey = null;
                                var h = {
                                    url: a,
                                    frag: r,
                                    responseType: "arraybuffer"
                                }
                                  , d = {
                                    timeout: o.fragLoadingTimeOut,
                                    maxRetry: 0,
                                    retryDelay: o.fragLoadingRetryDelay,
                                    maxRetryDelay: o.fragLoadingMaxRetryTimeout,
                                    highWaterMark: 0
                                }
                                  , f = {
                                    onSuccess: this.loadsuccess.bind(this),
                                    onError: this.loaderror.bind(this),
                                    onTimeout: this.loadtimeout.bind(this)
                                };
                                l.load(h, d, f)
                            } else
                                this.decryptkey && (r.decryptdata.key = this.decryptkey,
                                this.hls.trigger(c.a.KEY_LOADED, {
                                    frag: r
                                }))
                        } else
                            u.b.warn("Missing decryption data on fragment in onKeyLoading")
                    }
                    ,
                    t.loadsuccess = function(e, t, r) {
                        var i = r.frag;
                        i.decryptdata ? (this.decryptkey = i.decryptdata.key = new Uint8Array(e.data),
                        i.loader = null,
                        delete this.loaders[i.type],
                        this.hls.trigger(c.a.KEY_LOADED, {
                            frag: i
                        })) : u.b.error("after key load, decryptdata unset")
                    }
                    ,
                    t.loaderror = function(e, t) {
                        var r = t.frag
                          , i = r.loader;
                        i && i.abort(),
                        delete this.loaders[r.type],
                        this.hls.trigger(c.a.ERROR, {
                            type: h.b.NETWORK_ERROR,
                            details: h.a.KEY_LOAD_ERROR,
                            fatal: !1,
                            frag: r,
                            response: e
                        })
                    }
                    ,
                    t.loadtimeout = function(e, t) {
                        var r = t.frag
                          , i = r.loader;
                        i && i.abort(),
                        delete this.loaders[r.type],
                        this.hls.trigger(c.a.ERROR, {
                            type: h.b.NETWORK_ERROR,
                            details: h.a.KEY_LOAD_TIMEOUT,
                            fatal: !1,
                            frag: r
                        })
                    }
                    ,
                    e
                }();
                function H(e, t) {
                    var r;
                    try {
                        r = new Event("addtrack")
                    } catch (e) {
                        (r = document.createEvent("Event")).initEvent("addtrack", !1, !1)
                    }
                    r.track = e,
                    t.dispatchEvent(r)
                }
                function q(e, t, r) {
                    var i = e.mode;
                    if ("disabled" === i && (e.mode = "hidden"),
                    e.cues && e.cues.length > 0)
                        for (var n = function(e, t, r) {
                            var i = []
                              , n = function(e, t) {
                                if (t < e[0].startTime)
                                    return 0;
                                var r = e.length - 1;
                                if (t > e[r].endTime)
                                    return -1;
                                for (var i = 0, n = r; i <= n; ) {
                                    var a = Math.floor((n + i) / 2);
                                    if (t < e[a].startTime)
                                        n = a - 1;
                                    else {
                                        if (!(t > e[a].startTime && i < r))
                                            return a;
                                        i = a + 1
                                    }
                                }
                                return e[i].startTime - t < t - e[n].startTime ? i : n
                            }(e, t);
                            if (n > -1)
                                for (var a = n, o = e.length; a < o; a++) {
                                    var s = e[a];
                                    if (s.startTime >= t && s.endTime <= r)
                                        i.push(s);
                                    else if (s.startTime > r)
                                        return i
                                }
                            return i
                        }(e.cues, t, r), a = 0; a < n.length; a++)
                            e.removeCue(n[a]);
                    "disabled" === i && (e.mode = i)
                }
                var z = r(11)
                  , K = function() {
                    function e(e) {
                        this.hls = void 0,
                        this.id3Track = null,
                        this.media = null,
                        this.hls = e,
                        this._registerListeners()
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._unregisterListeners()
                    }
                    ,
                    t._registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        e.on(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.on(c.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
                        e.on(c.a.BUFFER_FLUSHING, this.onBufferFlushing, this)
                    }
                    ,
                    t._unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        e.off(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.off(c.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
                        e.off(c.a.BUFFER_FLUSHING, this.onBufferFlushing, this)
                    }
                    ,
                    t.onMediaAttached = function(e, t) {
                        this.media = t.media
                    }
                    ,
                    t.onMediaDetaching = function() {
                        this.id3Track && (function(e) {
                            var t = e.mode;
                            if ("disabled" === t && (e.mode = "hidden"),
                            e.cues)
                                for (var r = e.cues.length; r--; )
                                    e.removeCue(e.cues[r]);
                            "disabled" === t && (e.mode = t)
                        }(this.id3Track),
                        this.id3Track = null,
                        this.media = null)
                    }
                    ,
                    t.getID3Track = function(e) {
                        if (this.media) {
                            for (var t = 0; t < e.length; t++) {
                                var r = e[t];
                                if ("metadata" === r.kind && "id3" === r.label)
                                    return H(r, this.media),
                                    r
                            }
                            return this.media.addTextTrack("metadata", "id3")
                        }
                    }
                    ,
                    t.onFragParsingMetadata = function(e, t) {
                        if (this.media) {
                            var r = t.frag
                              , i = t.samples;
                            this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks),
                            this.id3Track.mode = "hidden");
                            for (var n = self.WebKitDataCue || self.VTTCue || self.TextTrackCue, a = 0; a < i.length; a++) {
                                var o = z.c(i[a].data);
                                if (o) {
                                    var s = i[a].pts
                                      , l = a < i.length - 1 ? i[a + 1].pts : r.end;
                                    l - s <= 0 && (l = s + .25);
                                    for (var c = 0; c < o.length; c++) {
                                        var h = o[c];
                                        if (!z.e(h)) {
                                            var u = new n(s,l,"");
                                            u.value = h,
                                            this.id3Track.addCue(u)
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ,
                    t.onBufferFlushing = function(e, t) {
                        var r = t.startOffset
                          , i = t.endOffset
                          , n = t.type;
                        if (!n || "audio" === n) {
                            var a = this.id3Track;
                            a && q(a, r, i)
                        }
                    }
                    ,
                    e
                }()
                  , V = function() {
                    function e(e) {
                        var t = this;
                        this.hls = void 0,
                        this.config = void 0,
                        this.media = null,
                        this.levelDetails = null,
                        this.currentTime = 0,
                        this.stallCount = 0,
                        this._latency = null,
                        this.timeupdateHandler = function() {
                            return t.timeupdate()
                        }
                        ,
                        this.hls = e,
                        this.config = e.config,
                        this.registerListeners()
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this.unregisterListeners(),
                        this.onMediaDetaching(),
                        this.levelDetails = null,
                        this.hls = this.timeupdateHandler = null
                    }
                    ,
                    t.registerListeners = function() {
                        this.hls.on(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        this.hls.on(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        this.hls.on(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        this.hls.on(c.a.LEVEL_UPDATED, this.onLevelUpdated, this),
                        this.hls.on(c.a.ERROR, this.onError, this)
                    }
                    ,
                    t.unregisterListeners = function() {
                        this.hls.off(c.a.MEDIA_ATTACHED, this.onMediaAttached),
                        this.hls.off(c.a.MEDIA_DETACHING, this.onMediaDetaching),
                        this.hls.off(c.a.MANIFEST_LOADING, this.onManifestLoading),
                        this.hls.off(c.a.LEVEL_UPDATED, this.onLevelUpdated),
                        this.hls.off(c.a.ERROR, this.onError)
                    }
                    ,
                    t.onMediaAttached = function(e, t) {
                        this.media = t.media,
                        this.media.addEventListener("timeupdate", this.timeupdateHandler)
                    }
                    ,
                    t.onMediaDetaching = function() {
                        this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler),
                        this.media = null)
                    }
                    ,
                    t.onManifestLoading = function() {
                        this.levelDetails = null,
                        this._latency = null,
                        this.stallCount = 0
                    }
                    ,
                    t.onLevelUpdated = function(e, t) {
                        var r = t.details;
                        this.levelDetails = r,
                        r.advanced && this.timeupdate(),
                        !r.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
                    }
                    ,
                    t.onError = function(e, t) {
                        t.details === h.a.BUFFER_STALLED_ERROR && (this.stallCount++,
                        u.b.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
                    }
                    ,
                    t.timeupdate = function() {
                        var e = this.media
                          , t = this.levelDetails;
                        if (e && t) {
                            this.currentTime = e.currentTime;
                            var r = this.computeLatency();
                            if (null !== r) {
                                this._latency = r;
                                var i = this.config
                                  , n = i.lowLatencyMode
                                  , a = i.maxLiveSyncPlaybackRate;
                                if (n && 1 !== a) {
                                    var o = this.targetLatency;
                                    if (null !== o) {
                                        var s = r - o
                                          , l = s < Math.min(this.maxLatency, o + t.targetduration);
                                        if (t.live && l && s > .05 && this.forwardBufferLength > 1) {
                                            var c = Math.min(2, Math.max(1, a))
                                              , h = Math.round(2 / (1 + Math.exp(-.75 * s - this.edgeStalled)) * 20) / 20;
                                            e.playbackRate = Math.min(c, Math.max(1, h))
                                        } else
                                            1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1)
                                    }
                                }
                            }
                        }
                    }
                    ,
                    t.estimateLiveEdge = function() {
                        var e = this.levelDetails;
                        return null === e ? null : e.edge + e.age
                    }
                    ,
                    t.computeLatency = function() {
                        var e = this.estimateLiveEdge();
                        return null === e ? null : e - this.currentTime
                    }
                    ,
                    n()(e, [{
                        key: "latency",
                        get: function() {
                            return this._latency || 0
                        }
                    }, {
                        key: "maxLatency",
                        get: function() {
                            var e = this.config
                              , t = this.levelDetails;
                            return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
                        }
                    }, {
                        key: "targetLatency",
                        get: function() {
                            var e = this.levelDetails;
                            if (null === e)
                                return null;
                            var t = e.holdBack
                              , r = e.partHoldBack
                              , i = e.targetduration
                              , n = this.config
                              , a = n.liveSyncDuration
                              , o = n.liveSyncDurationCount
                              , s = n.lowLatencyMode
                              , l = this.hls.userConfig
                              , c = s && r || t;
                            (l.liveSyncDuration || l.liveSyncDurationCount || 0 === c) && (c = void 0 !== a ? a : o * i);
                            var h = i;
                            return c + Math.min(1 * this.stallCount, h)
                        }
                    }, {
                        key: "liveSyncPosition",
                        get: function() {
                            var e = this.estimateLiveEdge()
                              , t = this.targetLatency
                              , r = this.levelDetails;
                            if (null === e || null === t || null === r)
                                return null;
                            var i = r.edge
                              , n = e - t - this.edgeStalled
                              , a = i - r.totalduration
                              , o = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
                            return Math.min(Math.max(a, n), o)
                        }
                    }, {
                        key: "drift",
                        get: function() {
                            var e = this.levelDetails;
                            return null === e ? 1 : e.drift
                        }
                    }, {
                        key: "edgeStalled",
                        get: function() {
                            var e = this.levelDetails;
                            if (null === e)
                                return 0;
                            var t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
                            return Math.max(e.age - t, 0)
                        }
                    }, {
                        key: "forwardBufferLength",
                        get: function() {
                            var e = this.media
                              , t = this.levelDetails;
                            if (!e || !t)
                                return 0;
                            var r = e.buffered.length;
                            return r ? e.buffered.end(r - 1) : t.edge - this.currentTime
                        }
                    }])
                }()
                  , j = r(10)
                  , W = r.n(j)
                  , Y = r(8)
                  , Q = r.n(Y)
                  , X = function(e) {
                    return e.No = "",
                    e.Yes = "YES",
                    e.v2 = "v2",
                    e
                }({})
                  , Z = function() {
                    function e(e, t, r) {
                        this.msn = void 0,
                        this.part = void 0,
                        this.skip = void 0,
                        this.msn = e,
                        this.part = t,
                        this.skip = r
                    }
                    return e.prototype.addDirectives = function(e) {
                        var t = new self.URL(e);
                        return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()),
                        void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()),
                        this.skip && t.searchParams.set("_HLS_skip", this.skip),
                        t.toString()
                    }
                    ,
                    e
                }()
                  , J = n()((function(e, t) {
                    void 0 === t && (t = []),
                    this.attrs = void 0,
                    this.audioCodec = void 0,
                    this.bitrate = void 0,
                    this.codecSet = void 0,
                    this.height = void 0,
                    this.id = void 0,
                    this.name = void 0,
                    this.videoCodec = void 0,
                    this.width = void 0,
                    this.unknownCodecs = void 0,
                    this.tags = void 0,
                    this.audioGroupIds = void 0,
                    this.details = void 0,
                    this.fragmentError = 0,
                    this.loadError = 0,
                    this.loaded = void 0,
                    this.realBitrate = 0,
                    this.textGroupIds = void 0,
                    this.url = void 0,
                    this._urlId = 0;
                    var r = [e.url].concat(t);
                    this.url = r.filter((function(e, t) {
                        return r.indexOf(e) === t
                    }
                    )),
                    this.attrs = e.attrs,
                    this.bitrate = e.bitrate,
                    e.details && (this.details = e.details),
                    this.id = e.id || 0,
                    this.name = e.name,
                    this.width = e.width || 0,
                    this.height = e.height || 0,
                    this.audioCodec = e.audioCodec,
                    this.videoCodec = e.videoCodec,
                    this.unknownCodecs = e.unknownCodecs,
                    this.tags = e.tags || [],
                    this.codecSet = [e.videoCodec, e.audioCodec].filter((function(e) {
                        return e
                    }
                    )).join(",").replace(/\.[^.,]+/g, "")
                }
                ), [{
                    key: "maxBitrate",
                    get: function() {
                        return Math.max(this.realBitrate, this.bitrate)
                    }
                }, {
                    key: "uri",
                    get: function() {
                        return this.url[this._urlId] || ""
                    }
                }, {
                    key: "urlId",
                    get: function() {
                        return this._urlId
                    },
                    set: function(e) {
                        var t = e % this.url.length;
                        this._urlId !== t && (this.details = void 0,
                        this._urlId = t)
                    }
                }]);
                function $(e, t, r) {
                    switch (t) {
                    case "audio":
                        e.audioGroupIds || (e.audioGroupIds = []),
                        e.audioGroupIds.push(r);
                        break;
                    case "text":
                        e.textGroupIds || (e.textGroupIds = []),
                        e.textGroupIds.push(r)
                    }
                }
                function ee(e) {
                    var t = {};
                    e.forEach((function(e) {
                        var r = e.groupId || "";
                        e.id = t[r] = t[r] || 0,
                        t[r]++
                    }
                    ))
                }
                function te(e, t) {
                    var r = t.startPTS;
                    if (Object(o.a)(r)) {
                        var i, n = 0;
                        t.sn > e.sn ? (n = r - e.start,
                        i = e) : (n = e.start - r,
                        i = t),
                        i.duration !== n && (i.duration = n)
                    } else
                        t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0)
                }
                function re(e, t, r, i, n, a) {
                    i - r <= 0 && (u.b.warn("Fragment should have a positive duration", t),
                    i = r + t.duration,
                    a = n + t.duration);
                    var s = r
                      , l = i
                      , c = t.startPTS
                      , h = t.endPTS;
                    if (Object(o.a)(c)) {
                        var d = Math.abs(c - r);
                        Object(o.a)(t.deltaPTS) ? t.deltaPTS = Math.max(d, t.deltaPTS) : t.deltaPTS = d,
                        s = Math.max(r, c),
                        r = Math.min(r, c),
                        n = Math.min(n, t.startDTS),
                        l = Math.min(i, h),
                        i = Math.max(i, h),
                        a = Math.max(a, t.endDTS)
                    }
                    t.duration = i - r;
                    var f = r - t.start;
                    t.appendedPTS = i,
                    t.start = t.startPTS = r,
                    t.maxStartPTS = s,
                    t.startDTS = n,
                    t.endPTS = i,
                    t.minEndPTS = l,
                    t.endDTS = a;
                    var p, g = t.sn;
                    if (!e || g < e.startSN || g > e.endSN)
                        return 0;
                    var v = g - e.startSN
                      , y = e.fragments;
                    for (y[v] = t,
                    p = v; p > 0; p--)
                        te(y[p], y[p - 1]);
                    for (p = v; p < y.length - 1; p++)
                        te(y[p], y[p + 1]);
                    return e.fragmentHint && te(y[y.length - 1], e.fragmentHint),
                    e.PTSKnown = e.alignedSliding = !0,
                    f
                }
                function ie(e, t) {
                    for (var r = null, i = e.fragments, n = i.length - 1; n >= 0; n--) {
                        var a = i[n].initSegment;
                        if (a) {
                            r = a;
                            break
                        }
                    }
                    e.fragmentHint && delete e.fragmentHint.endPTS;
                    var s, l = 0;
                    if (function(e, t, r) {
                        for (var i = t.skippedSegments, n = Math.max(e.startSN, t.startSN) - t.startSN, a = (e.fragmentHint ? 1 : 0) + (i ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN, o = t.startSN - e.startSN, s = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, c = n; c <= a; c++) {
                            var h = l[o + c]
                              , u = s[c];
                            i && !u && c < i && (u = t.fragments[c] = h),
                            h && u && r(h, u)
                        }
                    }(e, t, (function(e, i) {
                        e.relurl && (l = e.cc - i.cc),
                        Object(o.a)(e.startPTS) && Object(o.a)(e.endPTS) && (i.start = i.startPTS = e.startPTS,
                        i.startDTS = e.startDTS,
                        i.appendedPTS = e.appendedPTS,
                        i.maxStartPTS = e.maxStartPTS,
                        i.endPTS = e.endPTS,
                        i.endDTS = e.endDTS,
                        i.minEndPTS = e.minEndPTS,
                        i.duration = e.endPTS - e.startPTS,
                        i.duration && (s = i),
                        t.PTSKnown = t.alignedSliding = !0),
                        i.elementaryStreams = e.elementaryStreams,
                        i.loader = e.loader,
                        i.stats = e.stats,
                        i.urlId = e.urlId,
                        e.initSegment && (r = e.initSegment)
                    }
                    )),
                    r && t.fragments.forEach((function(e) {
                        var t;
                        e.initSegment && e.initSegment.relurl !== (null === (t = r) || void 0 === t ? void 0 : t.relurl) || (e.initSegment = r)
                    }
                    )),
                    t.skippedSegments && (t.deltaUpdateFailed = t.fragments.some((function(e) {
                        return !e
                    }
                    )),
                    t.deltaUpdateFailed)) {
                        u.b.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                        for (var c = t.skippedSegments; c--; )
                            t.fragments.shift();
                        t.startSN = t.fragments[0].sn,
                        t.startCC = t.fragments[0].cc
                    }
                    var h = t.fragments;
                    if (l) {
                        u.b.warn("discontinuity sliding from playlist, take drift into account");
                        for (var d = 0; d < h.length; d++)
                            h[d].cc += l
                    }
                    t.skippedSegments && (t.startCC = t.fragments[0].cc),
                    function(e, t, r) {
                        if (e && t)
                            for (var i = 0, n = 0, a = e.length; n <= a; n++) {
                                var o = e[n]
                                  , s = t[n + i];
                                o && s && o.index === s.index && o.fragment.sn === s.fragment.sn ? r(o, s) : i--
                            }
                    }(e.partList, t.partList, (function(e, t) {
                        t.elementaryStreams = e.elementaryStreams,
                        t.stats = e.stats
                    }
                    )),
                    s ? re(t, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS) : ne(e, t),
                    h.length && (t.totalduration = t.edge - h[0].start),
                    t.driftStartTime = e.driftStartTime,
                    t.driftStart = e.driftStart;
                    var f = t.advancedDateTime;
                    if (t.advanced && f) {
                        var p = t.edge;
                        t.driftStart || (t.driftStartTime = f,
                        t.driftStart = p),
                        t.driftEndTime = f,
                        t.driftEnd = p
                    } else
                        t.driftEndTime = e.driftEndTime,
                        t.driftEnd = e.driftEnd,
                        t.advancedDateTime = e.advancedDateTime
                }
                function ne(e, t) {
                    var r = t.startSN + t.skippedSegments - e.startSN
                      , i = e.fragments;
                    r < 0 || r >= i.length || function(e, t) {
                        if (t) {
                            for (var r = e.fragments, i = e.skippedSegments; i < r.length; i++)
                                r[i].start += t;
                            e.fragmentHint && (e.fragmentHint.start += t)
                        }
                    }(t, i[r].start)
                }
                var ae = function() {
                    function e(e, t) {
                        this.hls = void 0,
                        this.timer = -1,
                        this.canLoad = !1,
                        this.retryCount = 0,
                        this.log = void 0,
                        this.warn = void 0,
                        this.log = u.b.log.bind(u.b, t + ":"),
                        this.warn = u.b.warn.bind(u.b, t + ":"),
                        this.hls = e
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this.clearTimer(),
                        this.hls = this.log = this.warn = null
                    }
                    ,
                    t.onError = function(e, t) {
                        t.fatal && t.type === h.b.NETWORK_ERROR && this.clearTimer()
                    }
                    ,
                    t.clearTimer = function() {
                        clearTimeout(this.timer),
                        this.timer = -1
                    }
                    ,
                    t.startLoad = function() {
                        this.canLoad = !0,
                        this.retryCount = 0,
                        this.loadPlaylist()
                    }
                    ,
                    t.stopLoad = function() {
                        this.canLoad = !1,
                        this.clearTimer()
                    }
                    ,
                    t.switchParams = function(e, t) {
                        var r = null == t ? void 0 : t.renditionReports;
                        if (r)
                            for (var i = 0; i < r.length; i++) {
                                var n = r[i]
                                  , a = "" + n.URI;
                                if (a === e.substr(-a.length)) {
                                    var s = parseInt(n["LAST-MSN"])
                                      , l = parseInt(n["LAST-PART"]);
                                    if (t && this.hls.config.lowLatencyMode) {
                                        var c = Math.min(t.age - t.partTarget, t.targetduration);
                                        void 0 !== l && c > t.partTarget && (l += 1)
                                    }
                                    if (Object(o.a)(s))
                                        return new Z(s,Object(o.a)(l) ? l : void 0,X.No)
                                }
                            }
                    }
                    ,
                    t.loadPlaylist = function(e) {}
                    ,
                    t.shouldLoadTrack = function(e) {
                        return this.canLoad && e && !!e.url && (!e.details || e.details.live)
                    }
                    ,
                    t.playlistLoaded = function(e, t, r) {
                        var i = this
                          , n = t.details
                          , a = t.stats
                          , o = a.loading.end ? Math.max(0, self.performance.now() - a.loading.end) : 0;
                        if (n.advancedDateTime = Date.now() - o,
                        n.live || null != r && r.live) {
                            if (n.reloaded(r),
                            r && this.log("live playlist " + e + " " + (n.advanced ? "REFRESHED " + n.lastPartSn + "-" + n.lastPartIndex : "MISSED")),
                            r && n.fragments.length > 0 && ie(r, n),
                            !this.canLoad || !n.live)
                                return;
                            var s, l = void 0, c = void 0;
                            if (n.canBlockReload && n.endSN && n.advanced) {
                                var h = this.hls.config.lowLatencyMode
                                  , u = n.lastPartSn
                                  , d = n.endSN
                                  , f = n.lastPartIndex
                                  , p = u === d;
                                -1 !== f ? (l = p ? d + 1 : u,
                                c = p ? h ? 0 : f : f + 1) : l = d + 1;
                                var g = n.age
                                  , v = g + n.ageHeader
                                  , y = Math.min(v - n.partTarget, 1.5 * n.targetduration);
                                if (y > 0) {
                                    if (r && y > r.tuneInGoal)
                                        this.warn("CDN Tune-in goal increased from: " + r.tuneInGoal + " to: " + y + " with playlist age: " + n.age),
                                        y = 0;
                                    else {
                                        var m = Math.floor(y / n.targetduration);
                                        l += m,
                                        void 0 !== c && (c += Math.round(y % n.targetduration / n.partTarget)),
                                        this.log("CDN Tune-in age: " + n.ageHeader + "s last advanced " + g.toFixed(2) + "s goal: " + y + " skip sn " + m + " to part " + c)
                                    }
                                    n.tuneInGoal = y
                                }
                                if (s = this.getDeliveryDirectives(n, t.deliveryDirectives, l, c),
                                h || !p)
                                    return void this.loadPlaylist(s)
                            } else
                                s = this.getDeliveryDirectives(n, t.deliveryDirectives, l, c);
                            var T = function(e, t) {
                                var r, i = 1e3 * e.levelTargetDuration, n = i / 2, a = e.age, o = a > 0 && a < 3 * i, s = t.loading.end - t.loading.start, l = e.availabilityDelay;
                                if (!1 === e.updated)
                                    if (o) {
                                        var c = 333 * e.misses;
                                        r = Math.max(Math.min(n, 2 * s), c),
                                        e.availabilityDelay = (e.availabilityDelay || 0) + r
                                    } else
                                        r = n;
                                else
                                    o ? (l = Math.min(l || i / 2, a),
                                    e.availabilityDelay = l,
                                    r = l + i - a) : r = i - s;
                                return Math.round(r)
                            }(n, a);
                            void 0 !== l && n.canBlockReload && (T -= n.partTarget || 1),
                            this.log("reload live playlist " + e + " in " + Math.round(T) + " ms"),
                            this.timer = self.setTimeout((function() {
                                return i.loadPlaylist(s)
                            }
                            ), T)
                        } else
                            this.clearTimer()
                    }
                    ,
                    t.getDeliveryDirectives = function(e, t, r, i) {
                        var n = function(e, t) {
                            var r = e.canSkipUntil
                              , i = e.canSkipDateRanges
                              , n = e.endSN;
                            return r && (void 0 !== t ? t - n : 0) < r ? i ? X.v2 : X.Yes : X.No
                        }(e, r);
                        return null != t && t.skip && e.deltaUpdateFailed && (r = t.msn,
                        i = t.part,
                        n = X.No),
                        new Z(r,i,n)
                    }
                    ,
                    t.retryLoadingOrFail = function(e) {
                        var t, r = this, i = this.hls.config, n = this.retryCount < i.levelLoadingMaxRetry;
                        if (n)
                            if (this.retryCount++,
                            e.details.indexOf("LoadTimeOut") > -1 && null !== (t = e.context) && void 0 !== t && t.deliveryDirectives)
                                this.warn("retry playlist loading #" + this.retryCount + ' after "' + e.details + '"'),
                                this.loadPlaylist();
                            else {
                                var a = Math.min(Math.pow(2, this.retryCount) * i.levelLoadingRetryDelay, i.levelLoadingMaxRetryTimeout);
                                this.timer = self.setTimeout((function() {
                                    return r.loadPlaylist()
                                }
                                ), a),
                                this.warn("retry playlist loading #" + this.retryCount + " in " + a + ' ms after "' + e.details + '"')
                            }
                        else
                            this.warn('cannot recover from error "' + e.details + '"'),
                            this.clearTimer(),
                            e.fatal = !0;
                        return n
                    }
                    ,
                    e
                }()
                  , oe = /chrome|firefox/.test(navigator.userAgent.toLowerCase())
                  , se = function(e) {
                    function t(t) {
                        var r;
                        return (r = e.call(this, t, "[level-controller]") || this)._levels = [],
                        r._firstLevel = -1,
                        r._startLevel = void 0,
                        r.currentLevelIndex = -1,
                        r.manualLevelIndex = -1,
                        r.m3u8StringMap = {},
                        r.onParsedComplete = void 0,
                        r._registerListeners(),
                        r
                    }
                    Q()(t, e);
                    var r = t.prototype;
                    return r._registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MANIFEST_LOADED, this.onManifestLoaded, this),
                        e.on(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.on(c.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
                        e.on(c.a.FRAG_LOADED, this.onFragLoaded, this),
                        e.on(c.a.ERROR, this.onError, this)
                    }
                    ,
                    r._unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.MANIFEST_LOADED, this.onManifestLoaded, this),
                        e.off(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.off(c.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
                        e.off(c.a.FRAG_LOADED, this.onFragLoaded, this),
                        e.off(c.a.ERROR, this.onError, this)
                    }
                    ,
                    r.setLevel = function(e, t) {
                        var r, i, n;
                        void 0 === t && (t = {
                            bitrate: 0,
                            name: "",
                            m3u8String: ""
                        });
                        var a = t
                          , o = a.bitrate
                          , s = a.name
                          , l = a.m3u8String
                          , c = null === (r = this.hls.audioTracks) || void 0 === r || null === (i = r[-1 === this.hls.audioTrack ? 0 : this.hls.audioTrack]) || void 0 === i ? void 0 : i.groupId
                          , h = ("\n    #EXTM3U\n    #EXT-X-STREAM-INF:PROGRAM-ID=1" + (o ? ",BANDWIDTH=" : "") + (s ? ",NAME=" + s : "") + (c ? ",AUDIO=" + c : "") + ";\n    " + e + "\n    ").trim()
                          , u = A.parseMasterPlaylist(h, e).levels[0]
                          , d = new J(u,this.hls.config.externalRedundantUrls);
                        null === (n = this.levels) || void 0 === n || n.push(d);
                        var f = this.level + 1;
                        this.m3u8StringMap[f] = l,
                        this.hls.nextLevel = f
                    }
                    ,
                    r.destroy = function() {
                        this._unregisterListeners(),
                        this.manualLevelIndex = -1,
                        this._levels.length = 0,
                        e.prototype.destroy.call(this)
                    }
                    ,
                    r.startLoad = function() {
                        this._levels.forEach((function(e) {
                            e.loadError = 0
                        }
                        )),
                        e.prototype.startLoad.call(this)
                    }
                    ,
                    r.onManifestLoaded = function(e, t) {
                        var r, i, n = [], a = [], o = [], s = {}, l = !1, u = !1, d = !1;
                        if (t.levels.forEach((function(e) {
                            var t = e.attrs;
                            l = l || !(!e.width || !e.height),
                            u = u || !!e.videoCodec,
                            d = d || !!e.audioCodec,
                            oe && e.audioCodec && -1 !== e.audioCodec.indexOf("mp4a.40.34") && (e.audioCodec = void 0);
                            var r = e.bitrate + "-" + e.attrs.RESOLUTION + "-" + e.attrs.CODECS;
                            (i = s[r]) ? i.url.push(e.url) : (i = new J(e),
                            s[r] = i,
                            n.push(i)),
                            t && (t.AUDIO && $(i, "audio", t.AUDIO),
                            t.SUBTITLES && $(i, "text", t.SUBTITLES))
                        }
                        )),
                        (l || u) && d && (n = n.filter((function(e) {
                            var t = e.videoCodec
                              , r = e.width
                              , i = e.height;
                            return !!t || !(!r || !i)
                        }
                        ))),
                        n = n.filter((function(e) {
                            var t = e.audioCodec
                              , r = e.videoCodec;
                            return (!t || S(t, "audio")) && (!r || S(r, "video"))
                        }
                        )),
                        t.audioTracks && ee(a = t.audioTracks.filter((function(e) {
                            return !e.audioCodec || S(e.audioCodec, "audio")
                        }
                        ))),
                        t.subtitles && ee(o = t.subtitles),
                        n.length > 0) {
                            r = n[0].bitrate,
                            n.sort((function(e, t) {
                                return e.bitrate - t.bitrate
                            }
                            )),
                            this._levels = n;
                            for (var f = 0; f < n.length; f++)
                                if (n[f].bitrate === r) {
                                    this._firstLevel = f,
                                    this.log("manifest loaded, " + n.length + " level(s) found, first bitrate: " + r);
                                    break
                                }
                            var p = d && !u
                              , g = {
                                levels: n,
                                audioTracks: a,
                                subtitleTracks: o,
                                firstLevel: this._firstLevel,
                                stats: t.stats,
                                audio: d,
                                video: u,
                                altAudio: !p && a.some((function(e) {
                                    return !!e.url
                                }
                                ))
                            };
                            this.hls.trigger(c.a.MANIFEST_PARSED, g),
                            (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
                        } else
                            this.hls.trigger(c.a.ERROR, {
                                type: h.b.MEDIA_ERROR,
                                details: h.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                url: t.url,
                                reason: "no level with compatible codecs found in manifest"
                            })
                    }
                    ,
                    r.onError = function(t, r) {
                        if (e.prototype.onError.call(this, t, r),
                        !r.fatal) {
                            var i = r.context
                              , n = this._levels[this.currentLevelIndex];
                            if (i && (i.type === B.a.AUDIO_TRACK && n.audioGroupIds && i.groupId === n.audioGroupIds[n.urlId] || i.type === B.a.SUBTITLE_TRACK && n.textGroupIds && i.groupId === n.textGroupIds[n.urlId]))
                                this.redundantFailover(this.currentLevelIndex);
                            else {
                                var a, o = !1, s = !0;
                                switch (r.details) {
                                case h.a.FRAG_LOAD_ERROR:
                                case h.a.FRAG_LOAD_TIMEOUT:
                                case h.a.KEY_LOAD_ERROR:
                                case h.a.KEY_LOAD_TIMEOUT:
                                    if (r.frag) {
                                        var l = this._levels[r.frag.level];
                                        l ? (l.fragmentError++,
                                        l.fragmentError > this.hls.config.fragLoadingMaxRetry && (a = r.frag.level)) : a = r.frag.level
                                    }
                                    break;
                                case h.a.LEVEL_LOAD_ERROR:
                                case h.a.LEVEL_LOAD_TIMEOUT:
                                    i && (i.deliveryDirectives && (s = !1),
                                    a = i.level),
                                    o = !0;
                                    break;
                                case h.a.REMUX_ALLOC_ERROR:
                                    a = r.level,
                                    o = !0
                                }
                                void 0 !== a && this.recoverLevel(r, a, o, s)
                            }
                        }
                    }
                    ,
                    r.recoverLevel = function(e, t, r, i) {
                        var n = e.details
                          , a = this._levels[t];
                        if (a.loadError++,
                        r) {
                            if (!this.retryLoadingOrFail(e))
                                return void (this.currentLevelIndex = -1);
                            e.levelRetry = !0
                        }
                        if (i) {
                            var o = a.url.length;
                            if (o > 1 && a.loadError < o)
                                e.levelRetry = !0,
                                this.redundantFailover(t);
                            else if (-1 === this.manualLevelIndex) {
                                var s = 0 === t ? this._levels.length - 1 : t - 1;
                                this.currentLevelIndex !== s && 0 === this._levels[s].loadError && (this.warn(n + ": switch to " + s),
                                e.levelRetry = !0,
                                this.hls.nextAutoLevel = s)
                            }
                        }
                    }
                    ,
                    r.redundantFailover = function(e) {
                        var t = this._levels[e]
                          , r = t.url.length;
                        if (r > 1) {
                            var i = (t.urlId + 1) % r;
                            this.warn("Switching to redundant URL-id " + i),
                            this._levels.forEach((function(e) {
                                e.urlId = i
                            }
                            )),
                            this.level = e
                        }
                    }
                    ,
                    r.onFragLoaded = function(e, t) {
                        var r = t.frag;
                        if (void 0 !== r && r.type === B.b.MAIN) {
                            var i = this._levels[r.level];
                            void 0 !== i && (i.fragmentError = 0,
                            i.loadError = 0)
                        }
                    }
                    ,
                    r.onLevelLoaded = function(e, t) {
                        var r, i, n = t.level, a = t.details, o = this._levels[n];
                        if (!o)
                            return this.warn("Invalid level index " + n),
                            void (null !== (i = t.deliveryDirectives) && void 0 !== i && i.skip && (a.deltaUpdateFailed = !0));
                        n === this.currentLevelIndex ? (0 === o.fragmentError && (o.loadError = 0,
                        this.retryCount = 0),
                        this.playlistLoaded(n, t, o.details)) : null !== (r = t.deliveryDirectives) && void 0 !== r && r.skip && (a.deltaUpdateFailed = !0)
                    }
                    ,
                    r.onAudioTrackSwitched = function(e, t) {
                        var r = this.hls.levels[this.currentLevelIndex];
                        if (r && r.audioGroupIds && t.id >= 0) {
                            for (var i = -1, n = this.hls.audioTracks[t.id].groupId, a = 0; a < r.audioGroupIds.length; a++)
                                if (r.audioGroupIds[a] === n) {
                                    i = a;
                                    break
                                }
                            i !== r.urlId && (r.urlId = i,
                            this.startLoad())
                        }
                    }
                    ,
                    r.loadPlaylist = function(e) {
                        var t = this.currentLevelIndex
                          , r = this._levels[t];
                        if (this.canLoad && r && r.url.length > 0) {
                            var i = r.urlId
                              , n = r.url[i];
                            if (e)
                                try {
                                    n = e.addDirectives(n)
                                } catch (e) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
                                }
                            this.log("Attempt loading level index " + t + (e ? " at sn " + e.msn + " part " + e.part : "") + " with URL-id " + i + " " + n),
                            this.clearTimer(),
                            this.hls.trigger(c.a.LEVEL_LOADING, {
                                url: n,
                                level: t,
                                id: i,
                                deliveryDirectives: e || null,
                                m3u8: this.m3u8StringMap[t]
                            })
                        }
                    }
                    ,
                    r.removeLevel = function(e, t) {
                        var r = function(e, r) {
                            return r !== t
                        }
                          , i = this._levels.filter((function(i, n) {
                            return n !== e || i.url.length > 1 && void 0 !== t && (i.url = i.url.filter(r),
                            i.audioGroupIds && (i.audioGroupIds = i.audioGroupIds.filter(r)),
                            i.textGroupIds && (i.textGroupIds = i.textGroupIds.filter(r)),
                            i.urlId = 0,
                            !0)
                        }
                        )).map((function(e, t) {
                            var r = e.details;
                            return null != r && r.fragments && r.fragments.forEach((function(e) {
                                e.level = t
                            }
                            )),
                            e
                        }
                        ));
                        this._levels = i,
                        this.hls.trigger(c.a.LEVELS_UPDATED, {
                            levels: i
                        })
                    }
                    ,
                    n()(t, [{
                        key: "levels",
                        get: function() {
                            return 0 === this._levels.length ? null : this._levels
                        }
                    }, {
                        key: "level",
                        get: function() {
                            return this.currentLevelIndex
                        },
                        set: function(e) {
                            var t, r = this._levels;
                            if (0 !== r.length && (this.currentLevelIndex !== e || null === (t = r[e]) || void 0 === t || !t.details)) {
                                if (e < 0 || e >= r.length) {
                                    var i = e < 0;
                                    if (this.hls.trigger(c.a.ERROR, {
                                        type: h.b.OTHER_ERROR,
                                        details: h.a.LEVEL_SWITCH_ERROR,
                                        level: e,
                                        fatal: i,
                                        reason: "invalid level idx"
                                    }),
                                    i)
                                        return;
                                    e = Math.min(e, r.length - 1)
                                }
                                this.clearTimer();
                                var n = this.currentLevelIndex
                                  , a = r[n]
                                  , o = r[e];
                                this.log("switching to level " + e + " from " + n),
                                this.currentLevelIndex = e;
                                var s = W()({}, o, {
                                    level: e,
                                    maxBitrate: o.maxBitrate,
                                    uri: o.uri,
                                    urlId: o.urlId
                                });
                                delete s._urlId,
                                this.hls.trigger(c.a.LEVEL_SWITCHING, s);
                                var l = o.details;
                                if (!l || l.live) {
                                    var u = this.switchParams(o.uri, null == a ? void 0 : a.details);
                                    this.loadPlaylist(u)
                                }
                            }
                        }
                    }, {
                        key: "manualLevel",
                        get: function() {
                            return this.manualLevelIndex
                        },
                        set: function(e) {
                            this.manualLevelIndex = e,
                            void 0 === this._startLevel && (this._startLevel = e),
                            -1 !== e && (this.level = e)
                        }
                    }, {
                        key: "firstLevel",
                        get: function() {
                            return this._firstLevel
                        },
                        set: function(e) {
                            this._firstLevel = e
                        }
                    }, {
                        key: "startLevel",
                        get: function() {
                            if (void 0 === this._startLevel) {
                                var e = this.hls.config.startLevel;
                                return void 0 !== e ? e : this._firstLevel
                            }
                            return this._startLevel
                        },
                        set: function(e) {
                            this._startLevel = e
                        }
                    }, {
                        key: "nextLoadLevel",
                        get: function() {
                            return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
                        },
                        set: function(e) {
                            this.level = e,
                            -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
                        }
                    }])
                }(ae)
                  , le = function(e) {
                    return e.NOT_LOADED = "NOT_LOADED",
                    e.BACKTRACKED = "BACKTRACKED",
                    e.APPENDING = "APPENDING",
                    e.PARTIAL = "PARTIAL",
                    e.OK = "OK",
                    e
                }({})
                  , ce = function() {
                    function e(e) {
                        this.activeFragment = null,
                        this.activeParts = null,
                        this.fragments = Object.create(null),
                        this.timeRanges = Object.create(null),
                        this.bufferPadding = .2,
                        this.hls = void 0,
                        this.hls = e,
                        this._registerListeners()
                    }
                    var t = e.prototype;
                    return t._registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.BUFFER_APPENDED, this.onBufferAppended, this),
                        e.on(c.a.FRAG_BUFFERED, this.onFragBuffered, this),
                        e.on(c.a.FRAG_LOADED, this.onFragLoaded, this)
                    }
                    ,
                    t._unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.BUFFER_APPENDED, this.onBufferAppended, this),
                        e.off(c.a.FRAG_BUFFERED, this.onFragBuffered, this),
                        e.off(c.a.FRAG_LOADED, this.onFragLoaded, this)
                    }
                    ,
                    t.destroy = function() {
                        this._unregisterListeners(),
                        this.fragments = this.timeRanges = null
                    }
                    ,
                    t.getAppendedFrag = function(e, t) {
                        if (t === B.b.MAIN) {
                            var r = this.activeFragment
                              , i = this.activeParts;
                            if (!r)
                                return null;
                            if (i)
                                for (var n = i.length; n--; ) {
                                    var a = i[n]
                                      , o = a ? a.end : r.appendedPTS;
                                    if (a.start <= e && void 0 !== o && e <= o)
                                        return n > 9 && (this.activeParts = i.slice(n - 9)),
                                        a
                                }
                            else if (r.start <= e && void 0 !== r.appendedPTS && e <= r.appendedPTS)
                                return r
                        }
                        return this.getBufferedFrag(e, t)
                    }
                    ,
                    t.getBufferedFrag = function(e, t) {
                        for (var r = this.fragments, i = Object.keys(r), n = i.length; n--; ) {
                            var a = r[i[n]];
                            if ((null == a ? void 0 : a.body.type) === t && a.buffered) {
                                var o = a.body;
                                if (o.start <= e && e <= o.end)
                                    return o
                            }
                        }
                        return null
                    }
                    ,
                    t.detectEvictedFragments = function(e, t, r) {
                        var i = this;
                        Object.keys(this.fragments).forEach((function(n) {
                            var a = i.fragments[n];
                            if (a)
                                if (a.buffered) {
                                    var o = a.range[e];
                                    o && o.time.some((function(e) {
                                        var r = !i.isTimeBuffered(e.startPTS, e.endPTS, t);
                                        return r && i.removeFragment(a.body),
                                        r
                                    }
                                    ))
                                } else
                                    a.body.type === r && i.removeFragment(a.body)
                        }
                        ))
                    }
                    ,
                    t.detectPartialFragments = function(e) {
                        var t = this
                          , r = this.timeRanges
                          , i = e.frag
                          , n = e.part;
                        if (r && "initSegment" !== i.sn) {
                            var a = ue(i)
                              , o = this.fragments[a];
                            o && (Object.keys(r).forEach((function(e) {
                                var a = i.elementaryStreams[e];
                                if (a) {
                                    var s = r[e]
                                      , l = null !== n || !0 === a.partial;
                                    o.range[e] = t.getBufferedTimes(i, n, l, s)
                                }
                            }
                            )),
                            o.backtrack = o.loaded = null,
                            Object.keys(o.range).length ? o.buffered = !0 : this.removeFragment(o.body))
                        }
                    }
                    ,
                    t.fragBuffered = function(e) {
                        var t = ue(e)
                          , r = this.fragments[t];
                        r && (r.backtrack = r.loaded = null,
                        r.buffered = !0)
                    }
                    ,
                    t.getBufferedTimes = function(e, t, r, i) {
                        for (var n = {
                            time: [],
                            partial: r
                        }, a = t ? t.start : e.start, o = t ? t.end : e.end, s = e.minEndPTS || o, l = e.maxStartPTS || a, c = 0; c < i.length; c++) {
                            var h = i.start(c) - this.bufferPadding
                              , u = i.end(c) + this.bufferPadding;
                            if (l >= h && s <= u) {
                                n.time.push({
                                    startPTS: Math.max(a, i.start(c)),
                                    endPTS: Math.min(o, i.end(c))
                                });
                                break
                            }
                            if (a < u && o > h)
                                n.partial = !0,
                                n.time.push({
                                    startPTS: Math.max(a, i.start(c)),
                                    endPTS: Math.min(o, i.end(c))
                                });
                            else if (o <= h)
                                break
                        }
                        return n
                    }
                    ,
                    t.getPartialFragment = function(e) {
                        var t, r, i, n = null, a = 0, o = this.bufferPadding, s = this.fragments;
                        return Object.keys(s).forEach((function(l) {
                            var c = s[l];
                            c && he(c) && (r = c.body.start - o,
                            i = c.body.end + o,
                            e >= r && e <= i && (t = Math.min(e - r, i - e),
                            a <= t && (n = c.body,
                            a = t)))
                        }
                        )),
                        n
                    }
                    ,
                    t.getState = function(e) {
                        var t = ue(e)
                          , r = this.fragments[t];
                        return r ? r.buffered ? he(r) ? le.PARTIAL : le.OK : r.backtrack ? le.BACKTRACKED : le.APPENDING : le.NOT_LOADED
                    }
                    ,
                    t.backtrack = function(e, t) {
                        var r = ue(e)
                          , i = this.fragments[r];
                        if (!i || i.backtrack)
                            return null;
                        var n = i.backtrack = t || i.loaded;
                        return i.loaded = null,
                        n
                    }
                    ,
                    t.getBacktrackData = function(e) {
                        var t = ue(e)
                          , r = this.fragments[t];
                        if (r) {
                            var i, n = r.backtrack;
                            if (null != n && null !== (i = n.payload) && void 0 !== i && i.byteLength)
                                return n;
                            this.removeFragment(e)
                        }
                        return null
                    }
                    ,
                    t.isTimeBuffered = function(e, t, r) {
                        for (var i, n, a = 0; a < r.length; a++) {
                            if (i = r.start(a) - this.bufferPadding,
                            n = r.end(a) + this.bufferPadding,
                            e >= i && t <= n)
                                return !0;
                            if (t <= i)
                                return !1
                        }
                        return !1
                    }
                    ,
                    t.onFragLoaded = function(e, t) {
                        var r = t.frag
                          , i = t.part;
                        if ("initSegment" !== r.sn && !r.bitrateTest && !i) {
                            var n = ue(r);
                            this.fragments[n] = {
                                body: r,
                                loaded: t,
                                backtrack: null,
                                buffered: !1,
                                range: Object.create(null)
                            }
                        }
                    }
                    ,
                    t.onBufferAppended = function(e, t) {
                        var r = this
                          , i = t.frag
                          , n = t.part
                          , a = t.timeRanges;
                        if (i.type === B.b.MAIN)
                            if (this.activeFragment = i,
                            n) {
                                var o = this.activeParts;
                                o || (this.activeParts = o = []),
                                o.push(n)
                            } else
                                this.activeParts = null;
                        this.timeRanges = a,
                        Object.keys(a).forEach((function(e) {
                            var t = a[e];
                            if (r.detectEvictedFragments(e, t),
                            !n)
                                for (var o = 0; o < t.length; o++)
                                    i.appendedPTS = Math.max(t.end(o), i.appendedPTS || 0)
                        }
                        ))
                    }
                    ,
                    t.onFragBuffered = function(e, t) {
                        this.detectPartialFragments(t)
                    }
                    ,
                    t.hasFragment = function(e) {
                        var t = ue(e);
                        return !!this.fragments[t]
                    }
                    ,
                    t.removeFragmentsInRange = function(e, t, r) {
                        var i = this;
                        Object.keys(this.fragments).forEach((function(n) {
                            var a = i.fragments[n];
                            if (a && a.buffered) {
                                var o = a.body;
                                o.type === r && o.start < t && o.end > e && i.removeFragment(o)
                            }
                        }
                        ))
                    }
                    ,
                    t.removeFragment = function(e) {
                        var t = ue(e);
                        e.stats.loaded = 0,
                        e.clearElementaryStreamInfo(),
                        delete this.fragments[t]
                    }
                    ,
                    t.removeAllFragments = function() {
                        this.fragments = Object.create(null),
                        this.activeFragment = null,
                        this.activeParts = null
                    }
                    ,
                    e
                }();
                function he(e) {
                    var t, r;
                    return e.buffered && ((null === (t = e.range.video) || void 0 === t ? void 0 : t.partial) || (null === (r = e.range.audio) || void 0 === r ? void 0 : r.partial))
                }
                function ue(e) {
                    return e.type + "_" + e.level + "_" + e.urlId + "_" + e.sn
                }
                var de = function() {
                    function e() {
                        this._boundTick = void 0,
                        this._tickTimer = null,
                        this._tickInterval = null,
                        this._tickCallCount = 0,
                        this._destroyed = !1,
                        this._boundTick = this.tick.bind(this)
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._destroyed = !0,
                        this.onHandlerDestroying(),
                        this.onHandlerDestroyed()
                    }
                    ,
                    t.onHandlerDestroying = function() {
                        this.clearNextTick(),
                        this.clearInterval()
                    }
                    ,
                    t.onHandlerDestroyed = function() {}
                    ,
                    t.hasInterval = function() {
                        return !!this._tickInterval
                    }
                    ,
                    t.hasNextTick = function() {
                        return !!this._tickTimer
                    }
                    ,
                    t.setInterval = function(e) {
                        return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e),
                        !0)
                    }
                    ,
                    t.clearInterval = function() {
                        return !!this._tickInterval && (self.clearInterval(this._tickInterval),
                        this._tickInterval = null,
                        !0)
                    }
                    ,
                    t.clearNextTick = function() {
                        return !!this._tickTimer && (self.clearTimeout(this._tickTimer),
                        this._tickTimer = null,
                        !0)
                    }
                    ,
                    t.tick = function() {
                        this._tickCallCount++,
                        1 === this._tickCallCount && (this.doTick(),
                        this._tickCallCount > 1 && this.tickImmediate(),
                        this._tickCallCount = 0)
                    }
                    ,
                    t.tickImmediate = function() {
                        this.clearNextTick(),
                        this._tickTimer = self.setTimeout(this._boundTick, 0)
                    }
                    ,
                    t.doTick = function() {}
                    ,
                    n()(e, [{
                        key: "destroyed",
                        get: function() {
                            return this._destroyed
                        }
                    }])
                }()
                  , fe = {
                    length: 0,
                    start: function() {
                        return 0
                    },
                    end: function() {
                        return 0
                    }
                }
                  , pe = function() {
                    function e() {}
                    return e.isBuffered = function(t, r) {
                        try {
                            if (t)
                                for (var i = e.getBuffered(t), n = 0; n < i.length; n++)
                                    if (r >= i.start(n) && r <= i.end(n))
                                        return !0
                        } catch (e) {}
                        return !1
                    }
                    ,
                    e.bufferInfo = function(t, r, i) {
                        try {
                            if (t) {
                                var n, a = e.getBuffered(t), o = [];
                                for (n = 0; n < a.length; n++)
                                    o.push({
                                        start: a.start(n),
                                        end: a.end(n)
                                    });
                                return this.bufferedInfo(o, r, i)
                            }
                        } catch (e) {}
                        return {
                            len: 0,
                            start: r,
                            end: r,
                            nextStart: void 0
                        }
                    }
                    ,
                    e.bufferedInfo = function(e, t, r) {
                        t = Math.max(0, t),
                        e.sort((function(e, t) {
                            return e.start - t.start || t.end - e.end
                        }
                        ));
                        var i = [];
                        if (r)
                            for (var n = 0; n < e.length; n++) {
                                var a = i.length;
                                if (a) {
                                    var o = i[a - 1].end;
                                    e[n].start - o < r ? e[n].end > o && (i[a - 1].end = e[n].end) : i.push(e[n])
                                } else
                                    i.push(e[n])
                            }
                        else
                            i = e;
                        for (var s, l = 0, c = t, h = t, u = 0; u < i.length; u++) {
                            var d = i[u].start
                              , f = i[u].end;
                            if (t + r >= d && t < f)
                                c = d,
                                l = (h = f) - t;
                            else if (t + r < d) {
                                s = d;
                                break
                            }
                        }
                        return {
                            len: l,
                            start: c || 0,
                            end: h || 0,
                            nextStart: s
                        }
                    }
                    ,
                    e.getBuffered = function(e) {
                        try {
                            return e.buffered
                        } catch (e) {
                            return u.b.log("failed to get media.buffered", e),
                            fe
                        }
                    }
                    ,
                    e
                }()
                  , ge = function(e, t, r, i, n, a) {
                    void 0 === i && (i = 0),
                    void 0 === n && (n = -1),
                    void 0 === a && (a = !1),
                    this.level = void 0,
                    this.sn = void 0,
                    this.part = void 0,
                    this.id = void 0,
                    this.size = void 0,
                    this.partial = void 0,
                    this.transmuxing = {
                        start: 0,
                        executeStart: 0,
                        executeEnd: 0,
                        end: 0
                    },
                    this.buffering = {
                        audio: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        video: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        audiovideo: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        }
                    },
                    this.level = e,
                    this.sn = t,
                    this.id = r,
                    this.size = i,
                    this.part = n,
                    this.partial = a
                };
                function ve(e, t) {
                    if (e) {
                        var r = e.start + t;
                        e.start = e.startPTS = r,
                        e.endPTS = r + e.duration
                    }
                }
                function ye(e, t) {
                    for (var r = t.fragments, i = 0, n = r.length; i < n; i++)
                        ve(r[i], e);
                    t.fragmentHint && ve(t.fragmentHint, e),
                    t.alignedSliding = !0
                }
                function me(e, t, r) {
                    t && (function(e, t, r) {
                        if (function(e, t, r) {
                            return !(!t.details || !(r.endCC > r.startCC || e && e.cc < r.startCC))
                        }(e, r, t)) {
                            var i = function(e, t) {
                                var r = e.fragments
                                  , i = t.fragments;
                                if (i.length && r.length) {
                                    var n = function(e, t) {
                                        for (var r = null, i = 0, n = e.length; i < n; i++) {
                                            var a = e[i];
                                            if (a && a.cc === t) {
                                                r = a;
                                                break
                                            }
                                        }
                                        return r
                                    }(r, i[0].cc);
                                    if (n && (!n || n.startPTS))
                                        return n;
                                    u.b.log("No frag in previous level to align on")
                                } else
                                    u.b.log("No fragments to align")
                            }(r.details, t);
                            i && Object(o.a)(i.start) && (u.b.log("Adjusting PTS using last level due to CC increase within current level " + t.url),
                            ye(i.start, t))
                        }
                    }(e, r, t),
                    !r.alignedSliding && t.details && Te(r, t.details),
                    r.alignedSliding || !t.details || r.skippedSegments || ne(t.details, r))
                }
                function Te(e, t) {
                    if (t.fragments.length && e.hasProgramDateTime && t.hasProgramDateTime) {
                        var r = t.fragments[0].programDateTime
                          , i = e.fragments[0].programDateTime
                          , n = (i - r) / 1e3 + t.fragments[0].start;
                        n && Object(o.a)(n) && (u.b.log("Adjusting PTS using programDateTime delta " + (i - r) + "ms, sliding:" + n.toFixed(3) + " " + e.url + " "),
                        ye(n, e))
                    }
                }
                var Se = {
                    search: function(e, t) {
                        for (var r = 0, i = e.length - 1, n = null, a = null; r <= i; ) {
                            var o = t(a = e[n = (r + i) / 2 | 0]);
                            if (o > 0)
                                r = n + 1;
                            else {
                                if (!(o < 0))
                                    return a;
                                i = n - 1
                            }
                        }
                        return null
                    }
                };
                function Ie(e, t, r) {
                    if (void 0 === e && (e = 0),
                    void 0 === t && (t = 0),
                    r.start <= e && r.start + r.duration > e)
                        return 0;
                    var i = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
                    return r.start + r.duration - i <= e ? 1 : r.start - i > e && r.start ? -1 : 0
                }
                function Pe(e, t, r) {
                    var i = 1e3 * Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
                    return (r.endProgramDateTime || 0) - i > e
                }
                var be = r(24)
                  , Ee = r.n(be)
                  , De = Math.pow(2, 17)
                  , ke = function() {
                    function e(e) {
                        this.config = void 0,
                        this.loader = null,
                        this.partLoadTimeout = -1,
                        this.highWaterMark = De,
                        this.config = e
                    }
                    var t = e.prototype;
                    return t.setHighWaterMark = function(e) {
                        var t, r, i = Number(e);
                        this.highWaterMark = Number.isNaN(i) ? De : e,
                        null === (t = this.loader) || void 0 === t || null === (r = t.setHighWaterMark) || void 0 === r || r.call(t, this.highWaterMark)
                    }
                    ,
                    t.destroy = function() {
                        this.loader && (this.loader.destroy(),
                        this.loader = null)
                    }
                    ,
                    t.abort = function() {
                        this.loader && this.loader.abort()
                    }
                    ,
                    t.load = function(e, t) {
                        var r = this
                          , i = e.url;
                        if (!i)
                            return Promise.reject(new Le({
                                type: h.b.NETWORK_ERROR,
                                details: h.a.FRAG_LOAD_ERROR,
                                fatal: !1,
                                frag: e,
                                networkDetails: null
                            },"Fragment does not have a " + (i ? "part list" : "url")));
                        this.abort();
                        var n = this.config
                          , a = n.fLoader
                          , o = n.loader;
                        return new Promise((function(i, s) {
                            r.loader && r.loader.destroy();
                            var l = r.loader = e.loader = a ? new a(n) : new o(n)
                              , c = Ce(e)
                              , u = {
                                timeout: n.fragLoadingTimeOut,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: n.fragLoadingMaxRetryTimeout,
                                highWaterMark: r.highWaterMark
                            };
                            e.stats = l.stats;
                            var d = self.performance.now()
                              , f = {
                                onSuccess: function(t, n, a, o) {
                                    r.resetLoader(e, l),
                                    0 === e.stats.loading.start && (e.stats.loading.start = d),
                                    0 === e.stats.loading.end && (e.stats.loading.end = self.performance.now()),
                                    i({
                                        frag: e,
                                        part: null,
                                        payload: t.data,
                                        networkDetails: o
                                    })
                                },
                                onError: function(t, i, n) {
                                    r.resetLoader(e, l),
                                    s(new Le({
                                        type: h.b.NETWORK_ERROR,
                                        details: h.a.FRAG_LOAD_ERROR,
                                        fatal: !1,
                                        frag: e,
                                        response: t,
                                        networkDetails: n
                                    }))
                                },
                                onAbort: function(t, i, n) {
                                    t.aborted = !0,
                                    r.resetLoader(e, l),
                                    s(new Le({
                                        type: h.b.NETWORK_ERROR,
                                        details: h.a.INTERNAL_ABORTED,
                                        fatal: !1,
                                        frag: e,
                                        networkDetails: n
                                    }))
                                },
                                onTimeout: function(t, i, n) {
                                    r.resetLoader(e, l),
                                    s(new Le({
                                        type: h.b.NETWORK_ERROR,
                                        details: h.a.FRAG_LOAD_TIMEOUT,
                                        fatal: !1,
                                        frag: e,
                                        networkDetails: n
                                    }))
                                },
                                onProgress: function(r, i, n, a) {
                                    var o;
                                    t && (0 === e.stats.loading.start && (e.stats.loading.start = d),
                                    0 === e.stats.loading.first && (e.stats.loading.first = self.performance.now()),
                                    0 === e.stats.loaded && (e.stats.loaded += null != (o = null == n ? void 0 : n.byteLength) ? o : 0),
                                    t({
                                        frag: e,
                                        part: null,
                                        payload: n,
                                        networkDetails: a
                                    }))
                                }
                            };
                            "initSegment" === e.sn && delete f.onProgress,
                            l.load(c, u, f)
                        }
                        ))
                    }
                    ,
                    t.loadPart = function(e, t, r) {
                        var i = this;
                        this.abort();
                        var n = this.config
                          , a = n.fLoader
                          , o = n.loader;
                        return new Promise((function(s, l) {
                            i.loader && i.loader.destroy();
                            var c = i.loader = e.loader = a ? new a(n) : new o(n)
                              , u = Ce(e, t)
                              , d = {
                                timeout: n.fragLoadingTimeOut,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: n.fragLoadingMaxRetryTimeout,
                                highWaterMark: De
                            };
                            t.stats = c.stats,
                            c.load(u, d, {
                                onSuccess: function(n, a, o, l) {
                                    i.resetLoader(e, c),
                                    i.updateStatsFromPart(e, t);
                                    var h = {
                                        frag: e,
                                        part: t,
                                        payload: n.data,
                                        networkDetails: l
                                    };
                                    r(h),
                                    s(h)
                                },
                                onError: function(r, n, a) {
                                    i.resetLoader(e, c),
                                    l(new Le({
                                        type: h.b.NETWORK_ERROR,
                                        details: h.a.FRAG_LOAD_ERROR,
                                        fatal: !1,
                                        frag: e,
                                        part: t,
                                        response: r,
                                        networkDetails: a
                                    }))
                                },
                                onAbort: function(r, n, a) {
                                    e.stats.aborted = t.stats.aborted,
                                    i.resetLoader(e, c),
                                    l(new Le({
                                        type: h.b.NETWORK_ERROR,
                                        details: h.a.INTERNAL_ABORTED,
                                        fatal: !1,
                                        frag: e,
                                        part: t,
                                        networkDetails: a
                                    }))
                                },
                                onTimeout: function(r, n, a) {
                                    i.resetLoader(e, c),
                                    l(new Le({
                                        type: h.b.NETWORK_ERROR,
                                        details: h.a.FRAG_LOAD_TIMEOUT,
                                        fatal: !1,
                                        frag: e,
                                        part: t,
                                        networkDetails: a
                                    }))
                                }
                            })
                        }
                        ))
                    }
                    ,
                    t.updateStatsFromPart = function(e, t) {
                        var r = e.stats
                          , i = t.stats
                          , n = i.total;
                        if (r.loaded += i.loaded,
                        n) {
                            var a = Math.round(e.duration / t.duration)
                              , o = Math.min(Math.round(r.loaded / n), a)
                              , s = (a - o) * Math.round(r.loaded / o);
                            r.total = r.loaded + s
                        } else
                            r.total = Math.max(r.loaded, r.total);
                        var l = r.loading
                          , c = i.loading;
                        l.start ? l.first += c.first - c.start : (l.start = c.start,
                        l.first = c.first),
                        l.end = c.end
                    }
                    ,
                    t.resetLoader = function(e, t) {
                        e.loader = null,
                        this.loader === t && (self.clearTimeout(this.partLoadTimeout),
                        this.loader = null),
                        t.destroy()
                    }
                    ,
                    e
                }();
                function Ce(e, t) {
                    void 0 === t && (t = null);
                    var r = t || e
                      , i = {
                        frag: e,
                        part: t,
                        responseType: "arraybuffer",
                        url: r.url,
                        rangeStart: 0,
                        rangeEnd: 0
                    }
                      , n = r.byteRangeStartOffset
                      , a = r.byteRangeEndOffset;
                    return Object(o.a)(n) && Object(o.a)(a) && (i.rangeStart = n,
                    i.rangeEnd = a),
                    i
                }
                var Le = function(e) {
                    function t(t) {
                        for (var r, i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
                            n[a - 1] = arguments[a];
                        return (r = e.call.apply(e, [this].concat(n)) || this).data = void 0,
                        r.data = t,
                        r
                    }
                    return Q()(t, e),
                    t
                }(Ee()(Error))
                  , we = r(21)
                  , Re = {
                    toString: function(e) {
                        for (var t = "", r = e.length, i = 0; i < r; i++)
                            t += "[" + e.start(i).toFixed(3) + "," + e.end(i).toFixed(3) + "]";
                        return t
                    }
                }
                  , Ae = "STOPPED"
                  , _e = "IDLE"
                  , xe = "KEY_LOADING"
                  , Oe = "FRAG_LOADING"
                  , Fe = "FRAG_LOADING_WAITING_RETRY"
                  , Be = "WAITING_TRACK"
                  , Me = "PARSING"
                  , Ue = "PARSED"
                  , Ne = "BACKTRACKING"
                  , Ge = "ENDED"
                  , He = "ERROR"
                  , qe = "WAITING_INIT_PTS"
                  , ze = "WAITING_LEVEL"
                  , Ke = function(e) {
                    function t(t, r, i) {
                        var n;
                        return (n = e.call(this) || this).fragCurrent = null,
                        n.hls = void 0,
                        n.fragPrevious = null,
                        n.fragmentTracker = void 0,
                        n.transmuxer = null,
                        n._state = Ae,
                        n.media = void 0,
                        n.mediaBuffer = void 0,
                        n.config = void 0,
                        n.bitrateTest = !1,
                        n.lastCurrentTime = 0,
                        n.nextLoadPosition = 0,
                        n.startPosition = 0,
                        n.loadedmetadata = !1,
                        n.fragLoadError = 0,
                        n.retryDate = 0,
                        n.levels = null,
                        n.fragmentLoader = void 0,
                        n.levelLastLoaded = null,
                        n.startFragRequested = !1,
                        n.decrypter = void 0,
                        n.initPTS = [],
                        n.onvseeking = null,
                        n.onvended = null,
                        n.logPrefix = "",
                        n.log = void 0,
                        n.warn = void 0,
                        n.logPrefix = i,
                        n.log = u.b.log.bind(u.b, i + ":"),
                        n.warn = u.b.warn.bind(u.b, i + ":"),
                        n.hls = t,
                        n.fragmentLoader = new ke(t.config),
                        n.fragmentTracker = r,
                        n.config = t.config,
                        n.decrypter = new we.a(t,t.config),
                        t.on(c.a.KEY_LOADED, n.onKeyLoaded, n),
                        n
                    }
                    Q()(t, e);
                    var r = t.prototype;
                    return r.doTick = function() {
                        this.onTickEnd()
                    }
                    ,
                    r.onTickEnd = function() {}
                    ,
                    r.startLoad = function(e) {}
                    ,
                    r.stopLoad = function() {
                        this.fragmentLoader.abort();
                        var e = this.fragCurrent;
                        e && this.fragmentTracker.removeFragment(e),
                        this.resetTransmuxer(),
                        this.fragCurrent = null,
                        this.fragPrevious = null,
                        this.clearInterval(),
                        this.clearNextTick(),
                        this.state = Ae
                    }
                    ,
                    r._streamEnded = function(e, t) {
                        var r = this.fragCurrent
                          , i = this.fragmentTracker;
                        if (!t.live && r && r.sn === t.endSN && !e.nextStart) {
                            var n = i.getState(r);
                            return n === le.PARTIAL || n === le.OK
                        }
                        return !1
                    }
                    ,
                    r.onMediaAttached = function(e, t) {
                        var r = this.media = this.mediaBuffer = t.media;
                        this.onvseeking = this.onMediaSeeking.bind(this),
                        this.onvended = this.onMediaEnded.bind(this),
                        r.addEventListener("seeking", this.onvseeking),
                        r.addEventListener("ended", this.onvended);
                        var i = this.config;
                        this.levels && i.autoStartLoad && this.state === Ae && //! FIXME: lastCurrentTime0detach/attach0
                        this.startLoad(this.lastCurrentTime || i.startPosition)
                    }
                    ,
                    r.onMediaDetaching = function() {
                        var e = this.media;
                        null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"),
                        this.startPosition = this.lastCurrentTime = 0),
                        e && (e.removeEventListener("seeking", this.onvseeking),
                        e.removeEventListener("ended", this.onvended),
                        this.onvseeking = this.onvended = null),
                        this.media = this.mediaBuffer = null,
                        this.loadedmetadata = !1,
                        this.fragmentTracker.removeAllFragments(),
                        this.stopLoad()
                    }
                    ,
                    r.onMediaSeeking = function() {
                        var e = this.config
                          , t = this.fragCurrent
                          , r = this.media
                          , i = this.mediaBuffer
                          , n = this.state
                          , a = r ? r.currentTime : 0
                          , s = pe.bufferInfo(i || r, a, e.maxBufferHole);
                        this.log("media seeking to " + (Object(o.a)(a) ? a.toFixed(3) : a) + ", state: " + n);
                        var l = !1;
                        if (this.levels && t) {
                            var c = this.levels[t.level].details;
                            if (c && !c.live) {
                                var h, u = e.maxFragLookUpTolerance, d = t.start - u, f = t.start + t.duration + u;
                                (!s.len || f < s.start || d > s.end) && a < d && this.loadedmetadata && (l = !0,
                                this.log("seeking back, remove source buffer"),
                                null === (h = t.loader) || void 0 === h || h.abort(),
                                this.fragmentTracker.removeFragmentsInRange(a, Number.POSITIVE_INFINITY, t.type),
                                this.flushMainBuffer(a, Number.POSITIVE_INFINITY),
                                this.resetLoadingState())
                            }
                        }
                        if (l || n !== Ge || pe.isBuffered(r, a)) {
                            if (!l && t) {
                                var p = e.maxFragLookUpTolerance
                                  , g = t.start - p
                                  , v = t.start + t.duration + p;
                                if (!s.len || v < s.start || g > s.end) {
                                    var y = a > v;
                                    if (a < g || y) {
                                        y && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"),
                                        this.flushMainBuffer(t.start, t.end),
                                        t.loader.abort());
                                        var m = this.fragmentTracker.getState(t);
                                        y && !t.loader && m === le.APPENDING && (this.log("seeking outside of buffer while fragment appending, reset fragment sn=" + t.sn),
                                        this.fragmentTracker.removeFragment(t),
                                        this.flushMainBuffer(t.start, t.end)),
                                        this.resetLoadingState()
                                    }
                                }
                            }
                        } else
                            this.log("seeking, reset loading state"),
                            this.resetLoadingState();
                        r && (this.lastCurrentTime = a),
                        this.loadedmetadata || s.len || (this.nextLoadPosition = this.startPosition = a),
                        this.tickImmediate()
                    }
                    ,
                    r.onMediaEnded = function() {
                        this.startPosition = this.lastCurrentTime = 0
                    }
                    ,
                    r.onKeyLoaded = function(e, t) {
                        if (this.state === xe && t.frag === this.fragCurrent && this.levels) {
                            this.state = _e;
                            var r = this.levels[t.frag.level].details;
                            r && this.loadFragment(t.frag, r, t.frag.start)
                        }
                    }
                    ,
                    r.onHandlerDestroying = function() {
                        this.stopLoad(),
                        e.prototype.onHandlerDestroying.call(this)
                    }
                    ,
                    r.onHandlerDestroyed = function() {
                        this.state = Ae,
                        this.hls.off(c.a.KEY_LOADED, this.onKeyLoaded, this),
                        this.fragmentLoader && this.fragmentLoader.destroy(),
                        this.decrypter && this.decrypter.destroy(),
                        this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null,
                        e.prototype.onHandlerDestroyed.call(this)
                    }
                    ,
                    r.loadKey = function(e, t) {
                        this.log("Loading key for " + e.sn + " of [" + t.startSN + "-" + t.endSN + "], " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e.level),
                        this.state = xe,
                        this.fragCurrent = e,
                        this.hls.trigger(c.a.KEY_LOADING, {
                            frag: e
                        })
                    }
                    ,
                    r.loadFragment = function(e, t, r) {
                        this._loadFragForPlayback(e, t, r)
                    }
                    ,
                    r._loadFragForPlayback = function(e, t, r) {
                        var i = this;
                        this._doFragLoad(e, t, r, (function(t) {
                            if (i.fragContextChanged(e)) {
                                if (i.destroyed)
                                    return;
                                return i.warn("Fragment " + e.sn + (t.part ? " p: " + t.part.index : "") + " of level " + e.level + " was dropped during download."),
                                void i.fragmentTracker.removeFragment(e)
                            }
                            e.stats.chunkCount++,
                            i._handleFragmentLoadProgress(t)
                        }
                        )).then((function(t) {
                            if (t) {
                                i.fragLoadError = 0;
                                var r = i.state;
                                if (!i.fragContextChanged(e))
                                    return "payload"in t && (i.log("Loaded fragment " + e.sn + " of level " + e.level),
                                    i.hls.trigger(c.a.FRAG_LOADED, t),
                                    i.state === Ne) ? (i.fragmentTracker.backtrack(e, t),
                                    void i.resetFragmentLoading(e)) : void i._handleFragmentLoadComplete(t);
                                (r === Oe || r === Ne || !i.fragCurrent && r === Me) && (i.fragmentTracker.removeFragment(e),
                                i.state = _e)
                            }
                        }
                        )).catch((function(t) {
                            i.warn(t),
                            i.resetFragmentLoading(e)
                        }
                        ))
                    }
                    ,
                    r.flushMainBuffer = function(e, t, r) {
                        if (void 0 === r && (r = null),
                        e - t) {
                            var i = {
                                startOffset: e,
                                endOffset: t,
                                type: r
                            };
                            this.fragLoadError = 0,
                            this.hls.trigger(c.a.BUFFER_FLUSHING, i)
                        }
                    }
                    ,
                    r._loadInitSegment = function(e) {
                        var t = this;
                        this._doFragLoad(e).then((function(r) {
                            if (!r || t.fragContextChanged(e) || !t.levels)
                                throw new Error("init load aborted");
                            return r
                        }
                        )).then((function(r) {
                            var i = t.hls
                              , n = r.payload
                              , a = e.decryptdata;
                            if (n && n.byteLength > 0 && a && a.key && a.iv && "AES-128" === a.method) {
                                var o = self.performance.now();
                                return t.decrypter.webCryptoDecrypt(new Uint8Array(n), a.key.buffer, a.iv.buffer).then((function(t) {
                                    var n = self.performance.now();
                                    return i.trigger(c.a.FRAG_DECRYPTED, {
                                        frag: e,
                                        payload: t,
                                        stats: {
                                            tstart: o,
                                            tdecrypt: n
                                        }
                                    }),
                                    r.payload = t,
                                    r
                                }
                                ))
                            }
                            return r
                        }
                        )).then((function(r) {
                            var i = t.fragCurrent
                              , n = t.hls
                              , a = t.levels;
                            if (!a)
                                throw new Error("init load aborted, missing levels");
                            a[e.level].details;
                            var o = e.stats;
                            t.state = _e,
                            t.fragLoadError = 0,
                            e.data = new Uint8Array(r.payload),
                            o.parsing.start = o.buffering.start = self.performance.now(),
                            o.parsing.end = o.buffering.end = self.performance.now(),
                            r.frag === i && n.trigger(c.a.FRAG_BUFFERED, {
                                stats: o,
                                frag: i,
                                part: null,
                                id: e.type
                            }),
                            t.tick()
                        }
                        )).catch((function(r) {
                            t.warn(r),
                            t.resetFragmentLoading(e)
                        }
                        ))
                    }
                    ,
                    r.fragContextChanged = function(e) {
                        var t = this.fragCurrent;
                        return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
                    }
                    ,
                    r.fragBufferedComplete = function(e, t) {
                        var r = this.mediaBuffer ? this.mediaBuffer : this.media;
                        this.log("Buffered " + e.type + " sn: " + e.sn + (t ? " part: " + t.index : "") + " of " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + e.level + " " + Re.toString(pe.getBuffered(r))),
                        this.state = _e,
                        this.tick()
                    }
                    ,
                    r._handleFragmentLoadComplete = function(e) {
                        var t = this.transmuxer;
                        if (t) {
                            var r = e.frag
                              , i = e.part
                              , n = e.partsLoaded
                              , a = !n || 0 === n.length || n.some((function(e) {
                                return !e
                            }
                            ))
                              , o = new ge(r.level,r.sn,r.stats.chunkCount + 1,0,i ? i.index : -1,!a);
                            t.flush(o)
                        }
                    }
                    ,
                    r._handleFragmentLoadProgress = function(e) {}
                    ,
                    r._doFragLoad = function(e, t, r, i) {
                        var n = this;
                        if (void 0 === r && (r = null),
                        !this.levels)
                            throw new Error("frag load aborted, missing levels");
                        if (r = Math.max(e.start, r || 0),
                        this.config.lowLatencyMode && t) {
                            var a = t.partList;
                            if (a && i) {
                                r > e.end && t.fragmentHint && (e = t.fragmentHint);
                                var s = this.getNextPart(a, e, r);
                                if (s > -1) {
                                    var l = a[s];
                                    return this.log("Loading part sn: " + e.sn + " p: " + l.index + " cc: " + e.cc + " of playlist [" + t.startSN + "-" + t.endSN + "] parts [0-" + s + "-" + (a.length - 1) + "] " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + e.level + ", target: " + parseFloat(r.toFixed(3))),
                                    this.nextLoadPosition = l.start + l.duration,
                                    this.state = Oe,
                                    this.hls.trigger(c.a.FRAG_LOADING, {
                                        frag: e,
                                        part: a[s],
                                        targetBufferTime: r
                                    }),
                                    this.doFragPartsLoad(e, a, s, i).catch((function(e) {
                                        return n.handleFragLoadError(e)
                                    }
                                    ))
                                }
                                if (!e.url || this.loadedEndOfParts(a, r))
                                    return Promise.resolve(null)
                            }
                        }
                        return this.log("Loading fragment " + e.sn + " cc: " + e.cc + " " + (t ? "of [" + t.startSN + "-" + t.endSN + "] " : "") + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + e.level + ", target: " + parseFloat(r.toFixed(3))),
                        Object(o.a)(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration),
                        this.state = Oe,
                        this.hls.trigger(c.a.FRAG_LOADING, {
                            frag: e,
                            targetBufferTime: r
                        }),
                        this.fragmentLoader.load(e, i).catch((function(e) {
                            return n.handleFragLoadError(e)
                        }
                        ))
                    }
                    ,
                    r.doFragPartsLoad = function(e, t, r, i) {
                        var n = this;
                        return new Promise((function(a, o) {
                            var s = [];
                            !function r(l) {
                                var h = t[l];
                                n.fragmentLoader.loadPart(e, h, i).then((function(i) {
                                    s[h.index] = i;
                                    var o = i.part;
                                    n.hls.trigger(c.a.FRAG_LOADED, i);
                                    var u = t[l + 1];
                                    if (!u || u.fragment !== e)
                                        return a({
                                            frag: e,
                                            part: o,
                                            partsLoaded: s
                                        });
                                    r(l + 1)
                                }
                                )).catch(o)
                            }(r)
                        }
                        ))
                    }
                    ,
                    r.handleFragLoadError = function(e) {
                        var t = e.data;
                        return t && t.details === h.a.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(c.a.ERROR, t),
                        null
                    }
                    ,
                    r._handleTransmuxerFlush = function(e) {
                        var t = this.getCurrentContext(e);
                        if (t && this.state === Me) {
                            var r = t.frag
                              , i = t.part
                              , n = t.level
                              , a = self.performance.now();
                            r.stats.parsing.end = a,
                            i && (i.stats.parsing.end = a),
                            this.updateLevelTiming(r, i, n, e.partial)
                        } else
                            this.fragCurrent || (this.state = _e)
                    }
                    ,
                    r.getCurrentContext = function(e) {
                        var t = this.levels
                          , r = e.level
                          , i = e.sn
                          , n = e.part;
                        if (!t || !t[r])
                            return this.warn("Levels object was unset while buffering fragment " + i + " of level " + r + ". The current chunk will not be buffered."),
                            null;
                        var a = t[r]
                          , o = n > -1 ? function(e, t, r) {
                            if (!e || !e.details)
                                return null;
                            var i = e.details.partList;
                            if (i)
                                for (var n = i.length; n--; ) {
                                    var a = i[n];
                                    if (a.index === r && a.fragment.sn === t)
                                        return a
                                }
                            return null
                        }(a, i, n) : null
                          , s = o ? o.fragment : function(e, t, r) {
                            if (!e || !e.details)
                                return null;
                            var i = e.details
                              , n = i.fragments[t - i.startSN];
                            return n || ((n = i.fragmentHint) && n.sn === t ? n : t < i.startSN && r && r.sn === t ? r : null)
                        }(a, i, this.fragCurrent);
                        return s ? {
                            frag: s,
                            part: o,
                            level: a
                        } : null
                    }
                    ,
                    r.bufferFragmentData = function(e, t, r, i) {
                        if (e && this.state === Me) {
                            var n = e.data1
                              , a = e.data2
                              , o = n;
                            if (n && a && (o = Object(d.a)(n, a)),
                            o && o.length) {
                                var s = {
                                    type: e.type,
                                    frag: t,
                                    part: r,
                                    chunkMeta: i,
                                    parent: t.type,
                                    data: o
                                };
                                this.hls.trigger(c.a.BUFFER_APPENDING, s),
                                e.dropped && e.independent && !r && this.flushBufferGap(t)
                            }
                        }
                    }
                    ,
                    r.flushBufferGap = function(e) {
                        var t = this.media;
                        if (t)
                            if (pe.isBuffered(t, t.currentTime)) {
                                var r = t.currentTime
                                  , i = pe.bufferInfo(t, r, 0)
                                  , n = e.duration
                                  , a = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * n)
                                  , o = Math.max(Math.min(e.start - a, i.end - a), r + a);
                                e.start - o > a && this.flushMainBuffer(o, e.start)
                            } else
                                this.flushMainBuffer(0, e.start)
                    }
                    ,
                    r.getFwdBufferInfo = function(e, t) {
                        var r = this.config
                          , i = this.getLoadPosition();
                        if (!Object(o.a)(i))
                            return null;
                        var n = pe.bufferInfo(e, i, r.maxBufferHole);
                        if (0 === n.len && void 0 !== n.nextStart) {
                            var a = this.fragmentTracker.getBufferedFrag(i, t);
                            if (a && n.nextStart < a.end)
                                return pe.bufferInfo(e, i, Math.max(n.nextStart, r.maxBufferHole))
                        }
                        return n
                    }
                    ,
                    r.getMaxBufferLength = function(e) {
                        var t, r = this.config;
                        return t = e ? Math.max(8 * r.maxBufferSize / e, r.maxBufferLength) : r.maxBufferLength,
                        Math.min(t, r.maxMaxBufferLength)
                    }
                    ,
                    r.reduceMaxBufferLength = function(e) {
                        var t = this.config
                          , r = e || t.maxBufferLength;
                        return t.maxMaxBufferLength >= r && (t.maxMaxBufferLength /= 2,
                        this.warn("Reduce max buffer length to " + t.maxMaxBufferLength + "s"),
                        !0)
                    }
                    ,
                    r.getNextFragment = function(e, t) {
                        var r, i, n = t.fragments, a = n.length;
                        if (!a)
                            return null;
                        var o = this.config
                          , s = n[0].start
                          , l = n[0].type
                          , c = null;
                        if (t.live) {
                            var h = o.initialLiveManifestSize;
                            if (a < h)
                                return this.warn("Not enough fragments to start playback (have: " + a + ", need: " + h + ")"),
                                null;
                            t.PTSKnown || this.startFragRequested || -1 !== this.startPosition ? this.fragPrevious || l !== B.b.MAIN || (c = n[Math.max(a - 2, 0)],
                            this.startPosition = c.start) : (c = this.getInitialLiveFragment(t, n),
                            this.startPosition = c ? this.hls.liveSyncPosition || c.start : e)
                        } else
                            e <= s && (c = n[0]);
                        if (!c) {
                            var u = o.lowLatencyMode ? t.partEnd : t.fragmentEnd;
                            c = this.getFragmentAtPosition(e, u, t)
                        }
                        return null === (r = c) || void 0 === r || !r.initSegment || null !== (i = c) && void 0 !== i && i.initSegment.data || this.bitrateTest || (c = c.initSegment),
                        c
                    }
                    ,
                    r.getNextPart = function(e, t, r) {
                        for (var i = -1, n = !1, a = !0, o = 0, s = e.length; o < s; o++) {
                            var l = e[o];
                            if (a = a && !l.independent,
                            i > -1 && r < l.start)
                                break;
                            var c = l.loaded;
                            !c && (n || l.independent || a) && l.fragment === t && (i = o),
                            n = c
                        }
                        return i
                    }
                    ,
                    r.loadedEndOfParts = function(e, t) {
                        var r = e[e.length - 1];
                        return r && t > r.start && r.loaded
                    }
                    ,
                    r.getInitialLiveFragment = function(e, t) {
                        var r = this.fragPrevious
                          , i = null;
                        if (r) {
                            if (e.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + r.programDateTime),
                            i = function(e, t, r) {
                                if (null === t || !Array.isArray(e) || !e.length || !Object(o.a)(t))
                                    return null;
                                if (t < (e[0].programDateTime || 0))
                                    return null;
                                if (t >= (e[e.length - 1].endProgramDateTime || 0))
                                    return null;
                                r = r || 0;
                                for (var i = 0; i < e.length; ++i) {
                                    var n = e[i];
                                    if (Pe(t, r, n))
                                        return n
                                }
                                return null
                            }(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)),
                            !i) {
                                var n = r.sn + 1;
                                if (n >= e.startSN && n <= e.endSN) {
                                    var a = t[n - e.startSN];
                                    r.cc === a.cc && (i = a,
                                    this.log("Live playlist, switching playlist, load frag with next SN: " + i.sn))
                                }
                                i || (i = function(e, t) {
                                    return Se.search(e, (function(e) {
                                        return e.cc < t ? 1 : e.cc > t ? -1 : 0
                                    }
                                    ))
                                }(t, r.cc)) && this.log("Live playlist, switching playlist, load frag with same CC: " + i.sn)
                            }
                        } else {
                            var s = this.hls.liveSyncPosition;
                            null !== s && (i = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e))
                        }
                        return i
                    }
                    ,
                    r.getFragmentAtPosition = function(e, t, r) {
                        var i, n = this.config, a = this.fragPrevious, o = r.fragments, s = r.endSN, l = r.fragmentHint, c = n.maxFragLookUpTolerance, h = !!(n.lowLatencyMode && r.partList && l);
                        if (h && l && !this.bitrateTest && (o = o.concat(l),
                        s = l.sn),
                        i = e < t ? function(e, t, r, i) {
                            void 0 === r && (r = 0),
                            void 0 === i && (i = 0);
                            var n = null;
                            if (e ? n = t[e.sn - t[0].sn + 1] || null : 0 === r && 0 === t[0].start && (n = t[0]),
                            n && 0 === Ie(r, i, n))
                                return n;
                            var a = Se.search(t, Ie.bind(null, r, i));
                            return !a || a == e && n ? n : a
                        }(a, o, e, e > t - c ? 0 : c) : o[o.length - 1],
                        i) {
                            var u = i.sn - r.startSN
                              , d = this.fragmentTracker.getState(i);
                            d === le.OK && (a = i);
                            var f = a && i.level === a.level
                              , p = o[u + 1];
                            if (d === le.BACKTRACKED) {
                                i = null;
                                for (var g = u; o[g] && this.fragmentTracker.getState(o[g]) === le.BACKTRACKED; )
                                    i = a ? o[g--] : o[--g];
                                i || (i = p)
                            } else
                                a && i.sn === a.sn && !h && f && (i.sn < s && this.fragmentTracker.getState(p) !== le.OK ? (this.log("SN " + i.sn + " just loaded, load next one: " + p.sn),
                                i = p) : i = null)
                        }
                        return i
                    }
                    ,
                    r.synchronizeToLiveEdge = function(e) {
                        var t = this.config
                          , r = this.media;
                        if (r) {
                            var i = this.hls.liveSyncPosition
                              , n = r.currentTime
                              , a = e.fragments[0].start
                              , o = e.edge
                              , s = n >= a - t.maxFragLookUpTolerance && n <= o;
                            if (null !== i && r.duration > i && (n < i || !s)) {
                                var l = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
                                (!s && r.readyState < 4 || n < o - l) && (this.loadedmetadata || (this.nextLoadPosition = i),
                                r.readyState && (this.warn("Playback: " + n.toFixed(3) + " is located too far from the end of live sliding playlist: " + o + ", reset currentTime to : " + i.toFixed(3)),
                                r.currentTime = i))
                            }
                        }
                    }
                    ,
                    r.alignPlaylists = function(e, t) {
                        var r = this.levels
                          , i = this.levelLastLoaded
                          , n = this.fragPrevious
                          , a = null !== i ? r[i] : null
                          , s = e.fragments.length;
                        if (!s)
                            return this.warn("No fragments in live playlist"),
                            0;
                        var l = e.fragments[0].start
                          , c = !t
                          , h = e.alignedSliding && Object(o.a)(l);
                        if (c || !h && !l) {
                            me(n, a, e);
                            var u = e.fragments[0].start;
                            return this.log("Live playlist sliding: " + u.toFixed(2) + " start-sn: " + (t ? t.startSN : "na") + "->" + e.startSN + " prev-sn: " + (n ? n.sn : "na") + " fragments: " + s),
                            u
                        }
                        return l
                    }
                    ,
                    r.waitForCdnTuneIn = function(e) {
                        return e.live && e.canBlockReload && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
                    }
                    ,
                    r.setStartPosition = function(e, t) {
                        var r = this.startPosition;
                        if (r < t && (r = -1),
                        -1 === r || -1 === this.lastCurrentTime) {
                            var i = e.startTimeOffset;
                            Object(o.a)(i) ? (r = t + i,
                            i < 0 && (r += e.totalduration),
                            r = Math.min(Math.max(t, r), t + e.totalduration),
                            this.log("Start time offset " + i + " found in playlist, adjust startPosition to " + r),
                            this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0,
                            this.lastCurrentTime = r
                        }
                        this.nextLoadPosition = r
                    }
                    ,
                    r.getLoadPosition = function() {
                        var e = this.media
                          , t = 0;
                        return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition),
                        t
                    }
                    ,
                    r.handleFragLoadAborted = function(e, t) {
                        this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn("Fragment " + e.sn + (t ? " part" + t.index : "") + " of level " + e.level + " was aborted"),
                        this.resetFragmentLoading(e))
                    }
                    ,
                    r.resetFragmentLoading = function(e) {
                        this.fragCurrent && this.fragContextChanged(e) || (this.state = _e)
                    }
                    ,
                    r.onFragmentOrKeyLoadError = function(e, t) {
                        if (!t.fatal) {
                            var r = t.frag;
                            if (r && r.type === e) {
                                this.fragCurrent;
                                var i = this.config;
                                if (this.fragLoadError + 1 <= i.fragLoadingMaxRetry) {
                                    var n;
                                    if (this.resetLiveStartWhenNotLoaded(r.level))
                                        return;
                                    var a = Math.min(Math.pow(2, this.fragLoadError) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);
                                    this.warn("Fragment " + r.sn + " of " + e + " " + r.level + " failed to load, retrying in " + a + "ms"),
                                    this.retryDate = self.performance.now() + a,
                                    this.fragLoadError++,
                                    this.state = Fe,
                                    null === (n = this.transmuxer) || void 0 === n || n.abort()
                                } else if (t.levelRetry) {
                                    var o;
                                    e === B.b.AUDIO && (this.fragCurrent = null),
                                    this.fragLoadError = 0,
                                    this.state = _e,
                                    null === (o = this.transmuxer) || void 0 === o || o.abort()
                                } else
                                    u.b.error(t.details + " reaches max retry, redispatch as fatal ..."),
                                    t.fatal = !0,
                                    this.hls.stopLoad(),
                                    this.state = He
                            }
                        }
                    }
                    ,
                    r.afterBufferFlushed = function(e, t, r) {
                        if (e) {
                            var i = pe.getBuffered(e);
                            this.fragmentTracker.detectEvictedFragments(t, i, r),
                            this.state === Ge && this.resetLoadingState()
                        }
                    }
                    ,
                    r.resetLoadingState = function() {
                        this.log("current state is " + this.state + ", called reset"),
                        this.fragCurrent = null,
                        this.fragPrevious = null,
                        this.state = _e
                    }
                    ,
                    r.resetLiveStartWhenNotLoaded = function(e) {
                        if (!this.loadedmetadata) {
                            this.startFragRequested = !1;
                            var t = this.levels ? this.levels[e].details : null;
                            if (null != t && t.live)
                                return this.startPosition = -1,
                                this.setStartPosition(t, 0),
                                this.resetLoadingState(),
                                !0;
                            this.nextLoadPosition = this.startPosition
                        }
                        return !1
                    }
                    ,
                    r.updateLevelTiming = function(e, t, r, i) {
                        var n = this
                          , a = r.details;
                        Object.keys(e.elementaryStreams).reduce((function(t, o) {
                            var s = e.elementaryStreams[o];
                            if (s) {
                                var l = s.endPTS - s.startPTS;
                                if (l <= 0)
                                    return n.warn("Could not parse fragment " + e.sn + " " + o + " duration reliably (" + l + ") resetting transmuxer to fallback to playlist timing"),
                                    n.resetTransmuxer(),
                                    t || !1;
                                var h = i ? 0 : re(a, e, s.startPTS, s.endPTS, s.startDTS, s.endDTS);
                                return n.hls.trigger(c.a.LEVEL_PTS_UPDATED, {
                                    details: a,
                                    level: r,
                                    drift: h,
                                    type: o,
                                    frag: e,
                                    start: s.startPTS,
                                    end: s.endPTS
                                }),
                                !0
                            }
                            return t
                        }
                        ), !1) ? (this.state = Ue,
                        this.hls.trigger(c.a.FRAG_PARSED, {
                            frag: e,
                            part: t
                        })) : this.resetLoadingState()
                    }
                    ,
                    r.resetTransmuxer = function() {
                        this.transmuxer && (this.transmuxer.destroy(),
                        this.transmuxer = null)
                    }
                    ,
                    n()(t, [{
                        key: "state",
                        get: function() {
                            return this._state
                        },
                        set: function(e) {
                            var t = this._state;
                            t !== e && (this._state = e,
                            this.log(t + "->" + e))
                        }
                    }])
                }(de);
                function Ve() {
                    return self.MediaSource || self.WebKitMediaSource
                }
                function je() {
                    return self.SourceBuffer || self.WebKitSourceBuffer
                }
                var We = r(29)
                  , Ye = r(9)
                  , Qe = r(20)
                  , Xe = Ve() || {
                    isTypeSupported: function() {
                        return !1
                    }
                }
                  , Ze = function() {
                    function e(e, t, r, i) {
                        var n = this;
                        this.hls = void 0,
                        this.id = void 0,
                        this.observer = void 0,
                        this.frag = null,
                        this.part = null,
                        this.worker = void 0,
                        this.onwmsg = void 0,
                        this.transmuxer = null,
                        this.onTransmuxComplete = void 0,
                        this.onFlush = void 0,
                        this.hls = e,
                        this.id = t,
                        this.onTransmuxComplete = r,
                        this.onFlush = i;
                        var a = e.config
                          , o = function(t, r) {
                            (r = r || {}).frag = n.frag,
                            r.id = n.id,
                            e.trigger(t, r)
                        };
                        this.observer = new Qe.EventEmitter,
                        this.observer.on(c.a.FRAG_DECRYPTED, o),
                        this.observer.on(c.a.ERROR, o);
                        var s = {
                            mp4: Xe.isTypeSupported("video/mp4"),
                            mpeg: Xe.isTypeSupported("audio/mpeg"),
                            mp3: Xe.isTypeSupported('audio/mp4; codecs="mp3"')
                        }
                          , l = navigator.vendor;
                        if (a.enableWorker && "undefined" != typeof Worker) {
                            var d;
                            u.b.log("demuxing in webworker");
                            try {
                                d = this.worker = We(35),
                                this.onwmsg = this.onWorkerMessage.bind(this),
                                d.addEventListener("message", this.onwmsg),
                                d.onerror = function(t) {
                                    e.trigger(c.a.ERROR, {
                                        type: h.b.OTHER_ERROR,
                                        details: h.a.INTERNAL_EXCEPTION,
                                        fatal: !0,
                                        event: "demuxerWorker",
                                        error: new Error(t.message + "  (" + t.filename + ":" + t.lineno + ")")
                                    })
                                }
                                ,
                                d.postMessage({
                                    cmd: "init",
                                    typeSupported: s,
                                    vendor: l,
                                    id: t,
                                    config: JSON.stringify(a)
                                })
                            } catch (e) {
                                u.b.warn("Error in worker:", e),
                                u.b.error("Error while initializing DemuxerWorker, fallback to inline"),
                                d && self.URL.revokeObjectURL(d.objectURL),
                                this.transmuxer = new Ye.c(this.observer,s,a,l,t),
                                this.worker = null
                            }
                        } else
                            this.transmuxer = new Ye.c(this.observer,s,a,l,t)
                    }
                    var t = e.prototype;
                    return t.initChachaParam = function() {
                        this.worker && this.worker.postMessage({
                            cmd: "init-chacha-param",
                            param: this.hls.config.chachaParam
                        })
                    }
                    ,
                    t.setDiscontinuities = function(e) {
                        var t;
                        null === (t = this.worker) || void 0 === t || t.postMessage({
                            cmd: "set-discontinuities",
                            param: e
                        })
                    }
                    ,
                    t.clearChaChaChunk = function() {
                        var e;
                        null === (e = this.worker) || void 0 === e || e.postMessage({
                            cmd: "clear-chacha-chunk"
                        })
                    }
                    ,
                    t.destroy = function() {
                        var e = this.worker;
                        if (e)
                            e.removeEventListener("message", this.onwmsg),
                            e.terminate(),
                            this.worker = null;
                        else {
                            var t = this.transmuxer;
                            t && (t.destroy(),
                            this.transmuxer = null)
                        }
                        var r = this.observer;
                        r && r.removeAllListeners(),
                        this.observer = null
                    }
                    ,
                    t.push = function(e, t, r, i, n, a, o, s, l, c) {
                        var h, d = this;
                        l.transmuxing.start = self.performance.now();
                        var f = this.transmuxer
                          , p = this.worker
                          , g = a ? a.start : n.start
                          , v = n.decryptdata
                          , y = this.frag
                          , m = !(y && n.cc === y.cc)
                          , T = !(y && l.level === y.level)
                          , S = y ? l.sn - y.sn : -1
                          , I = this.part ? l.part - this.part.index : 1
                          , P = 1 !== l.id && l.id === (null == y ? void 0 : y.stats.chunkCount)
                          , b = !T && (1 === S && y.stats.loading.end > 0 || 0 === S && P)
                          , E = self.performance.now();
                        u.b.log("received segment data: last=" + (null === (h = this.frag) || void 0 === h ? void 0 : h.sn) + ",cur=" + l.sn + ", id=" + l.id + ", contiguous=" + b),
                        (T || S || 0 === n.stats.parsing.start) && (n.stats.parsing.start = E),
                        !a || !I && b || (a.stats.parsing.start = E);
                        var D = new Ye.b(m,b,s,T,g);
                        if (!b || m) {
                            u.b.log("[transmuxer-interface, " + n.type + "]: Starting new transmux session for sn: " + l.sn + " p: " + l.part + " level: " + l.level + " id: " + l.id + "\n        discontinuity: " + m + "\n        trackSwitch: " + T + "\n        contiguous: " + b + "\n        accurateTimeOffset: " + s + "\n        timeOffset: " + g);
                            var k = new Ye.a(r,i,t,o,c);
                            this.configureTransmuxer(k)
                        }
                        if (this.frag = n,
                        this.part = a,
                        p)
                            p.postMessage({
                                cmd: "demux",
                                data: e,
                                decryptdata: v,
                                chunkMeta: l,
                                state: D
                            }, e instanceof ArrayBuffer ? [e] : []);
                        else if (f) {
                            var C = f.push(e, v, l, D);
                            Object(Ye.d)(C) ? C.then((function(e) {
                                d.handleTransmuxComplete(e)
                            }
                            )) : this.handleTransmuxComplete(C)
                        }
                    }
                    ,
                    t.abort = function() {
                        var e = this.transmuxer
                          , t = this.worker;
                        t ? t.postMessage({
                            cmd: "abort"
                        }) : e && e.abort()
                    }
                    ,
                    t.flush = function(e) {
                        var t = this;
                        e.transmuxing.start = self.performance.now();
                        var r = this.transmuxer
                          , i = this.worker;
                        if (i)
                            i.postMessage({
                                cmd: "flush",
                                chunkMeta: e
                            });
                        else if (r) {
                            var n = r.flush(e);
                            Object(Ye.d)(n) ? n.then((function(r) {
                                t.handleFlushResult(r, e)
                            }
                            )) : this.handleFlushResult(n, e)
                        }
                    }
                    ,
                    t.handleFlushResult = function(e, t) {
                        var r = this;
                        e.forEach((function(e) {
                            r.handleTransmuxComplete(e)
                        }
                        )),
                        this.onFlush(t)
                    }
                    ,
                    t.onWorkerMessage = function(e) {
                        var t = e.data
                          , r = this.hls;
                        switch (t.event) {
                        case "init":
                            self.URL.revokeObjectURL(this.worker.objectURL);
                            break;
                        case "log":
                            var i, n = t.data, a = n.type, o = n.msg;
                            null === (i = u.b[a]) || void 0 === i || i.call.apply(i, [u.b].concat(o));
                            break;
                        case "transmuxComplete":
                            this.handleTransmuxComplete(t.data);
                            break;
                        case "flush":
                            this.onFlush(t.data);
                            break;
                        default:
                            t.data = t.data || {},
                            t.data.frag = this.frag,
                            t.data.id = this.id,
                            r.trigger(t.event, t.data)
                        }
                    }
                    ,
                    t.configureTransmuxer = function(e) {
                        var t = this.worker
                          , r = this.transmuxer;
                        t ? t.postMessage({
                            cmd: "configure",
                            config: e
                        }) : r && r.configure(e)
                    }
                    ,
                    t.handleTransmuxComplete = function(e) {
                        e.chunkMeta.transmuxing.end = self.performance.now(),
                        this.onTransmuxComplete(e)
                    }
                    ,
                    e
                }()
                  , Je = function() {
                    function e(e, t, r, i) {
                        this.config = void 0,
                        this.media = void 0,
                        this.fragmentTracker = void 0,
                        this.hls = void 0,
                        this.nudgeRetry = 0,
                        this.skipRetry = 0,
                        this.stallReported = !1,
                        this.stalled = null,
                        this.moved = !1,
                        this.seeking = !1,
                        this.config = e,
                        this.media = t,
                        this.fragmentTracker = r,
                        this.hls = i
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this.hls = this.fragmentTracker = this.media = null
                    }
                    ,
                    t.poll = function(e) {
                        var t = this.config
                          , r = this.media
                          , i = this.stalled
                          , n = r.currentTime
                          , a = r.seeking
                          , o = this.seeking && !a
                          , s = !this.seeking && a;
                        if (this.seeking = a,
                        n === e || 0 === n) {
                            if ((s || o) && (this.stalled = null),
                            !(r.paused && !r.seeking || r.ended || 0 === r.playbackRate) && pe.getBuffered(r).length) {
                                var l = pe.bufferInfo(r, n, 0)
                                  , c = l.len > 0
                                  , h = l.nextStart || 0;
                                if (c || h) {
                                    if (a) {
                                        var d = l.len > 2
                                          , f = !h || h - n > 2 && !this.fragmentTracker.getPartialFragment(n);
                                        if (d || f)
                                            return;
                                        this.moved = !1
                                    }
                                    if (!this.moved && null !== this.stalled) {
                                        var p, g = Math.max(h, l.start || 0) - n, v = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null, y = (null == v || null === (p = v.details) || void 0 === p ? void 0 : p.live) ? 2 * v.details.targetduration : 2;
                                        if (g > 0 && g <= y)
                                            return void this._trySkipBufferHole(null)
                                    }
                                    var m = self.performance.now();
                                    if (null !== i) {
                                        var T = m - i;
                                        !a && T >= 250 && this._reportStall(l.len);
                                        var S = pe.bufferInfo(r, n, t.maxBufferHole);
                                        this._tryFixBufferStall(S, T)
                                    } else
                                        this.stalled = m
                                }
                            }
                        } else if (this.moved = !0,
                        null !== i) {
                            if (this.stallReported) {
                                var I = self.performance.now() - i;
                                u.b.warn("playback not stuck anymore @" + n + ", after " + Math.round(I) + "ms"),
                                this.stallReported = !1
                            }
                            this.stalled = null,
                            this.nudgeRetry = 0,
                            this.skipRetry = 0
                        }
                    }
                    ,
                    t._tryFixBufferStall = function(e, t) {
                        var r = this.config
                          , i = this.fragmentTracker
                          , n = this.media.currentTime
                          , a = i.getPartialFragment(n);
                        a && this._trySkipBufferHole(a) || e.len > r.maxBufferHole && t > 1e3 * r.highBufferWatchdogPeriod && (u.b.warn("Trying to nudge playhead over buffer-hole"),
                        this.stalled = null,
                        this._tryNudgeBuffer())
                    }
                    ,
                    t._reportStall = function(e) {
                        var t = this.hls
                          , r = this.media;
                        this.stallReported || (this.stallReported = !0,
                        u.b.warn("Playback stalling at @" + r.currentTime + " due to low buffer (buffer=" + e + ")"),
                        t.trigger(c.a.ERROR, {
                            type: h.b.MEDIA_ERROR,
                            details: h.a.BUFFER_STALLED_ERROR,
                            fatal: !1,
                            buffer: e
                        }))
                    }
                    ,
                    t._trySkipBufferHole = function(e) {
                        var t = this.config
                          , r = this.hls
                          , i = this.media
                          , n = i.currentTime
                          , a = (this.skipRetry || 0) + 1;
                        this.skipRetry = a;
                        for (var o = 0, s = pe.getBuffered(i), l = 0; l < s.length; l++) {
                            var d = s.start(l);
                            if (n + t.maxBufferHole >= o && n < d) {
                                var f = Math.max(d + .05, i.currentTime + .1 * a);
                                return u.b.warn("skipping hole, adjusting currentTime from " + n + " to " + f + ", " + d + "/" + i.currentTime + "/" + a),
                                this.moved = !0,
                                this.stalled = null,
                                i.currentTime = f,
                                e && r.trigger(c.a.ERROR, {
                                    type: h.b.MEDIA_ERROR,
                                    details: h.a.BUFFER_SEEK_OVER_HOLE,
                                    fatal: !1,
                                    reason: "fragment loaded with buffer holes, seeking from " + n + " to " + f,
                                    frag: e
                                }),
                                f
                            }
                            o = s.end(l)
                        }
                        return 0
                    }
                    ,
                    t._tryNudgeBuffer = function() {
                        var e = this.config
                          , t = this.hls
                          , r = this.media
                          , i = r.currentTime
                          , n = (this.nudgeRetry || 0) + 1;
                        if (this.nudgeRetry = n,
                        n <= e.nudgeMaxRetry) {
                            var a = i + n * e.nudgeOffset;
                            u.b.warn("Nudging 'currentTime' from " + i + " to " + a),
                            r.currentTime = a,
                            t.trigger(c.a.ERROR, {
                                type: h.b.MEDIA_ERROR,
                                details: h.a.BUFFER_NUDGE_ON_STALL,
                                fatal: !1
                            })
                        } else
                            u.b.error("Playhead still not moving while enough data buffered @" + i + " after " + e.nudgeMaxRetry + " nudges"),
                            t.trigger(c.a.ERROR, {
                                type: h.b.MEDIA_ERROR,
                                details: h.a.BUFFER_STALLED_ERROR,
                                fatal: !0
                            })
                    }
                    ,
                    e
                }()
                  , $e = function(e) {
                    function t(t, r) {
                        var i;
                        return (i = e.call(this, t, r, "[stream-controller]") || this).audioCodecSwap = !1,
                        i.gapController = null,
                        i.level = -1,
                        i._forceStartLoad = !1,
                        i.altAudio = !1,
                        i.audioOnly = !1,
                        i.fragPlaying = null,
                        i.onvplaying = null,
                        i.onvseeked = null,
                        i.fragLastKbps = 0,
                        i.stalled = !1,
                        i.couldBacktrack = !1,
                        i.audioCodecSwitch = !1,
                        i.videoBuffer = null,
                        i.played = !1,
                        i._registerListeners(),
                        i
                    }
                    Q()(t, e);
                    var r = t.prototype;
                    return r.setChachaParam = function() {
                        this.initTransmuxer(),
                        this.transmuxer.initChachaParam()
                    }
                    ,
                    r.initTransmuxer = function() {
                        this.transmuxer || (this.transmuxer = new Ze(this.hls,B.b.MAIN,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this)))
                    }
                    ,
                    r._registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        e.on(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.on(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.on(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.on(c.a.LEVEL_LOADING, this.onLevelLoading, this),
                        e.on(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.on(c.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
                        e.on(c.a.ERROR, this.onError, this),
                        e.on(c.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
                        e.on(c.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
                        e.on(c.a.BUFFER_CREATED, this.onBufferCreated, this),
                        e.on(c.a.BUFFER_FLUSHED, this.onBufferFlushed, this),
                        e.on(c.a.LEVELS_UPDATED, this.onLevelsUpdated, this),
                        e.on(c.a.FRAG_BUFFERED, this.onFragBuffered, this)
                    }
                    ,
                    r._unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        e.off(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.off(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.off(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.off(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.off(c.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
                        e.off(c.a.ERROR, this.onError, this),
                        e.off(c.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
                        e.off(c.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
                        e.off(c.a.BUFFER_CREATED, this.onBufferCreated, this),
                        e.off(c.a.BUFFER_FLUSHED, this.onBufferFlushed, this),
                        e.off(c.a.LEVELS_UPDATED, this.onLevelsUpdated, this),
                        e.off(c.a.FRAG_BUFFERED, this.onFragBuffered, this)
                    }
                    ,
                    r.onHandlerDestroying = function() {
                        this._unregisterListeners(),
                        this.onMediaDetaching()
                    }
                    ,
                    r.startLoad = function(e) {
                        if (this.levels) {
                            var t = this.lastCurrentTime
                              , r = this.hls;
                            if (this.stopLoad(),
                            this.setInterval(100),
                            this.level = -1,
                            this.fragLoadError = 0,
                            !this.startFragRequested) {
                                var i = r.startLevel;
                                -1 === i && (r.config.testBandwidth ? (i = 0,
                                this.bitrateTest = !0) : i = r.nextAutoLevel),
                                this.level = r.nextLoadLevel = i,
                                this.loadedmetadata = !1
                            }
                            t > 0 && -1 === e && (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)),
                            e = t),
                            this.state = _e,
                            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
                            this.tick()
                        } else
                            this._forceStartLoad = !0,
                            this.state = Ae
                    }
                    ,
                    r.stopLoad = function() {
                        this._forceStartLoad = !1,
                        e.prototype.stopLoad.call(this)
                    }
                    ,
                    r.doTick = function() {
                        switch (this.state) {
                        case _e:
                            this.doTickIdle();
                            break;
                        case ze:
                            var e, t = this.levels, r = this.level, i = null == t || null === (e = t[r]) || void 0 === e ? void 0 : e.details;
                            if (i && (!i.live || this.levelLastLoaded === this.level)) {
                                if (this.waitForCdnTuneIn(i))
                                    break;
                                this.state = _e;
                                break
                            }
                            break;
                        case Fe:
                            var n, a = self.performance.now(), o = this.retryDate;
                            (!o || a >= o || null !== (n = this.media) && void 0 !== n && n.seeking) && (this.log("retryDate reached, switch back to IDLE state"),
                            this.state = _e)
                        }
                        this.onTickEnd()
                    }
                    ,
                    r.onTickEnd = function() {
                        e.prototype.onTickEnd.call(this),
                        this.checkBuffer(),
                        this.checkFragmentChanged()
                    }
                    ,
                    r.doTickIdle = function() {
                        var e, t, r = this.hls, i = this.levelLastLoaded, n = this.levels, a = this.media, o = r.config, s = r.nextLoadLevel;
                        if (null !== i && (a || !this.startFragRequested && o.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && n && n[s]) {
                            var l = n[s];
                            this.level = r.nextLoadLevel = s;
                            var h = l.details;
                            if (!h || this.state === ze || h.live && this.levelLastLoaded !== s)
                                this.state = ze;
                            else {
                                var u = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : a, B.b.MAIN);
                                if (null !== u && !(u.len >= this.getMaxBufferLength(l.maxBitrate))) {
                                    if (this._streamEnded(u, h)) {
                                        var d = {};
                                        return this.altAudio && (d.type = "video"),
                                        this.hls.trigger(c.a.BUFFER_EOS, d),
                                        void (this.state = Ge)
                                    }
                                    var p, g, v, y = u.end, m = this.getNextFragment(y, h);
                                    if (this.couldBacktrack && !this.fragPrevious && m && "initSegment" !== m.sn && this.fragmentTracker.getState(m) !== le.OK) {
                                        var T = m.sn - h.startSN
                                          , S = h.fragments[T - 1];
                                        S && m.cc === S.cc && (this.fragmentTracker.getBufferedFrag(S.start, B.b.MAIN) ? this.log("avoid loop loading, backtracked frag is already buffered") : (m = S,
                                        this.fragmentTracker.removeFragment(S)))
                                    }
                                    if (m && this.fragmentTracker.getState(m) === le.OK && this.nextLoadPosition > y) {
                                        var I = this.audioOnly && !this.altAudio ? f.a.AUDIO : f.a.VIDEO;
                                        this.afterBufferFlushed(a, I, B.b.MAIN),
                                        m = this.getNextFragment(this.nextLoadPosition, h)
                                    }
                                    m && (this.loadedmetadata || u.len || "initSegment" === m.sn || (h.firstLoadSN = m.sn),
                                    !m.initSegment || m.initSegment.data || this.bitrateTest || (m = m.initSegment),
                                    "identity" !== (null === (e = m.decryptdata) || void 0 === e ? void 0 : e.keyFormat) || null !== (t = m.decryptdata) && void 0 !== t && t.key ? (this.log("frag " + m.sn + " state=" + this.fragmentTracker.getState(m) + " chosen for loading, playing=" + (null === (p = this.fragPlaying) || void 0 === p ? void 0 : p.sn) + ",current=" + (null === (g = this.fragCurrent) || void 0 === g ? void 0 : g.sn) + ",prev=" + (null === (v = this.fragPrevious) || void 0 === v ? void 0 : v.sn)),
                                    this.loadFragment(m, h, y)) : this.loadKey(m, h))
                                }
                            }
                        }
                    }
                    ,
                    r.loadFragment = function(t, r, i) {
                        var n, a, o = this.fragmentTracker.getState(t);
                        if (this.fragCurrent = t,
                        o === le.BACKTRACKED) {
                            var s = this.fragmentTracker.getBacktrackData(t);
                            if (s)
                                return this._handleFragmentLoadProgress(s),
                                void this._handleFragmentLoadComplete(s);
                            o = le.NOT_LOADED
                        }
                        o === le.NOT_LOADED || o === le.PARTIAL ? (null === (a = this.transmuxer) || void 0 === a || a.clearChaChaChunk(),
                        "initSegment" === t.sn ? this._loadInitSegment(t) : this.bitrateTest ? (t.bitrateTest = !0,
                        this.log("Fragment " + t.sn + " of level " + t.level + " is being downloaded to test bitrate and will not be buffered"),
                        this._loadBitrateTestFrag(t)) : (this.startFragRequested = !0,
                        e.prototype.loadFragment.call(this, t, r, i))) : o === le.APPENDING ? this.reduceMaxBufferLength(t.duration) && this.fragmentTracker.removeFragment(t) : 0 === (null === (n = this.media) || void 0 === n ? void 0 : n.buffered.length) && this.fragmentTracker.removeAllFragments()
                    }
                    ,
                    r.getAppendedFrag = function(e) {
                        var t = this.fragmentTracker.getAppendedFrag(e, B.b.MAIN);
                        return t && "fragment"in t ? t.fragment : t
                    }
                    ,
                    r.getBufferedFrag = function(e) {
                        return this.fragmentTracker.getBufferedFrag(e, B.b.MAIN)
                    }
                    ,
                    r.followingBufferedFrag = function(e) {
                        return e ? this.getBufferedFrag(e.end + .5) : null
                    }
                    ,
                    r.immediateLevelSwitch = function() {
                        this.abortCurrentFrag(),
                        this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                    }
                    ,
                    r.nextLevelSwitch = function() {
                        var e = this.levels
                          , t = this.media;
                        if (null != t && t.readyState) {
                            var r, i = this.getAppendedFrag(t.currentTime);
                            if (i && i.start > 1 && this.flushMainBuffer(0, i.start - 1),
                            !t.paused && e) {
                                var n = e[this.hls.nextLoadLevel]
                                  , a = this.fragLastKbps;
                                r = a && this.fragCurrent && n.maxBitrate ? this.fragCurrent.duration * n.maxBitrate / (1e3 * a) + 1 : 0
                            } else
                                r = 0;
                            Number.isNaN(r) && (r = 0);
                            var o = this.getBufferedFrag(t.currentTime + r);
                            if (o) {
                                var s = this.followingBufferedFrag(o);
                                if (s) {
                                    this.abortCurrentFrag();
                                    var l = s.maxStartPTS ? s.maxStartPTS : s.start
                                      , c = s.duration
                                      , h = Math.max(o.end, l + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, .5 * c), .75 * c));
                                    this.flushMainBuffer(h, Number.POSITIVE_INFINITY)
                                }
                            }
                        }
                    }
                    ,
                    r.abortCurrentFrag = function() {
                        var e = this.fragCurrent;
                        this.fragCurrent = null,
                        null != e && e.loader && e.loader.abort(),
                        this.state === xe && (this.state = _e),
                        this.nextLoadPosition = this.getLoadPosition()
                    }
                    ,
                    r.flushMainBuffer = function(t, r) {
                        e.prototype.flushMainBuffer.call(this, t, r, this.altAudio ? "video" : null)
                    }
                    ,
                    r.onMediaAttached = function(t, r) {
                        e.prototype.onMediaAttached.call(this, t, r);
                        var i = r.media;
                        this.onvplaying = this.onMediaPlaying.bind(this),
                        this.onvseeked = this.onMediaSeeked.bind(this),
                        i.addEventListener("playing", this.onvplaying),
                        i.addEventListener("seeked", this.onvseeked),
                        this.gapController = new Je(this.config,i,this.fragmentTracker,this.hls)
                    }
                    ,
                    r.onMediaDetaching = function() {
                        var t = this.media;
                        t && (t.removeEventListener("playing", this.onvplaying),
                        t.removeEventListener("seeked", this.onvseeked),
                        this.onvplaying = this.onvseeked = null,
                        this.videoBuffer = null),
                        this.fragPlaying = null,
                        this.gapController && (this.gapController.destroy(),
                        this.gapController = null),
                        e.prototype.onMediaDetaching.call(this)
                    }
                    ,
                    r.onMediaPlaying = function() {
                        this.played = !1,
                        this.tick()
                    }
                    ,
                    r.onMediaSeeked = function() {
                        var e = this.media
                          , t = e ? e.currentTime : null;
                        Object(o.a)(t) && this.log("Media seeked to " + t.toFixed(3)),
                        this.tick()
                    }
                    ,
                    r.onManifestLoading = function() {
                        this.log("Trigger BUFFER_RESET"),
                        this.hls.trigger(c.a.BUFFER_RESET, void 0),
                        this.fragmentTracker.removeAllFragments(),
                        this.couldBacktrack = this.stalled = !1,
                        this.startPosition = this.lastCurrentTime = 0,
                        this.fragPlaying = null
                    }
                    ,
                    r.onManifestParsed = function(e, t) {
                        var r, i, n, a = !1, o = !1;
                        t.levels.forEach((function(e) {
                            (r = e.audioCodec) && (-1 !== r.indexOf("mp4a.40.2") && (a = !0),
                            -1 !== r.indexOf("mp4a.40.5") && (o = !0))
                        }
                        )),
                        this.audioCodecSwitch = a && o && !("function" == typeof (null == (n = je()) || null === (i = n.prototype) || void 0 === i ? void 0 : i.changeType)),
                        this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"),
                        this.levels = t.levels,
                        this.startFragRequested = !1
                    }
                    ,
                    r.onLevelLoading = function(e, t) {
                        var r = this.levels;
                        if (r && this.state === _e) {
                            var i = r[t.level];
                            (!i.details || i.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(i.details)) && (this.state = ze)
                        }
                    }
                    ,
                    r.onLevelLoaded = function(e, t) {
                        var r, i = this.levels, n = t.level, a = t.details, o = a.totalduration;
                        if (i) {
                            this.log("Level " + n + " loaded [" + a.startSN + "," + a.endSN + "], cc [" + a.startCC + ", " + a.endCC + "] duration:" + o);
                            var s = this.fragCurrent;
                            !s || this.state !== Oe && this.state !== Fe ? s || (this.state = _e) : s.level !== t.level && s.loader && (this.state = _e,
                            s.loader.abort());
                            var l = i[n]
                              , h = 0;
                            if (a.live || null !== (r = l.details) && void 0 !== r && r.live) {
                                if (a.fragments[0] || (a.deltaUpdateFailed = !0),
                                a.deltaUpdateFailed)
                                    return;
                                h = this.alignPlaylists(a, l.details)
                            }
                            l.details = a,
                            this.levelLastLoaded = n;
                            var u = (l.details || {}).fragments
                              , d = null == u ? void 0 : u.filter((function(e, t) {
                                var r, i, n = (null === (r = u[t - 1]) || void 0 === r ? void 0 : r.cc) || 0, a = (null === (i = u[t + 1]) || void 0 === i ? void 0 : i.cc) || 0;
                                return t === u.length - 1 ? e.cc - n == 1 : a - n == 2
                            }
                            )).map((function(e) {
                                return e.sn
                            }
                            ));
                            if (this.initTransmuxer(),
                            this.transmuxer.setDiscontinuities(d),
                            this.hls.trigger(c.a.LEVEL_UPDATED, {
                                details: a,
                                level: n
                            }),
                            this.state === ze) {
                                if (this.waitForCdnTuneIn(a))
                                    return;
                                this.state = _e
                            }
                            this.startFragRequested ? a.live && this.synchronizeToLiveEdge(a) : this.setStartPosition(a, h),
                            this.tick()
                        } else
                            this.warn("Levels were reset while loading level " + n)
                    }
                    ,
                    r._handleFragmentLoadProgress = function(e) {
                        var t, r = e.frag, i = e.part, n = e.payload, a = this.levels;
                        if (a) {
                            var o = a[r.level]
                              , s = o.details;
                            if (s) {
                                var l = o.videoCodec
                                  , c = s.PTSKnown || !s.live
                                  , h = null === (t = r.initSegment) || void 0 === t ? void 0 : t.data
                                  , u = this._getAudioCodec(o);
                                this.log("Transmuxing " + r.sn + " of [" + s.startSN + " ," + s.endSN + "],level " + r.level + ", cc " + r.cc + ", payload=" + n.byteLength);
                                var d = this.transmuxer = this.transmuxer || new Ze(this.hls,B.b.MAIN,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this))
                                  , f = i ? i.index : -1
                                  , p = -1 !== f
                                  , g = new ge(r.level,r.sn,r.stats.chunkCount,n.byteLength,f,p)
                                  , v = this.initPTS[r.cc];
                                d.push(n, h, u, l, r, i, s.totalduration, c, g, v)
                            } else
                                this.warn("Dropping fragment " + r.sn + " of level " + r.level + " after level details were reset")
                        } else
                            this.warn("Levels were reset while fragment load was in progress. Fragment " + r.sn + " of level " + r.level + " will not be buffered")
                    }
                    ,
                    r.onAudioTrackSwitching = function(e, t) {
                        var r = this.altAudio
                          , i = !!t.url
                          , n = t.id;
                        if (!i) {
                            if (this.mediaBuffer !== this.media) {
                                this.log("Switching on main audio, use media.buffered to schedule main fragment loading"),
                                this.mediaBuffer = this.media;
                                var a = this.fragCurrent;
                                null != a && a.loader && (this.log("Switching to main audio track, cancel main fragment load"),
                                a.loader.abort()),
                                this.resetTransmuxer(),
                                this.resetLoadingState()
                            } else
                                this.audioOnly && this.resetTransmuxer();
                            var o = this.hls;
                            r && (o.trigger(c.a.BUFFER_FLUSHING, {
                                startOffset: 0,
                                endOffset: Number.POSITIVE_INFINITY,
                                type: "audio"
                            }),
                            this.fragmentTracker.removeAllFragments()),
                            setTimeout((function() {
                                o.trigger(c.a.AUDIO_TRACK_SWITCHED, {
                                    id: n
                                })
                            }
                            ))
                        }
                    }
                    ,
                    r.onAudioTrackSwitched = function(e, t) {
                        var r = t.id
                          , i = -1 !== t.id && !!this.hls.audioTracks[r].url;
                        if (i) {
                            var n = this.videoBuffer;
                            n && this.mediaBuffer !== n && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"),
                            this.mediaBuffer = n)
                        }
                        this.altAudio = i,
                        this.tick()
                    }
                    ,
                    r.onBufferCreated = function(e, t) {
                        var r, i, n = t.tracks, a = !1;
                        for (var o in n) {
                            var s = n[o];
                            if ("main" === s.id) {
                                if (i = o,
                                r = s,
                                "video" === o) {
                                    var l = n[o];
                                    l && (this.videoBuffer = l.buffer)
                                }
                            } else
                                a = !0
                        }
                        a && r ? (this.log("Alternate track found, use " + i + ".buffered to schedule main fragment loading"),
                        this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
                    }
                    ,
                    r.onFragBuffered = function(e, t) {
                        var r = t.frag
                          , i = t.part;
                        if (!r || r.type === B.b.MAIN) {
                            if (this.fragContextChanged(r))
                                return this.warn("Fragment " + r.sn + (i ? " p: " + i.index : "") + " of level " + r.level + " finished buffering, but was aborted. state: " + this.state),
                                void (this.state === Ue && (this.state = _e));
                            var n = i ? i.stats : r.stats;
                            this.fragLastKbps = Math.round(8 * n.total / (n.buffering.end - n.loading.first)),
                            "initSegment" !== r.sn && (this.fragPrevious = r),
                            this.fragBufferedComplete(r, i)
                        }
                    }
                    ,
                    r.onError = function(e, t) {
                        switch (t.details) {
                        case h.a.FRAG_LOAD_ERROR:
                        case h.a.FRAG_LOAD_TIMEOUT:
                        case h.a.KEY_LOAD_ERROR:
                        case h.a.KEY_LOAD_TIMEOUT:
                            this.onFragmentOrKeyLoadError(B.b.MAIN, t);
                            break;
                        case h.a.LEVEL_LOAD_ERROR:
                        case h.a.LEVEL_LOAD_TIMEOUT:
                            this.state !== He && (t.fatal ? (this.warn("" + t.details),
                            this.state = He) : t.levelRetry || this.state !== ze || (this.state = _e));
                            break;
                        case h.a.BUFFER_FULL_ERROR:
                            if ("main" === t.parent && (this.state === Me || this.state === Ue)) {
                                var r = !0
                                  , i = this.getFwdBufferInfo(this.media, B.b.MAIN);
                                i && i.len > .5 && (r = !this.reduceMaxBufferLength(i.len)),
                                r && (this.warn("buffer full error also media.currentTime is not buffered, flush main"),
                                this.immediateLevelSwitch()),
                                this.resetLoadingState()
                            }
                        }
                    }
                    ,
                    r.checkBuffer = function() {
                        var e = this.media
                          , t = this.gapController;
                        if (e && t && e.readyState) {
                            var r = pe.getBuffered(e);
                            !this.loadedmetadata && r.length ? (this.loadedmetadata = !0,
                            this.seekToStartPos()) : t.poll(this.lastCurrentTime),
                            this.lastCurrentTime = e.currentTime
                        }
                    }
                    ,
                    r.onFragLoadEmergencyAborted = function() {
                        this.state = _e,
                        this.loadedmetadata || (this.startFragRequested = !1,
                        this.nextLoadPosition = this.startPosition),
                        this.tickImmediate()
                    }
                    ,
                    r.onBufferFlushed = function(e, t) {
                        var r = t.type;
                        if (r !== f.a.AUDIO || this.audioOnly && !this.altAudio) {
                            var i = (r === f.a.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                            this.afterBufferFlushed(i, r, B.b.MAIN)
                        }
                    }
                    ,
                    r.onLevelsUpdated = function(e, t) {
                        this.levels = t.levels
                    }
                    ,
                    r.swapAudioCodec = function() {
                        this.audioCodecSwap = !this.audioCodecSwap
                    }
                    ,
                    r.seekToStartPos = function() {
                        var e = this.media
                          , t = e.currentTime
                          , r = this.startPosition;
                        if (u.b.log("seeking to start pos", t, r),
                        r >= 0 && (t < r || !pe.isBuffered(e, r))) {
                            if (e.seeking)
                                return void u.b.log("could not seek to " + r + ", already seeking at " + t);
                            var i = pe.getBuffered(e)
                              , n = (i.length ? i.start(0) : 0) - r;
                            n > 0 && (u.b.log("adjusting start position by " + n + " to match buffer start"),
                            r += n,
                            this.startPosition = r),
                            this.log("seek to target start position " + r + " from current time " + t),
                            e.currentTime = r
                        }
                    }
                    ,
                    r._getAudioCodec = function(e) {
                        var t = this.config.defaultAudioCodec || e.audioCodec;
                        return this.audioCodecSwap && t && (this.log("Swapping audio codec"),
                        t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"),
                        t
                    }
                    ,
                    r._loadBitrateTestFrag = function(e) {
                        var t = this;
                        this._doFragLoad(e).then((function(r) {
                            var i = t.hls;
                            if (r && !i.nextLoadLevel && !t.fragContextChanged(e)) {
                                t.fragLoadError = 0,
                                t.state = _e,
                                t.startFragRequested = !1,
                                t.bitrateTest = !1;
                                var n = e.stats;
                                n.parsing.start = n.parsing.end = n.buffering.start = n.buffering.end = self.performance.now(),
                                i.trigger(c.a.FRAG_LOADED, r)
                            }
                        }
                        ))
                    }
                    ,
                    r._handleTransmuxComplete = function(e) {
                        var t, r = "main", i = this.hls, n = e.remuxResult, a = e.chunkMeta, s = this.getCurrentContext(a);
                        if (!s)
                            return this.warn("The loading context changed while buffering fragment " + a.sn + " of level " + a.level + ". This chunk will not be buffered."),
                            void this.resetLiveStartWhenNotLoaded(a.level);
                        var l = s.frag
                          , h = s.part
                          , u = s.level
                          , d = n.video
                          , p = n.text
                          , g = n.id3
                          , v = n.initSegment
                          , y = this.altAudio ? void 0 : n.audio;
                        if (this.fragContextChanged(l))
                            this.fragmentTracker.removeFragment(l);
                        else {
                            if (l.stats.transmuxing = a.transmuxing,
                            this.state = Me,
                            v) {
                                v.tracks && (this._bufferInitSegment(u, v.tracks, l, a),
                                i.trigger(c.a.FRAG_PARSING_INIT_SEGMENT, {
                                    frag: l,
                                    id: r,
                                    tracks: v.tracks
                                }));
                                var m = v.initPTS
                                  , T = v.timescale
                                  , S = v.videoStartPts
                                  , I = v.audioStartPts;
                                Object(o.a)(m) && (this.initPTS[l.cc] = m,
                                i.trigger(c.a.INIT_PTS_FOUND, {
                                    frag: l,
                                    id: r,
                                    initPTS: m,
                                    timescale: T,
                                    videoStartPts: S,
                                    audioStartPts: I
                                }))
                            }
                            if (d && !1 !== n.independent) {
                                if (u.details) {
                                    var P = d.startPTS
                                      , b = d.endPTS
                                      , E = d.startDTS
                                      , D = d.endDTS;
                                    if (h)
                                        h.elementaryStreams[d.type] = {
                                            startPTS: P,
                                            endPTS: b,
                                            startDTS: E,
                                            endDTS: D
                                        };
                                    else if (d.firstKeyFrame && d.independent && (this.couldBacktrack = !0),
                                    d.dropped && d.independent) {
                                        var k = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, B.b.MAIN);
                                        if ((k ? k.len : this.getLoadPosition()) + this.config.maxBufferHole < P)
                                            return void this.backtrack(l);
                                        l.setElementaryStreamInfo(d.type, l.start, b, l.start, D, !0)
                                    }
                                    l.setElementaryStreamInfo(d.type, P, b, E, D),
                                    this.bufferFragmentData(d, l, h, a)
                                }
                            } else if (!1 === n.independent)
                                return void this.backtrack(l);
                            if (y) {
                                var C = y.startPTS
                                  , L = y.endPTS
                                  , w = y.startDTS
                                  , R = y.endDTS;
                                h && (h.elementaryStreams[f.a.AUDIO] = {
                                    startPTS: C,
                                    endPTS: L,
                                    startDTS: w,
                                    endDTS: R
                                }),
                                l.setElementaryStreamInfo(f.a.AUDIO, C, L, w, R),
                                this.bufferFragmentData(y, l, h, a)
                            }
                            if (null != g && null !== (t = g.samples) && void 0 !== t && t.length) {
                                var A = {
                                    frag: l,
                                    id: r,
                                    samples: g.samples
                                };
                                i.trigger(c.a.FRAG_PARSING_METADATA, A)
                            }
                            if (p) {
                                var _ = {
                                    frag: l,
                                    id: r,
                                    samples: p.samples
                                };
                                i.trigger(c.a.FRAG_PARSING_USERDATA, _)
                            }
                        }
                    }
                    ,
                    r._bufferInitSegment = function(e, t, r, i) {
                        var n = this;
                        if (this.state === Me) {
                            this.audioOnly = !!t.audio && !t.video,
                            this.altAudio && !this.audioOnly && delete t.audio;
                            var a = t.audio
                              , o = t.video
                              , s = t.audiovideo;
                            if (a) {
                                var l = e.audioCodec
                                  , h = navigator.userAgent.toLowerCase();
                                this.audioCodecSwitch && (l && (l = -1 !== l.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"),
                                1 !== a.metadata.channelCount && -1 === h.indexOf("firefox") && (l = "mp4a.40.5")),
                                -1 !== h.indexOf("android") && "audio/mpeg" !== a.container && (l = "mp4a.40.2",
                                this.log("Android: force audio codec to " + l)),
                                e.audioCodec && e.audioCodec !== l && this.log('Swapping manifest audio codec "' + e.audioCodec + '" for "' + l + '"'),
                                a.levelCodec = l,
                                a.id = "main",
                                this.log("Init audio buffer, container:" + a.container + ", codecs[selected/level/parsed]=[" + (l || "") + "/" + (e.audioCodec || "") + "/" + a.codec + "]")
                            }
                            o && (o.levelCodec = e.videoCodec,
                            o.id = "main",
                            this.log("Init video buffer, container:" + o.container + ", codecs[level/parsed]=[" + (e.videoCodec || "") + "/" + o.codec + "]")),
                            s && this.log("Init audiovideo buffer, container:" + s.container + ", codecs[level/parsed]=[" + (e.attrs.CODECS || "") + "/" + s.codec + "]"),
                            this.hls.trigger(c.a.BUFFER_CODECS, t),
                            Object.keys(t).forEach((function(e) {
                                var a = t[e].initSegment;
                                null != a && a.byteLength && n.hls.trigger(c.a.BUFFER_APPENDING, {
                                    type: e,
                                    data: a,
                                    frag: r,
                                    part: null,
                                    chunkMeta: i,
                                    parent: r.type
                                })
                            }
                            )),
                            this.tick()
                        }
                    }
                    ,
                    r.backtrack = function(e) {
                        this.couldBacktrack = !0,
                        this.resetTransmuxer(),
                        this.flushBufferGap(e),
                        this.fragmentTracker.removeFragment(e),
                        this.fragPrevious = null,
                        this.nextLoadPosition = e.start,
                        this.state = _e
                    }
                    ,
                    r.checkFragmentChanged = function() {
                        var e = this.media
                          , t = null;
                        if (e && e.readyState > 1 && !1 === e.seeking) {
                            var r = e.currentTime;
                            if (pe.isBuffered(e, r) ? t = this.getAppendedFrag(r) : pe.isBuffered(e, r + .1) && (t = this.getAppendedFrag(r + .1)),
                            t) {
                                var i = this.fragPlaying
                                  , n = t.level;
                                i && t.sn === i.sn && i.level === n && t.urlId === i.urlId || (this.hls.trigger(c.a.FRAG_CHANGED, {
                                    frag: t
                                }),
                                i && i.level === n || this.hls.trigger(c.a.LEVEL_SWITCHED, {
                                    level: n
                                }),
                                this.fragPlaying = t),
                                i && i.level !== n && this.hls.trigger(c.a.BUFFER_FLUSHING, {
                                    startOffset: 0,
                                    endOffset: Math.floor(t.start),
                                    type: "video"
                                })
                            }
                        }
                    }
                    ,
                    n()(t, [{
                        key: "fragRemaining",
                        get: function() {
                            var e = this.levels
                              , t = this.level
                              , r = this.fragPlaying;
                            return e && r && e[t] && e[t].details ? e[t].details.endSN - r.sn : -1
                        }
                    }, {
                        key: "nextLevel",
                        get: function() {
                            var e = this.nextBufferedFrag;
                            return e ? e.level : -1
                        }
                    }, {
                        key: "currentLevel",
                        get: function() {
                            var e = this.media;
                            if (e) {
                                var t = this.getAppendedFrag(e.currentTime);
                                if (t)
                                    return t.level
                            }
                            return -1
                        }
                    }, {
                        key: "nextBufferedFrag",
                        get: function() {
                            var e = this.media;
                            if (e) {
                                var t = this.getAppendedFrag(e.currentTime);
                                return this.followingBufferedFrag(t)
                            }
                            return null
                        }
                    }, {
                        key: "forceStartLoad",
                        get: function() {
                            return this._forceStartLoad
                        }
                    }])
                }(Ke)
                  , et = function() {
                    function e(e, t, r) {
                        void 0 === t && (t = 0),
                        void 0 === r && (r = 0),
                        this.halfLife = void 0,
                        this.alpha_ = void 0,
                        this.estimate_ = void 0,
                        this.totalWeight_ = void 0,
                        this.halfLife = e,
                        this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0,
                        this.estimate_ = t,
                        this.totalWeight_ = r
                    }
                    var t = e.prototype;
                    return t.sample = function(e, t) {
                        var r = Math.pow(this.alpha_, e);
                        this.estimate_ = t * (1 - r) + r * this.estimate_,
                        this.totalWeight_ += e
                    }
                    ,
                    t.getTotalWeight = function() {
                        return this.totalWeight_
                    }
                    ,
                    t.getEstimate = function() {
                        if (this.alpha_) {
                            var e = 1 - Math.pow(this.alpha_, this.totalWeight_);
                            if (e)
                                return this.estimate_ / e
                        }
                        return this.estimate_
                    }
                    ,
                    e
                }()
                  , tt = function() {
                    function e(e, t, r) {
                        this.defaultEstimate_ = void 0,
                        this.minWeight_ = void 0,
                        this.minDelayMs_ = void 0,
                        this.slow_ = void 0,
                        this.fast_ = void 0,
                        this.defaultEstimate_ = r,
                        this.minWeight_ = .001,
                        this.minDelayMs_ = 50,
                        this.slow_ = new et(e),
                        this.fast_ = new et(t)
                    }
                    var t = e.prototype;
                    return t.update = function(e, t) {
                        var r = this.slow_
                          , i = this.fast_;
                        this.slow_.halfLife !== e && (this.slow_ = new et(e,r.getEstimate(),r.getTotalWeight())),
                        this.fast_.halfLife !== t && (this.fast_ = new et(t,i.getEstimate(),i.getTotalWeight()))
                    }
                    ,
                    t.sample = function(e, t) {
                        var r = (e = Math.max(e, this.minDelayMs_)) / 1e3
                          , i = 8 * t / r;
                        this.fast_.sample(r, i),
                        this.slow_.sample(r, i)
                    }
                    ,
                    t.canEstimate = function() {
                        var e = this.fast_;
                        return e && e.getTotalWeight() >= this.minWeight_
                    }
                    ,
                    t.getEstimate = function() {
                        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                    }
                    ,
                    t.destroy = function() {}
                    ,
                    e
                }()
                  , rt = function() {
                    function e(e) {
                        this.hls = void 0,
                        this.lastLoadedFragLevel = 0,
                        this._nextAutoLevel = -1,
                        this.timer = void 0,
                        this.onCheck = this._abandonRulesCheck.bind(this),
                        this.fragCurrent = null,
                        this.partCurrent = null,
                        this.bitrateTestDelay = 0,
                        this.bwEstimator = void 0,
                        this.hls = e;
                        var t = e.config;
                        this.bwEstimator = new tt(t.abrEwmaSlowVoD,t.abrEwmaFastVoD,t.abrEwmaDefaultEstimate),
                        this.registerListeners()
                    }
                    var t = e.prototype;
                    return t.registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.FRAG_LOADING, this.onFragLoading, this),
                        e.on(c.a.FRAG_LOADED, this.onFragLoaded, this),
                        e.on(c.a.FRAG_BUFFERED, this.onFragBuffered, this),
                        e.on(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.on(c.a.ERROR, this.onError, this)
                    }
                    ,
                    t.unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.FRAG_LOADING, this.onFragLoading, this),
                        e.off(c.a.FRAG_LOADED, this.onFragLoaded, this),
                        e.off(c.a.FRAG_BUFFERED, this.onFragBuffered, this),
                        e.off(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.off(c.a.ERROR, this.onError, this)
                    }
                    ,
                    t.destroy = function() {
                        this.unregisterListeners(),
                        this.clearTimer(),
                        this.hls = this.onCheck = null,
                        this.fragCurrent = this.partCurrent = null
                    }
                    ,
                    t.onFragLoading = function(e, t) {
                        var r, i = t.frag;
                        i.type === B.b.MAIN && (this.timer || (this.fragCurrent = i,
                        this.partCurrent = null != (r = t.part) ? r : null,
                        this.timer = self.setInterval(this.onCheck, 100)))
                    }
                    ,
                    t.onLevelLoaded = function(e, t) {
                        var r = this.hls.config;
                        t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD)
                    }
                    ,
                    t._abandonRulesCheck = function() {
                        var e = this.fragCurrent
                          , t = this.partCurrent
                          , r = this.hls
                          , i = r.autoLevelEnabled
                          , n = r.config
                          , a = r.media;
                        if (e && a) {
                            var s = t ? t.stats : e.stats
                              , l = t ? t.duration : e.duration;
                            if (s.aborted)
                                return u.b.warn("frag loader destroy or aborted, disarm abandonRules"),
                                this.clearTimer(),
                                void (this._nextAutoLevel = -1);
                            if (i && !a.paused && a.playbackRate && a.readyState) {
                                var h = performance.now() - s.loading.start
                                  , d = Math.abs(a.playbackRate);
                                if (!(h <= 500 * l / d)) {
                                    var f = r.levels
                                      , p = r.minAutoLevel
                                      , g = f[e.level]
                                      , v = s.total || Math.max(s.loaded, Math.round(l * g.maxBitrate / 8))
                                      , y = Math.max(1, s.bwEstimate ? s.bwEstimate / 8 : 1e3 * s.loaded / h)
                                      , m = (v - s.loaded) / y
                                      , T = a.currentTime
                                      , S = (pe.bufferInfo(a, T, n.maxBufferHole).end - T) / d;
                                    if (!(S >= 2 * l / d || m <= S)) {
                                        var I, P = Number.POSITIVE_INFINITY;
                                        for (I = e.level - 1; I > p && !((P = l * f[I].maxBitrate / (6.4 * y)) < S); I--)
                                            ;
                                        if (!(P >= m)) {
                                            var b = this.bwEstimator.getEstimate();
                                            u.b.warn("Fragment " + e.sn + (t ? " part " + t.index : "") + " of level " + e.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + I + "\n      Current BW estimate: " + (Object(o.a)(b) ? (b / 1024).toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + m.toFixed(3) + " s\n      Estimated load time for the next fragment: " + P.toFixed(3) + " s\n      Time to underbuffer: " + S.toFixed(3) + " s"),
                                            r.nextLoadLevel = I,
                                            this.bwEstimator.sample(h, s.loaded),
                                            this.clearTimer(),
                                            e.loader && (this.fragCurrent = this.partCurrent = null,
                                            e.loader.abort()),
                                            r.trigger(c.a.FRAG_LOAD_EMERGENCY_ABORTED, {
                                                frag: e,
                                                part: t,
                                                stats: s
                                            })
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ,
                    t.onFragLoaded = function(e, t) {
                        var r = t.frag
                          , i = t.part;
                        if (r.type === B.b.MAIN && Object(o.a)(r.sn)) {
                            var n = i ? i.stats : r.stats
                              , a = i ? i.duration : r.duration;
                            if (this.clearTimer(),
                            this.lastLoadedFragLevel = r.level,
                            this._nextAutoLevel = -1,
                            this.hls.config.abrMaxWithRealBitrate) {
                                var s = this.hls.levels[r.level]
                                  , l = (s.loaded ? s.loaded.bytes : 0) + n.loaded
                                  , h = (s.loaded ? s.loaded.duration : 0) + a;
                                s.loaded = {
                                    bytes: l,
                                    duration: h
                                },
                                s.realBitrate = Math.round(8 * l / h)
                            }
                            if (r.bitrateTest) {
                                var u = {
                                    stats: n,
                                    frag: r,
                                    part: i,
                                    id: r.type
                                };
                                this.onFragBuffered(c.a.FRAG_BUFFERED, u),
                                r.bitrateTest = !1
                            }
                        }
                    }
                    ,
                    t.onFragBuffered = function(e, t) {
                        var r = t.frag
                          , i = t.part
                          , n = i ? i.stats : r.stats;
                        if (!n.aborted && r.type === B.b.MAIN && "initSegment" !== r.sn) {
                            var a = n.parsing.end - n.loading.start;
                            this.bwEstimator.sample(a, n.loaded),
                            n.bwEstimate = this.bwEstimator.getEstimate(),
                            r.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0
                        }
                    }
                    ,
                    t.onError = function(e, t) {
                        switch (t.details) {
                        case h.a.FRAG_LOAD_ERROR:
                        case h.a.FRAG_LOAD_TIMEOUT:
                            this.clearTimer()
                        }
                    }
                    ,
                    t.clearTimer = function() {
                        self.clearInterval(this.timer),
                        this.timer = void 0
                    }
                    ,
                    t.getNextABRAutoLevel = function() {
                        var e = this.fragCurrent
                          , t = this.partCurrent
                          , r = this.hls
                          , i = r.maxAutoLevel
                          , n = r.config
                          , a = r.minAutoLevel
                          , o = r.media
                          , s = t ? t.duration : e ? e.duration : 0
                          , l = o ? o.currentTime : 0
                          , c = o && 0 !== o.playbackRate ? Math.abs(o.playbackRate) : 1
                          , h = this.bwEstimator ? this.bwEstimator.getEstimate() : n.abrEwmaDefaultEstimate
                          , d = (pe.bufferInfo(o, l, n.maxBufferHole).end - l) / c
                          , f = this.findBestLevel(h, a, i, d, n.abrBandWidthFactor, n.abrBandWidthUpFactor);
                        if (f >= 0)
                            return f;
                        u.b.trace((d ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
                        var p = s ? Math.min(s, n.maxStarvationDelay) : n.maxStarvationDelay
                          , g = n.abrBandWidthFactor
                          , v = n.abrBandWidthUpFactor;
                        if (!d) {
                            var y = this.bitrateTestDelay;
                            y && (p = (s ? Math.min(s, n.maxLoadingDelay) : n.maxLoadingDelay) - y,
                            u.b.trace("bitrate test took " + Math.round(1e3 * y) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * p) + " ms"),
                            g = v = 1)
                        }
                        return f = this.findBestLevel(h, a, i, d + p, g, v),
                        Math.max(f, 0)
                    }
                    ,
                    t.findBestLevel = function(e, t, r, i, n, a) {
                        for (var o, s = this.fragCurrent, l = this.partCurrent, c = this.lastLoadedFragLevel, h = this.hls.levels, d = h[c], f = !(null == d || null === (o = d.details) || void 0 === o || !o.live), p = null == d ? void 0 : d.codecSet, g = l ? l.duration : s ? s.duration : 0, v = r; v >= t; v--) {
                            var y = h[v];
                            if (y && (!p || y.codecSet === p)) {
                                var m = y.details
                                  , T = (l ? null == m ? void 0 : m.partTarget : null == m ? void 0 : m.averagetargetduration) || g
                                  , S = void 0;
                                S = v <= c ? n * e : a * e;
                                var I = h[v].maxBitrate
                                  , P = I * T / S;
                                if (u.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + v + "/" + Math.round(S) + "/" + I + "/" + T + "/" + i + "/" + P),
                                S > I && (!P || f && !this.bitrateTestDelay || P < i))
                                    return v
                            }
                        }
                        return -1
                    }
                    ,
                    n()(e, [{
                        key: "nextAutoLevel",
                        get: function() {
                            var e = this._nextAutoLevel
                              , t = this.bwEstimator;
                            if (!(-1 === e || t && t.canEstimate()))
                                return e;
                            var r = this.getNextABRAutoLevel();
                            return -1 !== e && (r = Math.min(e, r)),
                            r
                        },
                        set: function(e) {
                            this._nextAutoLevel = e
                        }
                    }])
                }()
                  , it = r(18)
                  , nt = function(e) {
                    function t(t, r) {
                        var i;
                        return (i = e.call(this, t, r, "[audio-stream-controller]") || this).videoBuffer = null,
                        i.videoTrackCC = -1,
                        i.waitingVideoCC = -1,
                        i.audioSwitch = !1,
                        i.trackId = -1,
                        i.mainEnded = !1,
                        i.waitingData = null,
                        i.mainDetails = null,
                        i.bufferFlushed = !1,
                        i.pendingAudioTrackData = null,
                        i._registerListeners(),
                        i
                    }
                    Q()(t, e);
                    var r = t.prototype;
                    return r.onHandlerDestroying = function() {
                        this._unregisterListeners(),
                        this.mainDetails = null
                    }
                    ,
                    r._registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        e.on(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.on(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.on(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.on(c.a.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
                        e.on(c.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
                        e.on(c.a.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
                        e.on(c.a.ERROR, this.onError, this),
                        e.on(c.a.BUFFER_RESET, this.onBufferReset, this),
                        e.on(c.a.BUFFER_CREATED, this.onBufferCreated, this),
                        e.on(c.a.BUFFER_FLUSHED, this.onBufferFlushed, this),
                        e.on(c.a.INIT_PTS_FOUND, this.onInitPtsFound, this),
                        e.on(c.a.FRAG_BUFFERED, this.onFragBuffered, this),
                        e.on(c.a.BUFFER_EOS, this.onMainBufferEOS, this)
                    }
                    ,
                    r._unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.MEDIA_ATTACHED, this.onMediaAttached, this),
                        e.off(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.off(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.off(c.a.LEVEL_LOADED, this.onLevelLoaded, this),
                        e.off(c.a.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
                        e.off(c.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
                        e.off(c.a.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
                        e.off(c.a.ERROR, this.onError, this),
                        e.off(c.a.BUFFER_RESET, this.onBufferReset, this),
                        e.off(c.a.BUFFER_CREATED, this.onBufferCreated, this),
                        e.off(c.a.BUFFER_FLUSHED, this.onBufferFlushed, this),
                        e.off(c.a.INIT_PTS_FOUND, this.onInitPtsFound, this),
                        e.off(c.a.FRAG_BUFFERED, this.onFragBuffered, this),
                        e.off(c.a.BUFFER_EOS, this.onMainBufferEOS, this)
                    }
                    ,
                    r.onInitPtsFound = function(e, t) {
                        var r = t.frag
                          , i = t.id
                          , n = t.initPTS;
                        if ("main" === i) {
                            var a = r.cc;
                            this.initPTS[r.cc] = n,
                            this.log("InitPTS for cc: " + a + " found from main: " + n),
                            this.videoTrackCC = a,
                            this.state === qe && this.tick()
                        }
                    }
                    ,
                    r.startLoad = function(e) {
                        if (!this.levels)
                            return this.startPosition = e,
                            void (this.state = Ae);
                        var t = this.lastCurrentTime;
                        this.stopLoad(),
                        this.setInterval(100),
                        this.fragLoadError = 0,
                        t > 0 && -1 === e ? (this.log("Override startPosition with lastCurrentTime @" + t.toFixed(3)),
                        this.state = _e) : (this.loadedmetadata = !1,
                        this.mainEnded = !1,
                        this.state = Be),
                        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
                        this.tick()
                    }
                    ,
                    r.doTick = function() {
                        switch (this.state) {
                        case _e:
                            this.doTickIdle();
                            break;
                        case Be:
                            var t, r = this.levels, i = this.trackId, n = null == r || null === (t = r[i]) || void 0 === t ? void 0 : t.details;
                            if (n) {
                                if (this.waitForCdnTuneIn(n))
                                    break;
                                this.state = qe
                            }
                            break;
                        case Fe:
                            var a, o = performance.now(), s = this.retryDate;
                            (!s || o >= s || null !== (a = this.media) && void 0 !== a && a.seeking) && (this.log("RetryDate reached, switch back to IDLE state"),
                            this.state = _e);
                            break;
                        case qe:
                            var l = this.waitingData;
                            if (l) {
                                var c = l.frag
                                  , h = l.part
                                  , d = l.cache
                                  , f = l.complete;
                                if (void 0 !== this.initPTS[c.cc]) {
                                    this.waitingData = null,
                                    this.waitingVideoCC = -1,
                                    this.state = Oe;
                                    var p = {
                                        frag: c,
                                        part: h,
                                        payload: d.flush(),
                                        networkDetails: null
                                    };
                                    this._handleFragmentLoadProgress(p),
                                    f && e.prototype._handleFragmentLoadComplete.call(this, p)
                                } else if (this.videoTrackCC !== this.waitingVideoCC)
                                    u.b.log("Waiting fragment cc (" + c.cc + ") cancelled because video is at cc " + this.videoTrackCC),
                                    this.clearWaitingFragment();
                                else {
                                    var g = this.getLoadPosition()
                                      , v = pe.bufferInfo(this.mediaBuffer, g, this.config.maxBufferHole);
                                    Ie(v.end, this.config.maxFragLookUpTolerance, c) < 0 && (u.b.log("Waiting fragment cc (" + c.cc + ") @ " + c.start + " cancelled because another fragment at " + v.end + " is needed"),
                                    this.clearWaitingFragment())
                                }
                            } else
                                this.state = _e
                        }
                        this.onTickEnd()
                    }
                    ,
                    r.clearWaitingFragment = function() {
                        var e = this.waitingData;
                        e && (this.warn("clear waiting fragment, frag: " + e.frag.sn + ", cc: " + e.frag.cc + ", video cc: " + this.videoTrackCC),
                        this.fragmentTracker.removeFragment(e.frag),
                        this.waitingData = null,
                        this.waitingVideoCC = -1,
                        this.state = _e)
                    }
                    ,
                    r.onTickEnd = function() {
                        var e = this.media
                          , t = this.trackId
                          , r = this.levels;
                        if (e && e.readyState) {
                            var i = (this.mediaBuffer ? this.mediaBuffer : e).buffered;
                            if (!this.loadedmetadata) {
                                var n, a;
                                if (this.videoBuffer && null != r && null !== (n = r[t]) && void 0 !== n && null !== (a = n.details) && void 0 !== a && a.live) {
                                    var o = pe.getBuffered(this.videoBuffer);
                                    o.length && (e.currentTime = o.start(0))
                                }
                                i.length && (this.loadedmetadata = !0)
                            }
                            this.lastCurrentTime = e.currentTime
                        }
                    }
                    ,
                    r.onMainBufferEOS = function(e, t) {
                        "video" === t.type && (this.mainEnded = !0)
                    }
                    ,
                    r.doTickIdle = function() {
                        var e, t, r, i, n = this.hls, a = this.levels, o = this.media, s = this.trackId, l = n.config;
                        if (a && a[s] && (o || !this.startFragRequested && l.startFragPrefetch)) {
                            var h = a[s].details;
                            if (!h || h.live && this.levelLastLoaded !== s || this.waitForCdnTuneIn(h))
                                this.state = Be;
                            else {
                                this.bufferFlushed && (this.bufferFlushed = !1,
                                this.afterBufferFlushed(this.mediaBuffer ? this.mediaBuffer : this.media, f.a.AUDIO, B.b.AUDIO));
                                var u = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, B.b.AUDIO);
                                if (null !== u) {
                                    var d = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, B.b.MAIN)
                                      , p = u.len
                                      , g = this.getMaxBufferLength(null == d ? void 0 : d.len)
                                      , v = this.audioSwitch;
                                    if (!(p >= g) || v) {
                                        if (!v && this._streamEnded(u, h))
                                            return n.trigger(c.a.BUFFER_EOS, {
                                                type: "audio"
                                            }),
                                            void (this.state = Ge);
                                        var y = h.fragments[0].start
                                          , m = u.end;
                                        if (v) {
                                            var T = this.getLoadPosition();
                                            m = T,
                                            h.PTSKnown && T < y && (u.end > y || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"),
                                            o.currentTime = y + .05)
                                        }
                                        if ((!(d && m > d.end + h.targetduration) || this.mainEnded) && (d && d.len || !u.len)) {
                                            var S = this.getNextFragment(m, h);
                                            S ? (S && this.fragmentTracker.getState(S) === le.OK && this.nextLoadPosition > m && (S = this.getNextFragment(this.nextLoadPosition, h)),
                                            S && (this.log("frag " + S.sn + " state=" + this.fragmentTracker.getState(S) + " chosen for loading, current=" + (null === (e = this.fragCurrent) || void 0 === e ? void 0 : e.sn) + ",prev=" + (null === (t = this.fragPrevious) || void 0 === t ? void 0 : t.sn)),
                                            "identity" !== (null === (r = S.decryptdata) || void 0 === r ? void 0 : r.keyFormat) || null !== (i = S.decryptdata) && void 0 !== i && i.key ? this.loadFragment(S, h, m) : this.loadKey(S, h))) : this.bufferFlushed = !0
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ,
                    r.getMaxBufferLength = function(t) {
                        var r = e.prototype.getMaxBufferLength.call(this);
                        return t ? Math.max(r, t) : r
                    }
                    ,
                    r.onMediaDetaching = function() {
                        this.videoBuffer = null,
                        e.prototype.onMediaDetaching.call(this)
                    }
                    ,
                    r.onAudioTracksUpdated = function(e, t) {
                        var r = t.audioTracks;
                        this.resetTransmuxer(),
                        this.levels = r.map((function(e) {
                            return new J(e)
                        }
                        ))
                    }
                    ,
                    r.onAudioTrackSwitching = function(e, t) {
                        var r = !!t.url;
                        this.trackId = t.id;
                        var i = this.fragCurrent;
                        null != i && i.loader && i.loader.abort(),
                        this.fragCurrent = null,
                        this.clearWaitingFragment(),
                        r ? this.setInterval(100) : this.resetTransmuxer(),
                        r ? (this.audioSwitch = !0,
                        this.state = _e) : this.state = Ae,
                        this.tick()
                    }
                    ,
                    r.onManifestLoading = function() {
                        this.mainDetails = null,
                        this.fragmentTracker.removeAllFragments(),
                        this.startPosition = this.lastCurrentTime = 0,
                        this.bufferFlushed = !1
                    }
                    ,
                    r.onLevelLoaded = function(e, t) {
                        this.mainDetails = t.details,
                        this.pendingAudioTrackData && (this.onAudioTrackLoaded(c.a.AUDIO_TRACK_LOADED, this.pendingAudioTrackData),
                        this.pendingAudioTrackData = null)
                    }
                    ,
                    r.onAudioTrackLoaded = function(e, t) {
                        var r, i = this.levels, n = t.details, a = t.id;
                        if (i) {
                            this.log("Track " + a + " loaded [" + n.startSN + "," + n.endSN + "],duration:" + n.totalduration);
                            var o = i[a]
                              , s = 0;
                            if (n.live || null !== (r = o.details) && void 0 !== r && r.live) {
                                var l = this.mainDetails;
                                if (n.fragments[0] || (n.deltaUpdateFailed = !0),
                                n.deltaUpdateFailed)
                                    return;
                                if (!l)
                                    return void (this.pendingAudioTrackData = t);
                                !o.details && n.hasProgramDateTime && l.hasProgramDateTime ? (Te(n, l),
                                s = n.fragments[0].start) : s = this.alignPlaylists(n, o.details)
                            }
                            o.details = n,
                            this.levelLastLoaded = a,
                            this.startFragRequested || !this.mainDetails && n.live || this.setStartPosition(o.details, s),
                            this.state !== Be || this.waitForCdnTuneIn(n) || (this.state = _e),
                            this.pendingAudioTrackData = null,
                            this.tick()
                        } else
                            this.warn("Audio tracks were reset while loading level " + a)
                    }
                    ,
                    r._handleFragmentLoadProgress = function(e) {
                        var t, r = e.frag, i = e.part, n = e.payload, a = this.config, o = this.trackId, s = this.levels;
                        if (s) {
                            var l = s[o]
                              , c = l.details
                              , h = a.defaultAudioCodec || l.audioCodec || "mp4a.40.2"
                              , d = this.transmuxer;
                            d || (d = this.transmuxer = new Ze(this.hls,B.b.AUDIO,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this)));
                            var f = this.initPTS[r.cc]
                              , p = null === (t = r.initSegment) || void 0 === t ? void 0 : t.data;
                            if (void 0 !== f) {
                                var g = i ? i.index : -1
                                  , v = -1 !== g
                                  , y = new ge(r.level,r.sn,r.stats.chunkCount,n.byteLength,g,v);
                                d.push(n, p, h, "", r, i, c.totalduration, !1, y, f)
                            } else
                                u.b.log("Unknown video PTS for cc " + r.cc + ", waiting for video PTS before demuxing audio frag " + r.sn + " of [" + c.startSN + " ," + c.endSN + "],track " + o),
                                (this.waitingData = this.waitingData || {
                                    frag: r,
                                    part: i,
                                    cache: new it.a,
                                    complete: !1
                                }).cache.push(new Uint8Array(n)),
                                this.waitingVideoCC = this.videoTrackCC,
                                this.state = qe
                        } else
                            this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + r.sn + " of level " + r.level + " will not be buffered")
                    }
                    ,
                    r._handleFragmentLoadComplete = function(t) {
                        this.waitingData ? this.waitingData.complete = !0 : e.prototype._handleFragmentLoadComplete.call(this, t)
                    }
                    ,
                    r.onBufferReset = function() {
                        this.mediaBuffer = this.videoBuffer = null,
                        this.loadedmetadata = !1,
                        this.mainEnded = !1
                    }
                    ,
                    r.onBufferCreated = function(e, t) {
                        var r = t.tracks.audio;
                        r && (this.mediaBuffer = r.buffer),
                        t.tracks.video && (this.videoBuffer = t.tracks.video.buffer)
                    }
                    ,
                    r.onFragBuffered = function(e, t) {
                        var r, i, n = t.frag, a = t.part;
                        if (n.type === B.b.AUDIO)
                            if (this.fragContextChanged(n))
                                this.warn("Fragment " + n.sn + (a ? " p: " + a.index : "") + " of level " + n.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch);
                            else {
                                if (!this.loadedmetadata && "initSegment" !== n.sn && null !== (r = this.mediaBuffer) && void 0 !== r && null !== (i = r.buffered) && void 0 !== i && i.length) {
                                    var o, s, l = pe.getBuffered(this.mediaBuffer).start(0) - n.start, h = this.levels[n.level].details;
                                    if (0 !== l && null != h && h.live)
                                        return this.levels[n.level].details.fragments.forEach((function(e) {
                                            e.start = e.startPTS = e.startDTS = e.start + l,
                                            e.endPTS = e.endDTS = e.end
                                        }
                                        )),
                                        null !== (o = this.videoBuffer) && void 0 !== o && null !== (s = o.buffered) && void 0 !== s && s.length && (this.nextLoadPosition = this.videoBuffer.buffered.start(0)),
                                        this.audioSwitch = !0,
                                        this.resetTransmuxer(),
                                        this.state = _e,
                                        void this.tick()
                                }
                                "initSegment" !== n.sn && (this.fragPrevious = n,
                                this.audioSwitch && (this.audioSwitch = !1,
                                this.hls.trigger(c.a.AUDIO_TRACK_SWITCHED, {
                                    id: this.trackId
                                }))),
                                this.fragBufferedComplete(n, a)
                            }
                    }
                    ,
                    r.onError = function(t, r) {
                        switch (r.details) {
                        case h.a.FRAG_LOAD_ERROR:
                        case h.a.FRAG_LOAD_TIMEOUT:
                        case h.a.KEY_LOAD_ERROR:
                        case h.a.KEY_LOAD_TIMEOUT:
                            this.onFragmentOrKeyLoadError(B.b.AUDIO, r);
                            break;
                        case h.a.AUDIO_TRACK_LOAD_ERROR:
                        case h.a.AUDIO_TRACK_LOAD_TIMEOUT:
                            this.state !== He && this.state !== Ae && (this.state = r.fatal ? He : _e,
                            this.warn(r.details + " while loading frag, switching to " + this.state + " state"));
                            break;
                        case h.a.BUFFER_FULL_ERROR:
                            if ("audio" === r.parent && (this.state === Me || this.state === Ue)) {
                                var i = !0
                                  , n = this.getFwdBufferInfo(this.mediaBuffer, B.b.AUDIO);
                                n && n.len > .5 && (i = !this.reduceMaxBufferLength(n.len)),
                                i && (this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer"),
                                this.fragCurrent = null,
                                e.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")),
                                this.resetLoadingState()
                            }
                        }
                    }
                    ,
                    r.onBufferFlushed = function(e, t) {
                        t.type === f.a.AUDIO && (this.bufferFlushed = !0)
                    }
                    ,
                    r._handleTransmuxComplete = function(e) {
                        var t, r = "audio", i = this.hls, n = e.remuxResult, a = e.chunkMeta, o = this.getCurrentContext(a);
                        if (!o)
                            return this.warn("The loading context changed while buffering fragment " + a.sn + " of level " + a.level + ". This chunk will not be buffered."),
                            void this.resetLiveStartWhenNotLoaded(a.level);
                        var s = o.frag
                          , l = o.part
                          , h = n.audio
                          , u = n.text
                          , d = n.id3
                          , p = n.initSegment;
                        if (this.fragContextChanged(s))
                            this.fragmentTracker.removeFragment(s);
                        else {
                            if (this.state = Me,
                            this.audioSwitch && h && this.completeAudioSwitch(),
                            null != p && p.tracks && (this._bufferInitSegment(p.tracks, s, a),
                            i.trigger(c.a.FRAG_PARSING_INIT_SEGMENT, {
                                frag: s,
                                id: r,
                                tracks: p.tracks
                            })),
                            h) {
                                var g = h.startPTS
                                  , v = h.endPTS
                                  , y = h.startDTS
                                  , m = h.endDTS;
                                l && (l.elementaryStreams[f.a.AUDIO] = {
                                    startPTS: g,
                                    endPTS: v,
                                    startDTS: y,
                                    endDTS: m
                                }),
                                s.setElementaryStreamInfo(f.a.AUDIO, g, v, y, m),
                                this.bufferFragmentData(h, s, l, a)
                            }
                            if (null != d && null !== (t = d.samples) && void 0 !== t && t.length) {
                                var T = W()({
                                    frag: s,
                                    id: r
                                }, d);
                                i.trigger(c.a.FRAG_PARSING_METADATA, T)
                            }
                            if (u) {
                                var S = W()({
                                    frag: s,
                                    id: r
                                }, u);
                                i.trigger(c.a.FRAG_PARSING_USERDATA, S)
                            }
                        }
                    }
                    ,
                    r._bufferInitSegment = function(e, t, r) {
                        if (this.state === Me) {
                            e.video && delete e.video;
                            var i = e.audio;
                            if (i) {
                                i.levelCodec = i.codec,
                                i.id = "audio",
                                this.log("Init audio buffer, container:" + i.container + ", codecs[parsed]=[" + i.codec + "]"),
                                this.hls.trigger(c.a.BUFFER_CODECS, e);
                                var n = i.initSegment;
                                if (null != n && n.byteLength) {
                                    var a = {
                                        type: "audio",
                                        frag: t,
                                        part: null,
                                        chunkMeta: r,
                                        parent: t.type,
                                        data: n
                                    };
                                    this.hls.trigger(c.a.BUFFER_APPENDING, a)
                                }
                                this.tick()
                            }
                        }
                    }
                    ,
                    r.loadFragment = function(t, r, i) {
                        var n = this.fragmentTracker.getState(t);
                        this.fragCurrent = t,
                        this.audioSwitch || n === le.NOT_LOADED || n === le.PARTIAL ? "initSegment" === t.sn ? this._loadInitSegment(t) : r.live && !Object(o.a)(this.initPTS[t.cc]) ? (this.log("Waiting for video PTS in continuity counter " + t.cc + " of live stream before loading audio fragment " + t.sn + " of level " + this.trackId),
                        this.state = qe) : (this.startFragRequested = !0,
                        e.prototype.loadFragment.call(this, t, r, i)) : (this.warn("loadFragment has no effect, frag: " + t.sn + ", fragState: " + n + ", audioSwitch: " + this.audioSwitch + ", startFragRequested: " + this.startFragRequested),
                        this.fragmentTracker.removeFragment(t))
                    }
                    ,
                    r.completeAudioSwitch = function() {
                        var t = this.hls
                          , r = this.media
                          , i = this.trackId;
                        r && (this.log("Switching audio track : flushing all audio"),
                        e.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")),
                        this.audioSwitch = !1,
                        t.trigger(c.a.AUDIO_TRACK_SWITCHED, {
                            id: i
                        })
                    }
                    ,
                    t
                }(Ke)
                  , at = function(e) {
                    function t(t) {
                        var r;
                        return (r = e.call(this, t, "[audio-track-controller]") || this).tracks = [],
                        r.groupId = null,
                        r.tracksInGroup = [],
                        r.trackId = -1,
                        r.trackName = "",
                        r.selectDefaultTrack = !0,
                        r.registerListeners(),
                        r
                    }
                    Q()(t, e);
                    var r = t.prototype;
                    return r.registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.on(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.on(c.a.LEVEL_LOADING, this.onLevelLoading, this),
                        e.on(c.a.LEVEL_SWITCHING, this.onLevelSwitching, this),
                        e.on(c.a.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
                        e.on(c.a.ERROR, this.onError, this)
                    }
                    ,
                    r.unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.MANIFEST_LOADING, this.onManifestLoading, this),
                        e.off(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.off(c.a.LEVEL_LOADING, this.onLevelLoading, this),
                        e.off(c.a.LEVEL_SWITCHING, this.onLevelSwitching, this),
                        e.off(c.a.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
                        e.off(c.a.ERROR, this.onError, this)
                    }
                    ,
                    r.destroy = function() {
                        this.unregisterListeners(),
                        this.tracks.length = 0,
                        this.tracksInGroup.length = 0,
                        e.prototype.destroy.call(this)
                    }
                    ,
                    r.onManifestLoading = function() {
                        this.tracks = [],
                        this.groupId = null,
                        this.tracksInGroup = [],
                        this.trackId = -1,
                        this.trackName = "",
                        this.selectDefaultTrack = !0
                    }
                    ,
                    r.onManifestParsed = function(e, t) {
                        this.tracks = t.audioTracks || []
                    }
                    ,
                    r.onAudioTrackLoaded = function(e, t) {
                        var r = t.id
                          , i = t.details
                          , n = this.tracksInGroup[r];
                        if (n) {
                            var a = n.details;
                            n.details = t.details,
                            this.log("audioTrack " + r + " loaded [" + i.startSN + "-" + i.endSN + "]"),
                            r === this.trackId && (this.retryCount = 0,
                            this.playlistLoaded(r, t, a))
                        } else
                            this.warn("Invalid audio track id " + r)
                    }
                    ,
                    r.onLevelLoading = function(e, t) {
                        this.switchLevel(t.level)
                    }
                    ,
                    r.onLevelSwitching = function(e, t) {
                        this.switchLevel(t.level)
                    }
                    ,
                    r.switchLevel = function(e) {
                        var t = this.hls.levels[e];
                        if (null != t && t.audioGroupIds) {
                            var r = t.audioGroupIds[t.urlId];
                            if (this.groupId !== r) {
                                this.groupId = r;
                                var i = this.tracks.filter((function(e) {
                                    return !r || e.groupId === r
                                }
                                ));
                                this.tracksInGroup = i;
                                var n = {
                                    audioTracks: i
                                };
                                this.log("Updating audio tracks, " + i.length + ' track(s) found in "' + r + '" group-id'),
                                this.hls.trigger(c.a.AUDIO_TRACKS_UPDATED, n),
                                this.selectInitialTrack()
                            }
                        }
                    }
                    ,
                    r.onError = function(t, r) {
                        if (e.prototype.onError.call(this, t, r),
                        !r.fatal && r.context && r.context.type === B.a.AUDIO_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId) {
                            var i, n = this.audioTracks, a = null != (i = this.hls.config.externalAudioRedundantUrls) ? i : [], o = a.length;
                            o && (n[this.trackId].url = a[this.retryCount % o]),
                            this.retryLoadingOrFail(r)
                        }
                    }
                    ,
                    r.setAudioTrack = function(e) {
                        var t = this.tracksInGroup;
                        if (e >= t.length)
                            this.warn("Invalid id passed to audio-track controller");
                        else {
                            if (e < 0)
                                return this.log("switching to internal audio track"),
                                this.trackId = -1,
                                void this.hls.trigger(c.a.AUDIO_TRACK_SWITCHING, {
                                    id: -1,
                                    type: "AUDIO",
                                    url: "",
                                    groupId: "",
                                    name: ""
                                });
                            this.clearTimer();
                            var r = t[this.trackId];
                            this.log("Now switching to audio-track index " + e);
                            var i = t[e]
                              , n = i.id
                              , a = i.groupId
                              , o = void 0 === a ? "" : a
                              , s = i.name
                              , l = i.type
                              , h = i.url;
                            if (this.trackId = e,
                            this.trackName = s,
                            this.selectDefaultTrack = !1,
                            this.hls.trigger(c.a.AUDIO_TRACK_SWITCHING, {
                                id: n,
                                groupId: o,
                                name: s,
                                type: l,
                                url: h
                            }),
                            !i.details || i.details.live) {
                                var u = this.switchParams(i.url, null == r ? void 0 : r.details);
                                this.loadPlaylist(u)
                            }
                        }
                    }
                    ,
                    r.selectInitialTrack = function() {
                        this.tracksInGroup;
                        var e = this.trackName
                          , t = this.findTrackId(e) || this.findTrackId();
                        this.setAudioTrack(t)
                    }
                    ,
                    r.findTrackId = function(e) {
                        for (var t = this.tracksInGroup, r = 0; r < t.length; r++) {
                            var i = t[r];
                            if ((!this.selectDefaultTrack || i.default) && (!e || e === i.name))
                                return i.id
                        }
                        return -1
                    }
                    ,
                    r.loadPlaylist = function(e) {
                        var t = this.tracksInGroup[this.trackId];
                        if (this.shouldLoadTrack(t)) {
                            var r = t.id
                              , i = t.groupId
                              , n = t.url;
                            if (e)
                                try {
                                    n = e.addDirectives(n)
                                } catch (e) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + e)
                                }
                            this.log("loading audio-track playlist for id: " + r),
                            this.clearTimer(),
                            this.hls.trigger(c.a.AUDIO_TRACK_LOADING, {
                                url: n,
                                id: r,
                                groupId: i,
                                deliveryDirectives: e || null
                            })
                        }
                    }
                    ,
                    n()(t, [{
                        key: "audioTracks",
                        get: function() {
                            return this.tracksInGroup
                        }
                    }, {
                        key: "audioTrack",
                        get: function() {
                            return this.trackId
                        },
                        set: function(e) {
                            this.selectDefaultTrack = !1,
                            this.setAudioTrack(e)
                        }
                    }])
                }(ae)
                  , ot = r(19)
                  , st = r.n(ot)
                  , lt = function() {
                    function e(e) {
                        this.buffers = void 0,
                        this.queues = {
                            video: [],
                            audio: [],
                            audiovideo: []
                        },
                        this.buffers = e
                    }
                    var t = e.prototype;
                    return t.append = function(e, t) {
                        var r = this.queues[t];
                        r.push(e),
                        1 === r.length && this.buffers[t] && this.executeNext(t)
                    }
                    ,
                    t.insertAbort = function(e, t) {
                        this.queues[t].unshift(e),
                        this.executeNext(t)
                    }
                    ,
                    t.appendBlocker = function(e) {
                        var t, r = new Promise((function(e) {
                            t = e
                        }
                        )), i = {
                            execute: t,
                            onStart: function() {},
                            onComplete: function() {},
                            onError: function() {}
                        };
                        return this.append(i, e),
                        r
                    }
                    ,
                    t.executeNext = function(e) {
                        var t = this.buffers
                          , r = this.queues
                          , i = t[e]
                          , n = r[e];
                        if (n.length) {
                            var a = n[0];
                            try {
                                a.execute()
                            } catch (t) {
                                u.b.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"),
                                a.onError(t),
                                i && i.updating || (n.shift(),
                                this.executeNext(e))
                            }
                        }
                    }
                    ,
                    t.shiftAndExecuteNext = function(e) {
                        this.queues[e].shift(),
                        this.executeNext(e)
                    }
                    ,
                    t.current = function(e) {
                        return this.queues[e][0]
                    }
                    ,
                    e
                }()
                  , ct = Ve()
                  , ht = /([ha]vc.)(?:\.[^.,]+)+/
                  , ut = function() {
                    function e(e) {
                        var t = this;
                        this.details = null,
                        this._objectUrl = null,
                        this.operationQueue = void 0,
                        this.listeners = void 0,
                        this.hls = void 0,
                        this.bufferCodecEventsExpected = 0,
                        this._bufferCodecEventsTotal = 0,
                        this.media = null,
                        this.mediaSource = null,
                        this.appendError = 0,
                        this.tracks = {},
                        this.pendingTracks = {},
                        this.sourceBuffer = void 0,
                        this._onMediaSourceOpen = function() {
                            var e = t.hls
                              , r = t.media
                              , i = t.mediaSource;
                            u.b.log("[buffer-controller]: Media source opened"),
                            r && (t.updateMediaElementDuration(),
                            e.trigger(c.a.MEDIA_ATTACHED, {
                                media: r
                            })),
                            i && i.removeEventListener("sourceopen", t._onMediaSourceOpen),
                            t.checkPendingTracks()
                        }
                        ,
                        this._onMediaSourceClose = function() {
                            u.b.log("[buffer-controller]: Media source closed")
                        }
                        ,
                        this._onMediaSourceEnded = function() {
                            u.b.log("[buffer-controller]: Media source ended")
                        }
                        ,
                        this.hls = e,
                        this._initSourceBuffer(),
                        this.registerListeners()
                    }
                    var t = e.prototype;
                    return t.hasSourceTypes = function() {
                        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
                    }
                    ,
                    t.destroy = function() {
                        this.unregisterListeners(),
                        this.details = null
                    }
                    ,
                    t.registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.MEDIA_ATTACHING, this.onMediaAttaching, this),
                        e.on(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.on(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.on(c.a.BUFFER_RESET, this.onBufferReset, this),
                        e.on(c.a.BUFFER_APPENDING, this.onBufferAppending, this),
                        e.on(c.a.BUFFER_CODECS, this.onBufferCodecs, this),
                        e.on(c.a.BUFFER_EOS, this.onBufferEos, this),
                        e.on(c.a.BUFFER_FLUSHING, this.onBufferFlushing, this),
                        e.on(c.a.LEVEL_UPDATED, this.onLevelUpdated, this),
                        e.on(c.a.FRAG_PARSED, this.onFragParsed, this),
                        e.on(c.a.FRAG_CHANGED, this.onFragChanged, this)
                    }
                    ,
                    t.unregisterListeners = function() {
                        var e = this.hls;
                        e.off(c.a.MEDIA_ATTACHING, this.onMediaAttaching, this),
                        e.off(c.a.MEDIA_DETACHING, this.onMediaDetaching, this),
                        e.off(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.off(c.a.BUFFER_RESET, this.onBufferReset, this),
                        e.off(c.a.BUFFER_APPENDING, this.onBufferAppending, this),
                        e.off(c.a.BUFFER_CODECS, this.onBufferCodecs, this),
                        e.off(c.a.BUFFER_EOS, this.onBufferEos, this),
                        e.off(c.a.BUFFER_FLUSHING, this.onBufferFlushing, this),
                        e.off(c.a.LEVEL_UPDATED, this.onLevelUpdated, this),
                        e.off(c.a.FRAG_PARSED, this.onFragParsed, this),
                        e.off(c.a.FRAG_CHANGED, this.onFragChanged, this)
                    }
                    ,
                    t._initSourceBuffer = function() {
                        this.sourceBuffer = {},
                        this.operationQueue = new lt(this.sourceBuffer),
                        this.listeners = {
                            audio: [],
                            video: [],
                            audiovideo: []
                        }
                    }
                    ,
                    t.onManifestParsed = function(e, t) {
                        var r = 2;
                        (t.audio && !t.video || !t.altAudio) && (r = 1),
                        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r,
                        this.details = null,
                        u.b.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
                    }
                    ,
                    t.onMediaAttaching = function(e, t) {
                        var r = this.media = t.media;
                        if (r && ct) {
                            var i = this.mediaSource = new ct;
                            i.addEventListener("sourceopen", this._onMediaSourceOpen),
                            i.addEventListener("sourceended", this._onMediaSourceEnded),
                            i.addEventListener("sourceclose", this._onMediaSourceClose),
                            r.src = self.URL.createObjectURL(i),
                            this._objectUrl = r.src
                        }
                    }
                    ,
                    t.onMediaDetaching = function() {
                        var e = this.media
                          , t = this.mediaSource
                          , r = this._objectUrl;
                        if (t) {
                            if (u.b.log("[buffer-controller]: media source detaching"),
                            "open" === t.readyState)
                                try {
                                    t.endOfStream()
                                } catch (e) {
                                    u.b.warn("[buffer-controller]: onMediaDetaching: " + e.message + " while calling endOfStream")
                                }
                            this.onBufferReset(),
                            t.removeEventListener("sourceopen", this._onMediaSourceOpen),
                            t.removeEventListener("sourceended", this._onMediaSourceEnded),
                            t.removeEventListener("sourceclose", this._onMediaSourceClose),
                            e && (r && self.URL.revokeObjectURL(r),
                            e.src === r ? (e.removeAttribute("src"),
                            e.load()) : u.b.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")),
                            this.mediaSource = null,
                            this.media = null,
                            this._objectUrl = null,
                            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal,
                            this.pendingTracks = {},
                            this.tracks = {}
                        }
                        this.hls.trigger(c.a.MEDIA_DETACHED, void 0)
                    }
                    ,
                    t.onBufferReset = function() {
                        var e = this;
                        this.getSourceBufferTypes().forEach((function(t) {
                            var r = e.sourceBuffer[t];
                            try {
                                r && (e.removeBufferListeners(t),
                                e.mediaSource && e.mediaSource.removeSourceBuffer(r),
                                e.sourceBuffer[t] = void 0)
                            } catch (e) {
                                u.b.warn("[buffer-controller]: Failed to reset the " + t + " buffer", e)
                            }
                        }
                        )),
                        this._initSourceBuffer()
                    }
                    ,
                    t.onBufferCodecs = function(e, t) {
                        var r = this
                          , i = this.getSourceBufferTypes().length;
                        Object.keys(t).forEach((function(e) {
                            if (i) {
                                var n = r.tracks[e];
                                if (n && "function" == typeof n.buffer.changeType) {
                                    var a = t[e]
                                      , o = a.codec
                                      , s = a.levelCodec
                                      , l = a.container;
                                    if ((n.levelCodec || n.codec).replace(ht, "$1") !== (s || o).replace(ht, "$1")) {
                                        var c = l + ";codecs=" + (s || o);
                                        r.appendChangeType(e, c)
                                    }
                                }
                            } else
                                r.pendingTracks[e] = t[e]
                        }
                        )),
                        i || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0),
                        this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
                    }
                    ,
                    t.appendChangeType = function(e, t) {
                        var r = this
                          , i = this.operationQueue
                          , n = {
                            execute: function() {
                                var n = r.sourceBuffer[e];
                                n && (u.b.log("[buffer-controller]: changing " + e + " sourceBuffer type to " + t),
                                n.changeType(t)),
                                i.shiftAndExecuteNext(e)
                            },
                            onStart: function() {},
                            onComplete: function() {},
                            onError: function(t) {
                                u.b.warn("[buffer-controller]: Failed to change " + e + " SourceBuffer type", t)
                            }
                        };
                        i.append(n, e)
                    }
                    ,
                    t.onBufferAppending = function(e, t) {
                        var r = this
                          , i = this.hls
                          , n = this.operationQueue
                          , a = this.tracks
                          , o = t.data
                          , s = t.type
                          , l = t.frag
                          , d = t.part
                          , f = t.chunkMeta
                          , p = f.buffering[s]
                          , g = self.performance.now();
                        p.start = g;
                        var v = l.stats.buffering
                          , y = d ? d.stats.buffering : null;
                        0 === v.start && (v.start = g),
                        y && 0 === y.start && (y.start = g);
                        var m = a.audio
                          , T = "audio" === s && 1 === f.id && "audio/mpeg" === (null == m ? void 0 : m.container)
                          , S = {
                            execute: function() {
                                if (p.executeStart = self.performance.now(),
                                T) {
                                    var e = r.sourceBuffer[s];
                                    if (e) {
                                        var t = l.start - e.timestampOffset;
                                        Math.abs(t) >= .1 && (u.b.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + l.start + " (delta: " + t + ") sn: " + l.sn + ")"),
                                        e.timestampOffset = l.start)
                                    }
                                }
                                r.appendExecutor(o, s)
                            },
                            onStart: function() {},
                            onComplete: function() {
                                var e = self.performance.now();
                                p.executeEnd = p.end = e,
                                0 === v.first && (v.first = e),
                                y && 0 === y.first && (y.first = e);
                                var t = r.sourceBuffer
                                  , i = {};
                                for (var n in t)
                                    i[n] = pe.getBuffered(t[n]);
                                r.appendError = 0,
                                r.hls.trigger(c.a.BUFFER_APPENDED, {
                                    type: s,
                                    frag: l,
                                    part: d,
                                    chunkMeta: f,
                                    parent: l.type,
                                    timeRanges: i
                                })
                            },
                            onError: function(e) {
                                u.b.error("[buffer-controller]: Error encountered while trying to append to the " + s + " SourceBuffer", e);
                                var t = {
                                    type: h.b.MEDIA_ERROR,
                                    parent: l.type,
                                    details: h.a.BUFFER_APPEND_ERROR,
                                    err: e,
                                    fatal: !1
                                };
                                e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = h.a.BUFFER_FULL_ERROR : (r.appendError++,
                                t.details = h.a.BUFFER_APPEND_ERROR,
                                r.appendError > i.config.appendErrorMaxRetry && (u.b.error("[buffer-controller]: Failed " + i.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"),
                                t.fatal = !0)),
                                i.trigger(c.a.ERROR, t)
                            }
                        };
                        n.append(S, s)
                    }
                    ,
                    t.onBufferFlushing = function(e, t) {
                        var r = this
                          , i = this.operationQueue
                          , n = function(e) {
                            return {
                                execute: r.removeExecutor.bind(r, e, t.startOffset, t.endOffset),
                                onStart: function() {},
                                onComplete: function() {
                                    r.hls.trigger(c.a.BUFFER_FLUSHED, {
                                        type: e
                                    })
                                },
                                onError: function(t) {
                                    u.b.warn("[buffer-controller]: Failed to remove from " + e + " SourceBuffer", t)
                                }
                            }
                        };
                        t.type ? i.append(n(t.type), t.type) : this.getSourceBufferTypes().forEach((function(e) {
                            i.append(n(e), e)
                        }
                        ))
                    }
                    ,
                    t.onFragParsed = function(e, t) {
                        var r = this
                          , i = t.frag
                          , n = t.part
                          , a = []
                          , o = n ? n.elementaryStreams : i.elementaryStreams;
                        o[f.a.AUDIOVIDEO] ? a.push("audiovideo") : (o[f.a.AUDIO] && a.push("audio"),
                        o[f.a.VIDEO] && a.push("video")),
                        0 === a.length && u.b.warn("Fragments must have at least one ElementaryStreamType set. type: " + i.type + " level: " + i.level + " sn: " + i.sn),
                        this.blockBuffers((function() {
                            var e = self.performance.now();
                            i.stats.buffering.end = e,
                            n && (n.stats.buffering.end = e);
                            var t = n ? n.stats : i.stats;
                            r.hls.trigger(c.a.FRAG_BUFFERED, {
                                frag: i,
                                part: n,
                                stats: t,
                                id: i.type
                            })
                        }
                        ), a)
                    }
                    ,
                    t.onFragChanged = function(e, t) {
                        this.flushBackBuffer()
                    }
                    ,
                    t.onBufferEos = function(e, t) {
                        var r = this;
                        this.getSourceBufferTypes().reduce((function(e, i) {
                            var n = r.sourceBuffer[i];
                            return t.type && t.type !== i || n && !n.ended && (n.ended = !0,
                            u.b.log("[buffer-controller]: " + i + " sourceBuffer now EOS")),
                            e && !(n && !n.ended)
                        }
                        ), !0) && this.blockBuffers((function() {
                            var e = r.mediaSource;
                            e && "open" === e.readyState && e.endOfStream()
                        }
                        ))
                    }
                    ,
                    t.onLevelUpdated = function(e, t) {
                        var r = t.details;
                        r.fragments.length && (this.details = r,
                        this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
                    }
                    ,
                    t.flushBackBuffer = function() {
                        var e = this.hls
                          , t = this.details
                          , r = this.media
                          , i = this.sourceBuffer;
                        if (r && null !== t) {
                            var n = this.getSourceBufferTypes();
                            if (n.length) {
                                var a = t.live && null !== e.config.liveBackBufferLength ? e.config.liveBackBufferLength : e.config.backBufferLength;
                                if (Object(o.a)(a) && !(a < 0)) {
                                    var s = r.currentTime
                                      , l = t.levelTargetDuration
                                      , h = Math.max(a, l)
                                      , u = Math.floor(s / l) * l - h;
                                    n.forEach((function(r) {
                                        var n = i[r];
                                        if (n) {
                                            var a = pe.getBuffered(n);
                                            a.length > 0 && u > a.start(0) && (e.trigger(c.a.BACK_BUFFER_REACHED, {
                                                bufferEnd: u
                                            }),
                                            t.live && e.trigger(c.a.LIVE_BACK_BUFFER_REACHED, {
                                                bufferEnd: u
                                            }),
                                            e.trigger(c.a.BUFFER_FLUSHING, {
                                                startOffset: 0,
                                                endOffset: u,
                                                type: r
                                            }))
                                        }
                                    }
                                    ))
                                }
                            }
                        }
                    }
                    ,
                    t.updateMediaElementDuration = function() {
                        if (this.details && this.media && this.mediaSource && "open" === this.mediaSource.readyState) {
                            var e = this.details
                              , t = this.hls
                              , r = this.media
                              , i = this.mediaSource
                              , n = e.fragments[0].start + e.totalduration
                              , a = r.duration
                              , s = Object(o.a)(i.duration) ? i.duration : 0;
                            e.live && t.config.liveDurationInfinity ? (u.b.log("[buffer-controller]: Media Source duration is set to Infinity"),
                            i.duration = 1 / 0,
                            this.updateSeekableRange(e)) : (n > s && n > a || !Object(o.a)(a)) && (u.b.log("[buffer-controller]: Updating Media Source duration to " + n.toFixed(3)),
                            i.duration = n)
                        }
                    }
                    ,
                    t.updateSeekableRange = function(e) {
                        var t = this.mediaSource
                          , r = e.fragments;
                        if (r.length && e.live && null != t && t.setLiveSeekableRange) {
                            var i = Math.max(0, r[0].start)
                              , n = Math.max(i, i + e.totalduration);
                            t.setLiveSeekableRange(i, n)
                        }
                    }
                    ,
                    t.checkPendingTracks = function() {
                        var e = this.bufferCodecEventsExpected
                          , t = this.operationQueue
                          , r = this.pendingTracks
                          , i = Object.keys(r).length;
                        if (i && !e || 2 === i) {
                            this.createSourceBuffers(r),
                            this.pendingTracks = {};
                            var n = this.getSourceBufferTypes();
                            if (0 === n.length)
                                return void this.hls.trigger(c.a.ERROR, {
                                    type: h.b.MEDIA_ERROR,
                                    details: h.a.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                    fatal: !0,
                                    reason: "could not create source buffer for media codec(s)"
                                });
                            n.forEach((function(e) {
                                t.executeNext(e)
                            }
                            ))
                        }
                    }
                    ,
                    t.createSourceBuffers = function(e) {
                        var t = this.sourceBuffer
                          , r = this.mediaSource;
                        if (!r)
                            throw Error("createSourceBuffers called when mediaSource was null");
                        var i = 0;
                        for (var n in e)
                            if (!t[n]) {
                                var a = e[n];
                                if (!a)
                                    throw Error("source buffer exists for track " + n + ", however track does not");
                                var o = a.levelCodec || a.codec
                                  , s = a.container + ";codecs=" + o;
                                u.b.log("[buffer-controller]: creating sourceBuffer(" + s + ")");
                                try {
                                    var l = t[n] = r.addSourceBuffer(s)
                                      , d = n;
                                    this.addBufferListener(d, "updatestart", this._onSBUpdateStart),
                                    this.addBufferListener(d, "updateend", this._onSBUpdateEnd),
                                    this.addBufferListener(d, "error", this._onSBUpdateError),
                                    this.tracks[n] = {
                                        buffer: l,
                                        codec: o,
                                        container: a.container,
                                        levelCodec: a.levelCodec,
                                        id: a.id
                                    },
                                    i++
                                } catch (e) {
                                    u.b.error("[buffer-controller]: error while trying to add sourceBuffer: " + e.message),
                                    this.hls.trigger(c.a.ERROR, {
                                        type: h.b.MEDIA_ERROR,
                                        details: h.a.BUFFER_ADD_CODEC_ERROR,
                                        fatal: !1,
                                        error: e,
                                        mimeType: s
                                    })
                                }
                            }
                        i && this.hls.trigger(c.a.BUFFER_CREATED, {
                            tracks: this.tracks
                        })
                    }
                    ,
                    t._onSBUpdateStart = function(e) {
                        this.operationQueue.current(e).onStart()
                    }
                    ,
                    t._onSBUpdateEnd = function(e) {
                        var t = this.operationQueue;
                        t.current(e).onComplete(),
                        t.shiftAndExecuteNext(e)
                    }
                    ,
                    t._onSBUpdateError = function(e, t) {
                        u.b.error("[buffer-controller]: " + e + " SourceBuffer error", t),
                        this.hls.trigger(c.a.ERROR, {
                            type: h.b.MEDIA_ERROR,
                            details: h.a.BUFFER_APPENDING_ERROR,
                            fatal: !1
                        });
                        var r = this.operationQueue.current(e);
                        r && r.onError(t)
                    }
                    ,
                    t.removeExecutor = function(e, t, r) {
                        var i = this.media
                          , n = this.mediaSource
                          , a = this.operationQueue
                          , s = this.sourceBuffer[e];
                        if (!i || !n || !s)
                            return u.b.warn("[buffer-controller]: Attempting to remove from the " + e + " SourceBuffer, but it does not exist"),
                            void a.shiftAndExecuteNext(e);
                        var l = Object(o.a)(i.duration) ? i.duration : 1 / 0
                          , c = Object(o.a)(n.duration) ? n.duration : 1 / 0
                          , h = Math.max(0, t)
                          , d = Math.min(r, l, c);
                        d > h ? (u.b.log("[buffer-controller]: Removing [" + h + "," + d + "] from the " + e + " SourceBuffer"),
                        s.remove(h, d)) : a.shiftAndExecuteNext(e)
                    }
                    ,
                    t.appendExecutor = function(e, t) {
                        var r = this.operationQueue
                          , i = this.sourceBuffer[t];
                        if (!i)
                            return u.b.warn("[buffer-controller]: Attempting to append to the " + t + " SourceBuffer, but it does not exist"),
                            void r.shiftAndExecuteNext(t);
                        i.ended = !1,
                        i.appendBuffer(e)
                    }
                    ,
                    t.blockBuffers = function(e, t) {
                        var r = this;
                        if (void 0 === t && (t = this.getSourceBufferTypes()),
                        !t.length)
                            return u.b.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"),
                            void Promise.resolve(e);
                        var i = this.operationQueue
                          , n = t.map((function(e) {
                            return i.appendBlocker(e)
                        }
                        ));
                        Promise.all(n).then((function() {
                            e(),
                            t.forEach((function(e) {
                                var t = r.sourceBuffer[e];
                                t && t.updating || i.shiftAndExecuteNext(e)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    t.getSourceBufferTypes = function() {
                        return Object.keys(this.sourceBuffer)
                    }
                    ,
                    t.addBufferListener = function(e, t, r) {
                        var i = this.sourceBuffer[e];
                        if (i) {
                            var n = r.bind(this, e);
                            this.listeners[e].push({
                                event: t,
                                listener: n
                            }),
                            i.addEventListener(t, n)
                        }
                    }
                    ,
                    t.removeBufferListeners = function(e) {
                        var t = this.sourceBuffer[e];
                        t && this.listeners[e].forEach((function(e) {
                            t.removeEventListener(e.event, e.listener)
                        }
                        ))
                    }
                    ,
                    e
                }()
                  , dt = function() {
                    function e(e) {
                        this.autoLevelCapping = void 0,
                        this.firstLevel = void 0,
                        this.media = void 0,
                        this.restrictedLevels = void 0,
                        this.timer = void 0,
                        this.hls = void 0,
                        this.streamController = void 0,
                        this.clientRect = void 0,
                        this.hls = e,
                        this.autoLevelCapping = Number.POSITIVE_INFINITY,
                        this.firstLevel = -1,
                        this.media = null,
                        this.restrictedLevels = [],
                        this.timer = void 0,
                        this.clientRect = null,
                        this.registerListeners()
                    }
                    var t = e.prototype;
                    return t.setStreamController = function(e) {
                        this.streamController = e
                    }
                    ,
                    t.destroy = function() {
                        this.unregisterListener(),
                        this.hls.config.capLevelToPlayerSize && this.stopCapping(),
                        this.media = null,
                        this.clientRect = null,
                        this.hls = this.streamController = null
                    }
                    ,
                    t.registerListeners = function() {
                        var e = this.hls;
                        e.on(c.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
                        e.on(c.a.MEDIA_ATTACHING, this.onMediaAttaching, this),
                        e.on(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.on(c.a.BUFFER_CODECS, this.onBufferCodecs, this),
                        e.on(c.a.MEDIA_DETACHING, this.onMediaDetaching, this)
                    }
                    ,
                    t.unregisterListener = function() {
                        var e = this.hls;
                        e.off(c.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
                        e.off(c.a.MEDIA_ATTACHING, this.onMediaAttaching, this),
                        e.off(c.a.MANIFEST_PARSED, this.onManifestParsed, this),
                        e.off(c.a.BUFFER_CODECS, this.onBufferCodecs, this),
                        e.off(c.a.MEDIA_DETACHING, this.onMediaDetaching, this)
                    }
                    ,
                    t.onFpsDropLevelCapping = function(t, r) {
                        e.isLevelAllowed(r.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(r.droppedLevel)
                    }
                    ,
                    t.onMediaAttaching = function(e, t) {
                        this.media = t.media instanceof HTMLVideoElement ? t.media : null
                    }
                    ,
                    t.onManifestParsed = function(e, t) {
                        var r = this.hls;
                        this.restrictedLevels = [],
                        this.firstLevel = t.firstLevel,
                        r.config.capLevelToPlayerSize && t.video && this.startCapping()
                    }
                    ,
                    t.onBufferCodecs = function(e, t) {
                        this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
                    }
                    ,
                    t.onMediaDetaching = function() {
                        this.stopCapping()
                    }
                    ,
                    t.detectPlayerSize = function() {
                        if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                            var e = this.hls.levels;
                            if (e.length) {
                                var t = this.hls;
                                t.autoLevelCapping = this.getMaxLevel(e.length - 1),
                                t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(),
                                this.autoLevelCapping = t.autoLevelCapping
                            }
                        }
                    }
                    ,
                    t.getMaxLevel = function(t) {
                        var r = this
                          , i = this.hls.levels;
                        if (!i.length)
                            return -1;
                        var n = i.filter((function(i, n) {
                            return e.isLevelAllowed(n, r.restrictedLevels) && n <= t
                        }
                        ));
                        return this.clientRect = null,
                        e.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
                    }
                    ,
                    t.startCapping = function() {
                        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY,
                        this.hls.firstLevel = this.getMaxLevel(this.firstLevel),
                        self.clearInterval(this.timer),
                        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3),
                        this.detectPlayerSize())
                    }
                    ,
                    t.stopCapping = function() {
                        this.restrictedLevels = [],
                        this.firstLevel = -1,
                        this.autoLevelCapping = Number.POSITIVE_INFINITY,
                        this.timer && (self.clearInterval(this.timer),
                        this.timer = void 0)
                    }
                    ,
                    t.getDimensions = function() {
                        if (this.clientRect)
                            return this.clientRect;
                        var e = this.media
                          , t = {
                            width: 0,
                            height: 0
                        };
                        if (e) {
                            var r = e.getBoundingClientRect();
                            t.width = r.width,
                            t.height = r.height,
                            t.width || t.height || (t.width = r.right - r.left || e.width || 0,
                            t.height = r.bottom - r.top || e.height || 0)
                        }
                        return this.clientRect = t,
                        t
                    }
                    ,
                    e.isLevelAllowed = function(e, t) {
                        return void 0 === t && (t = []),
                        -1 === t.indexOf(e)
                    }
                    ,
                    e.getMaxLevelByMediaSize = function(e, t, r) {
                        if (!e || !e.length)
                            return -1;
                        for (var i, n, a = e.length - 1, o = 0; o < e.length; o += 1) {
                            var s = e[o];
                            if ((s.width >= t || s.height >= r) && (i = s,
                            !(n = e[o + 1]) || i.width !== n.width || i.height !== n.height)) {
                                a = o;
                                break
                            }
                        }
                        return a
                    }
                    ,
                    n()(e, [{
                        key: "mediaWidth",
                        get: function() {
                            return this.getDimensions().width * e.contentScaleFactor
                        }
                    }, {
                        key: "mediaHeight",
                        get: function() {
                            return this.getDimensions().height * e.contentScaleFactor
                        }
                    }], [{
                        key: "contentScaleFactor",
                        get: function() {
                            var e = 1;
                            try {
                                e = self.devicePixelRatio
                            } catch (e) {}
                            return e
                        }
                    }])
                }()
                  , ft = function() {
                    function e(e) {
                        this.hls = void 0,
                        this.isVideoPlaybackQualityAvailable = !1,
                        this.timer = void 0,
                        this.media = null,
                        this.lastTime = void 0,
                        this.lastDroppedFrames = 0,
                        this.lastDecodedFrames = 0,
                        this.streamController = void 0,
                        this.hls = e,
                        this.registerListeners()
                    }
                    var t = e.prototype;
                    return t.setStreamController = function(e) {
                        this.streamController = e
                    }
                    ,
                    t.registerListeners = function() {
                        this.hls.on(c.a.MEDIA_ATTACHING, this.onMediaAttaching, this)
                    }
                    ,
                    t.unregisterListeners = function() {
                        this.hls.off(c.a.MEDIA_ATTACHING, this.onMediaAttaching)
                    }
                    ,
                    t.destroy = function() {
                        this.timer && clearInterval(this.timer),
                        this.unregisterListeners(),
                        this.isVideoPlaybackQualityAvailable = !1,
                        this.media = null
                    }
                    ,
                    t.onMediaAttaching = function(e, t) {
                        var r = this.hls.config;
                        if (r.capLevelOnFPSDrop) {
                            var i = t.media instanceof self.HTMLVideoElement ? t.media : null;
                            this.media = i,
                            i && "function" == typeof i.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0),
                            self.clearInterval(this.timer),
                            this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod)
                        }
                    }
                    ,
                    t.checkFPS = function(e, t, r) {
                        var i = performance.now();
                        if (t) {
                            if (this.lastTime) {
                                var n = i - this.lastTime
                                  , a = r - this.lastDroppedFrames
                                  , o = t - this.lastDecodedFrames
                                  , s = 1e3 * a / n
                                  , l = this.hls;
                                if (l.trigger(c.a.FPS_DROP, {
                                    currentDropped: a,
                                    currentDecoded: o,
                                    totalDroppedFrames: r
                                }),
                                s > 0 && a > l.config.fpsDroppedMonitoringThreshold * o) {
                                    var h = l.currentLevel;
                                    u.b.warn("drop FPS ratio greater than max allowed value for currentLevel: " + h),
                                    h > 0 && (-1 === l.autoLevelCapping || l.autoLevelCapping >= h) && (h -= 1,
                                    l.trigger(c.a.FPS_DROP_LEVEL_CAPPING, {
                                        level: h,
                                        droppedLevel: l.currentLevel
                                    }),
                                    l.autoLevelCapping = h,
                                    this.streamController.nextLevelSwitch())
                                }
                            }
                            this.lastTime = i,
                            this.lastDroppedFrames = r,
                            this.lastDecodedFrames = t
                        }
                    }
                    ,
                    t.checkFPSInterval = function() {
                        var e = this.media;
                        if (e)
                            if (this.isVideoPlaybackQualityAvailable) {
                                var t = e.getVideoPlaybackQuality();
                                this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
                            } else
                                this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
                    }
                    ,
                    e
                }()
                  , pt = r(25)
                  , gt = r.n(pt)
                  , vt = r(22)
                  , yt = r.n(vt)
                  , mt = r(17)
                  , Tt = /^age:\s*[\d.]+\s*$/m
                  , St = function() {
                    function e(e) {
                        this.xhrSetup = void 0,
                        this.requestTimeout = void 0,
                        this.retryTimeout = void 0,
                        this.retryDelay = void 0,
                        this.config = null,
                        this.callbacks = null,
                        this.context = void 0,
                        this.loader = null,
                        this.stats = void 0,
                        this.xhrSetup = e ? e.xhrSetup : null,
                        this.stats = new mt.a,
                        this.retryDelay = 0
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this.callbacks = null,
                        this.abortInternal(),
                        this.loader = null,
                        this.config = null
                    }
                    ,
                    t.abortInternal = function() {
                        var e = this.loader;
                        self.clearTimeout(this.requestTimeout),
                        self.clearTimeout(this.retryTimeout),
                        e && (e.onreadystatechange = null,
                        e.onprogress = null,
                        4 !== e.readyState && (this.stats.aborted = !0,
                        e.abort()))
                    }
                    ,
                    t.abort = function() {
                        var e;
                        this.abortInternal(),
                        null !== (e = this.callbacks) && void 0 !== e && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                    }
                    ,
                    t.load = function() {
                        var e = gt()(yt.a.mark((function e(t, r, i) {
                            var n;
                            return yt.a.wrap((function(e) {
                                for (; ; )
                                    switch (e.prev = e.next) {
                                    case 0:
                                        if (!this.stats.loading.start) {
                                            e.next = 2;
                                            break
                                        }
                                        throw new Error("Loader can only be used once.");
                                    case 2:
                                        if (this.stats.loading.start = self.performance.now(),
                                        this.context = t,
                                        this.config = r,
                                        this.callbacks = i,
                                        this.retryDelay = r.retryDelay,
                                        !r.proxy) {
                                            e.next = 15;
                                            break
                                        }
                                        return e.next = 10,
                                        r.proxy(t.url);
                                    case 10:
                                        if (!(n = e.sent)) {
                                            e.next = 15;
                                            break
                                        }
                                        return this.stats.loading.end = self.performance.now(),
                                        this.callbacks.onSuccess({
                                            url: t.url,
                                            data: n
                                        }, this.stats, this.context, null),
                                        e.abrupt("return");
                                    case 15:
                                        this.loadInternal();
                                    case 16:
                                    case "end":
                                        return e.stop()
                                    }
                            }
                            ), e, this)
                        }
                        )));
                        return function(t, r, i) {
                            return e.apply(this, arguments)
                        }
                    }(),
                    t.loadInternal = function() {
                        var e = this.config
                          , t = this.context;
                        if (e) {
                            var r = this.loader = new self.XMLHttpRequest
                              , i = this.stats;
                            i.loading.first = 0,
                            i.loaded = 0;
                            var n = this.xhrSetup;
                            try {
                                if (n)
                                    try {
                                        n(r, t.url)
                                    } catch (e) {
                                        r.open("GET", t.url, !0),
                                        n(r, t.url)
                                    }
                                r.readyState || r.open("GET", t.url, !0)
                            } catch (e) {
                                return void this.callbacks.onError({
                                    code: r.status,
                                    text: e.message
                                }, t, r)
                            }
                            t.rangeEnd && r.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)),
                            r.onreadystatechange = this.readystatechange.bind(this),
                            r.onprogress = this.loadprogress.bind(this),
                            r.responseType = t.responseType,
                            self.clearTimeout(this.requestTimeout),
                            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e.timeout),
                            r.send()
                        }
                    }
                    ,
                    t.readystatechange = function() {
                        var e = this.context
                          , t = this.loader
                          , r = this.stats;
                        if (e && t) {
                            var i = t.readyState
                              , n = this.config;
                            if (!r.aborted && i >= 2)
                                if (self.clearTimeout(this.requestTimeout),
                                0 === r.loading.first && (r.loading.first = Math.max(self.performance.now(), r.loading.start)),
                                4 === i) {
                                    t.onreadystatechange = null,
                                    t.onprogress = null;
                                    var a = t.status;
                                    if (a >= 200 && a < 300) {
                                        var o, s;
                                        if (r.loading.end = Math.max(self.performance.now(), r.loading.first),
                                        s = "arraybuffer" === e.responseType ? (o = t.response).byteLength : (o = t.responseText).length,
                                        r.loaded = r.total = s,
                                        !this.callbacks)
                                            return;
                                        var l = this.callbacks.onProgress;
                                        if (l && l(r, e, o, t),
                                        !this.callbacks)
                                            return;
                                        var c = {
                                            url: t.responseURL,
                                            data: o
                                        };
                                        this.callbacks.onSuccess(c, r, e, t)
                                    } else
                                        r.retry >= n.maxRetry || a >= 400 && a < 499 ? (u.b.error(a + " while loading " + e.url),
                                        this.callbacks.onError({
                                            code: a,
                                            text: t.statusText
                                        }, e, t)) : (u.b.warn(a + " while loading " + e.url + ", retrying in " + this.retryDelay + "..."),
                                        this.abortInternal(),
                                        this.loader = null,
                                        self.clearTimeout(this.retryTimeout),
                                        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay),
                                        this.retryDelay = Math.min(2 * this.retryDelay, n.maxRetryDelay),
                                        r.retry++)
                                } else
                                    self.clearTimeout(this.requestTimeout),
                                    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout)
                        }
                    }
                    ,
                    t.loadtimeout = function() {
                        u.b.warn("timeout while loading " + this.context.url);
                        var e = this.callbacks;
                        e && (this.abortInternal(),
                        e.onTimeout(this.stats, this.context, this.loader))
                    }
                    ,
                    t.loadprogress = function(e) {
                        var t = this.stats;
                        t.loaded = e.loaded,
                        e.lengthComputable && (t.total = e.total)
                    }
                    ,
                    t.getCacheAge = function() {
                        var e = null;
                        if (this.loader && Tt.test(this.loader.getAllResponseHeaders())) {
                            var t = this.loader.getResponseHeader("age");
                            e = t ? parseFloat(t) : null
                        }
                        return e
                    }
                    ,
                    e
                }()
                  , It = function() {
                    function e(e) {
                        this.fetchSetup = void 0,
                        this.requestTimeout = void 0,
                        this.request = void 0,
                        this.response = void 0,
                        this.controller = void 0,
                        this.context = void 0,
                        this.config = null,
                        this.callbacks = null,
                        this.stats = void 0,
                        this.loader = null,
                        this.fetchSetup = e.fetchSetup || bt,
                        this.controller = new self.AbortController,
                        this.stats = new mt.a
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this.loader = this.callbacks = null,
                        this.abortInternal()
                    }
                    ,
                    t.abortInternal = function() {
                        this.controller && !this.stats.loading.end && (this.stats.aborted = !0,
                        this.controller.abort())
                    }
                    ,
                    t.abort = function() {
                        var e;
                        this.abortInternal(),
                        null !== (e = this.callbacks) && void 0 !== e && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                    }
                    ,
                    t.setHighWaterMark = function(e) {
                        this.config && (this.config.highWaterMark = e)
                    }
                    ,
                    t.load = function() {
                        var e = gt()(yt.a.mark((function e(t, r, i) {
                            var n, a, s, l, c, h, u, d = this;
                            return yt.a.wrap((function(e) {
                                for (; ; )
                                    switch (e.prev = e.next) {
                                    case 0:
                                        if (!(n = this.stats).loading.start) {
                                            e.next = 3;
                                            break
                                        }
                                        throw new Error("Loader can only be used once.");
                                    case 3:
                                        if (n.loading.start = self.performance.now(),
                                        a = Pt(t, this.controller.signal),
                                        s = i.onProgress,
                                        l = "arraybuffer" === t.responseType,
                                        c = l ? "byteLength" : "length",
                                        this.context = t,
                                        this.config = r,
                                        this.callbacks = i,
                                        self.clearTimeout(this.requestTimeout),
                                        !r.proxy) {
                                            e.next = 20;
                                            break
                                        }
                                        return e.next = 15,
                                        r.proxy(t.url);
                                    case 15:
                                        if (!(h = e.sent)) {
                                            e.next = 20;
                                            break
                                        }
                                        return this.stats.loading.end = self.performance.now(),
                                        this.callbacks.onSuccess({
                                            url: t.url,
                                            data: h
                                        }, this.stats, this.context, null),
                                        e.abrupt("return");
                                    case 20:
                                        this.request = this.fetchSetup(t, a),
                                        this.requestTimeout = self.setTimeout((function() {
                                            d.abortInternal(),
                                            i.onTimeout(n, t, d.response)
                                        }
                                        ), r.timeout),
                                        u = s && Object(o.a)(r.highWaterMark),
                                        self.fetch(this.request).then((function(e) {
                                            if (d.response = d.loader = e,
                                            !e.ok) {
                                                var r = e.status
                                                  , i = e.statusText;
                                                throw new Et(i || "fetch, bad network response",r,e)
                                            }
                                            return n.loading.first = Math.max(self.performance.now(), n.loading.start),
                                            n.total = parseInt(e.headers.get("Content-Length") || "0"),
                                            u ? d.loadProgressively(e, n, t, s) : l ? e.arrayBuffer() : e.text()
                                        }
                                        )).then((function(e) {
                                            var a = d.response;
                                            self.clearTimeout(d.requestTimeout),
                                            n.loading.end = Math.max(self.performance.now(), n.loading.first),
                                            u || (n.loaded = n.total = e[c]);
                                            var l = {
                                                url: a.url,
                                                data: e
                                            };
                                            s && !Object(o.a)(r.highWaterMark) && s(n, t, e, a),
                                            i.onSuccess(l, n, t, a)
                                        }
                                        )).catch((function(e) {
                                            if (self.clearTimeout(d.requestTimeout),
                                            !n.aborted) {
                                                var r = (null == e ? void 0 : e.code) || 0;
                                                i.onError({
                                                    code: r,
                                                    text: null == e ? void 0 : e.message
                                                }, t, null == e ? void 0 : e.details)
                                            }
                                        }
                                        ));
                                    case 24:
                                    case "end":
                                        return e.stop()
                                    }
                            }
                            ), e, this)
                        }
                        )));
                        return function(t, r, i) {
                            return e.apply(this, arguments)
                        }
                    }(),
                    t.getCacheAge = function() {
                        var e = null;
                        if (this.response) {
                            var t = this.response.headers.get("age");
                            e = t ? parseFloat(t) : null
                        }
                        return e
                    }
                    ,
                    t.loadProgressively = function(e, t, r, i) {
                        var n = this
                          , a = new it.a
                          , o = e.body.getReader();
                        return function s() {
                            return o.read().then((function(o) {
                                if (o.done)
                                    return a.dataLength && i(t, r, a.flush(), e),
                                    Promise.resolve(new ArrayBuffer(0));
                                var l = o.value
                                  , c = l.length;
                                t.loaded += c;
                                var h = n.config.highWaterMark
                                  , u = void 0 === h ? De : h;
                                return c < u || a.dataLength ? (a.push(l),
                                a.dataLength >= u && i(t, r, a.flush(), e)) : i(t, r, l, e),
                                s()
                            }
                            )).catch((function() {
                                return Promise.reject()
                            }
                            ))
                        }()
                    }
                    ,
                    e
                }();
                function Pt(e, t) {
                    var r = {
                        method: "GET",
                        mode: "cors",
                        credentials: "same-origin",
                        signal: t
                    };
                    return e.rangeEnd && (r.headers = new self.Headers({
                        Range: "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1)
                    })),
                    r
                }
                function bt(e, t) {
                    return new self.Request(e.url,t)
                }
                var Et = function(e) {
                    function t(t, r, i) {
                        var n;
                        return (n = e.call(this, t) || this).code = void 0,
                        n.details = void 0,
                        n.code = r,
                        n.details = i,
                        n
                    }
                    return Q()(t, e),
                    t
                }(Ee()(Error))
                  , Dt = It
                  , kt = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
                function Ct(e, t) {
                    var r = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var i = Object.getOwnPropertySymbols(e);
                        t && (i = i.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }
                        ))),
                        r.push.apply(r, i)
                    }
                    return r
                }
                function Lt(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var r = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? Ct(Object(r), !0).forEach((function(t) {
                            l()(e, t, r[t])
                        }
                        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ct(Object(r)).forEach((function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                        }
                        ))
                    }
                    return e
                }
                var wt = Lt(Lt({
                    m3u8PostProcessor: null,
                    chachaParam: null,
                    autoStartLoad: !0,
                    startPosition: -1,
                    defaultAudioCodec: void 0,
                    debug: !1,
                    capLevelOnFPSDrop: !1,
                    capLevelToPlayerSize: !1,
                    initialLiveManifestSize: 1,
                    maxBufferLength: 30,
                    backBufferLength: 1 / 0,
                    maxBufferSize: 6e7,
                    maxBufferHole: .1,
                    highBufferWatchdogPeriod: 2,
                    nudgeOffset: .1,
                    nudgeMaxRetry: 5,
                    maxFragLookUpTolerance: .25,
                    liveSyncDurationCount: 3,
                    liveMaxLatencyDurationCount: 1 / 0,
                    liveSyncDuration: void 0,
                    liveMaxLatencyDuration: void 0,
                    maxLiveSyncPlaybackRate: 1,
                    liveDurationInfinity: !1,
                    liveBackBufferLength: null,
                    maxMaxBufferLength: 600,
                    enableWorker: !0,
                    enableSoftwareAES: !0,
                    manifestLoadingTimeOut: 1e4,
                    manifestLoadingMaxRetry: 1,
                    manifestLoadingRetryDelay: 1e3,
                    manifestLoadingMaxRetryTimeout: 64e3,
                    startLevel: void 0,
                    levelLoadingTimeOut: 1e4,
                    levelLoadingMaxRetry: 4,
                    levelLoadingRetryDelay: 1e3,
                    levelLoadingMaxRetryTimeout: 64e3,
                    fragLoadingTimeOut: 2e4,
                    fragLoadingMaxRetry: 6,
                    fragLoadingRetryDelay: 1e3,
                    fragLoadingMaxRetryTimeout: 64e3,
                    startFragPrefetch: !1,
                    fpsDroppedMonitoringPeriod: 5e3,
                    fpsDroppedMonitoringThreshold: .2,
                    appendErrorMaxRetry: 3,
                    loader: St,
                    fLoader: void 0,
                    pLoader: void 0,
                    xhrSetup: void 0,
                    licenseXhrSetup: void 0,
                    licenseResponseCallback: void 0,
                    abrController: rt,
                    bufferController: ut,
                    capLevelController: dt,
                    fpsController: ft,
                    stretchShortVideoTrack: !1,
                    maxAudioFramesDrift: 1,
                    forceKeyFrameOnDiscontinuity: !0,
                    abrEwmaFastLive: 3,
                    abrEwmaSlowLive: 9,
                    abrEwmaFastVoD: 3,
                    abrEwmaSlowVoD: 9,
                    abrEwmaDefaultEstimate: 5e5,
                    abrBandWidthFactor: .95,
                    abrBandWidthUpFactor: .7,
                    abrMaxWithRealBitrate: !1,
                    maxStarvationDelay: 4,
                    maxLoadingDelay: 4,
                    minAutoBitrate: 0,
                    emeEnabled: !1,
                    licenseUrl: void 0,
                    drmSystemOptions: {},
                    requestMediaKeySystemAccessFunc: kt,
                    testBandwidth: !0,
                    progressive: !1,
                    lowLatencyMode: !1,
                    useSBRWorkaround: !1
                }, {
                    cueHandler: st.a,
                    enableCEA708Captions: !1,
                    enableWebVTT: !1,
                    enableIMSC1: !1,
                    captionsTextTrack1Label: "English",
                    captionsTextTrack1LanguageCode: "en",
                    captionsTextTrack2Label: "Spanish",
                    captionsTextTrack2LanguageCode: "es",
                    captionsTextTrack3Label: "Unknown CC",
                    captionsTextTrack3LanguageCode: "",
                    captionsTextTrack4Label: "Unknown CC",
                    captionsTextTrack4LanguageCode: "",
                    renderTextTracksNatively: !0
                }), {}, {
                    subtitleStreamController: void 0,
                    subtitleTrackController: void 0,
                    timelineController: void 0,
                    audioStreamController: nt,
                    audioTrackController: at,
                    emeController: void 0
                });
                function Rt(e) {
                    var t = e.loader;
                    t !== Dt && t !== St ? (u.b.log("[config]: Custom loader detected, cannot enable progressive streaming"),
                    e.progressive = !1) : function() {
                        if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
                            try {
                                return new self.ReadableStream({}),
                                !0
                            } catch (e) {}
                        return !1
                    }() && (e.loader = Dt,
                    e.progressive = !0,
                    e.enableSoftwareAES = !0,
                    u.b.log("[config]: Progressive streaming enabled, using FetchLoader"))
                }
                var At = r(12)
                  , _t = function() {
                    function e(t) {
                        void 0 === t && (t = {}),
                        this.config = void 0,
                        this.userConfig = void 0,
                        this.coreComponents = void 0,
                        this.networkControllers = void 0,
                        this._emitter = new Qe.EventEmitter,
                        this._autoLevelCapping = void 0,
                        this.abrController = void 0,
                        this.bufferController = void 0,
                        this.capLevelController = void 0,
                        this.latencyController = void 0,
                        this.levelController = void 0,
                        this.streamController = void 0,
                        this.audioTrackController = void 0,
                        this.subtitleTrackController = void 0,
                        this.emeController = void 0,
                        this._media = null,
                        this.url = null;
                        var r = this.config = function(e, t) {
                            if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration))
                                throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                            if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount))
                                throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                            if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration))
                                throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                            return W()({}, e, t)
                        }(e.DefaultConfig, t);
                        this.userConfig = t,
                        Object(u.a)(r.debug),
                        this._autoLevelCapping = -1,
                        r.progressive && Rt(r);
                        var i = r.abrController
                          , n = r.bufferController
                          , a = r.capLevelController
                          , o = r.fpsController
                          , s = this.abrController = new i(this)
                          , l = this.bufferController = new n(this)
                          , c = this.capLevelController = new a(this)
                          , h = new o(this)
                          , d = new N(this)
                          , f = new G(this)
                          , p = new K(this)
                          , g = this.levelController = new se(this)
                          , v = new ce(this)
                          , y = this.streamController = new $e(this,v);
                        c.setStreamController(y),
                        h.setStreamController(y);
                        var m = [g, y];
                        this.networkControllers = m;
                        var T = [d, f, s, l, c, h, p, v];
                        this.audioTrackController = this.createController(r.audioTrackController, null, m),
                        this.createController(r.audioStreamController, v, m),
                        this.subtitleTrackController = this.createController(r.subtitleTrackController, null, m),
                        this.createController(r.subtitleStreamController, v, m),
                        this.createController(r.timelineController, null, T),
                        this.emeController = this.createController(r.emeController, null, T),
                        this.latencyController = this.createController(V, null, T),
                        this.coreComponents = T,
                        r.chachaParam && (this.chachaParam = r.chachaParam)
                    }
                    e.isSupported = function() {
                        return function() {
                            var e = Ve();
                            if (!e)
                                return !1;
                            var t = je()
                              , r = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"')
                              , i = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
                            return !!r && !!i
                        }()
                    }
                    ;
                    var t = e.prototype;
                    return t.setHighWaterMark = function(e) {
                        var t, r;
                        null === (t = this.streamController) || void 0 === t || null === (r = t.fragmentLoader) || void 0 === r || r.setHighWaterMark(e)
                    }
                    ,
                    t.createController = function(e, t, r) {
                        if (e) {
                            var i = t ? new e(this,t) : new e(this);
                            return r && r.push(i),
                            i
                        }
                        return null
                    }
                    ,
                    t.on = function(e, t, r) {
                        void 0 === r && (r = this),
                        this._emitter.on(e, t, r)
                    }
                    ,
                    t.once = function(e, t, r) {
                        void 0 === r && (r = this),
                        this._emitter.once(e, t, r)
                    }
                    ,
                    t.removeAllListeners = function(e) {
                        this._emitter.removeAllListeners(e)
                    }
                    ,
                    t.off = function(e, t, r, i) {
                        void 0 === r && (r = this),
                        this._emitter.off(e, t, r, i)
                    }
                    ,
                    t.listeners = function(e) {
                        return this._emitter.listeners(e)
                    }
                    ,
                    t.emit = function(e, t, r) {
                        return this._emitter.emit(e, t, r)
                    }
                    ,
                    t.trigger = function(e, t) {
                        if (this.config.debug)
                            return this.emit(e, e, t);
                        try {
                            return this.emit(e, e, t)
                        } catch (t) {
                            u.b.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t),
                            this.trigger(c.a.ERROR, {
                                type: h.b.OTHER_ERROR,
                                details: h.a.INTERNAL_EXCEPTION,
                                fatal: !1,
                                event: e,
                                error: t
                            })
                        }
                        return !1
                    }
                    ,
                    t.listenerCount = function(e) {
                        return this._emitter.listenerCount(e)
                    }
                    ,
                    t.destroy = function() {
                        u.b.log("destroy"),
                        this.trigger(c.a.DESTROYING, void 0),
                        this.detachMedia(),
                        this.removeAllListeners(),
                        this._autoLevelCapping = -1,
                        this.url = null,
                        this.networkControllers.forEach((function(e) {
                            return e.destroy()
                        }
                        )),
                        this.networkControllers.length = 0,
                        this.coreComponents.forEach((function(e) {
                            return e.destroy()
                        }
                        )),
                        this.coreComponents.length = 0
                    }
                    ,
                    t.setLevel = function(e, t) {
                        void 0 === t && (t = {
                            bitrate: 0,
                            name: "",
                            m3u8String: ""
                        }),
                        this.levelController.setLevel(e, t)
                    }
                    ,
                    t.attachMedia = function(e) {
                        u.b.log("attachMedia"),
                        this._media = e,
                        this.trigger(c.a.MEDIA_ATTACHING, {
                            media: e
                        })
                    }
                    ,
                    t.detachMedia = function() {
                        u.b.log("detachMedia"),
                        this.trigger(c.a.MEDIA_DETACHING, void 0),
                        this._media = null
                    }
                    ,
                    t.loadSource = function(e, t) {
                        this.stopLoad();
                        var r = this.media
                          , i = this.url
                          , n = this.url = a.buildAbsoluteURL(self.location.href, e, {
                            alwaysNormalize: !0
                        });
                        u.b.log("loadSource:" + n),
                        r && i && i !== n && this.bufferController.hasSourceTypes() && (this.detachMedia(),
                        this.attachMedia(r)),
                        t ? this.trigger(c.a.M3U8_DIRECT_LOAD, {
                            url: e,
                            m3u8: t
                        }) : this.trigger(c.a.MANIFEST_LOADING, {
                            url: e
                        })
                    }
                    ,
                    t.startLoad = function(e) {
                        void 0 === e && (e = -1),
                        u.b.log("startLoad(" + e + ")"),
                        this.networkControllers.forEach((function(t) {
                            t.startLoad(e)
                        }
                        ))
                    }
                    ,
                    t.stopLoad = function() {
                        u.b.log("stopLoad"),
                        this.networkControllers.forEach((function(e) {
                            e.stopLoad()
                        }
                        ))
                    }
                    ,
                    t.swapAudioCodec = function() {
                        u.b.log("swapAudioCodec"),
                        this.streamController.swapAudioCodec()
                    }
                    ,
                    t.recoverMediaError = function() {
                        u.b.log("recoverMediaError");
                        var e = this._media;
                        this.detachMedia(),
                        e && this.attachMedia(e)
                    }
                    ,
                    t.removeLevel = function(e, t) {
                        void 0 === t && (t = 0),
                        this.levelController.removeLevel(e, t)
                    }
                    ,
                    n()(e, [{
                        key: "chachaParam",
                        set: function(e) {
                            if (this.config.chachaParam = e,
                            e) {
                                if (!this.config.enableWorker)
                                    throw new Error("chacha is supported only in worker!");
                                this.streamController.setChachaParam()
                            }
                        }
                    }, {
                        key: "levels",
                        get: function() {
                            return this.levelController.levels || []
                        }
                    }, {
                        key: "currentLevel",
                        get: function() {
                            return this.streamController.currentLevel
                        },
                        set: function(e) {
                            u.b.log("set currentLevel:" + e),
                            this.loadLevel = e,
                            this.abrController.clearTimer(),
                            this.streamController.immediateLevelSwitch()
                        }
                    }, {
                        key: "currentFragment",
                        get: function() {
                            return this.streamController.fragCurrent
                        }
                    }, {
                        key: "remainingFragmentCount",
                        get: function() {
                            return this.streamController.fragRemaining
                        }
                    }, {
                        key: "nextLevel",
                        get: function() {
                            return this.streamController.nextLevel
                        },
                        set: function(e) {
                            u.b.log("set nextLevel:" + e),
                            this.levelController.manualLevel = e,
                            this.streamController.nextLevelSwitch()
                        }
                    }, {
                        key: "loadLevel",
                        get: function() {
                            return this.levelController.level
                        },
                        set: function(e) {
                            u.b.log("set loadLevel:" + e),
                            this.levelController.manualLevel = e
                        }
                    }, {
                        key: "nextLoadLevel",
                        get: function() {
                            return this.levelController.nextLoadLevel
                        },
                        set: function(e) {
                            this.levelController.nextLoadLevel = e
                        }
                    }, {
                        key: "firstLevel",
                        get: function() {
                            return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                        },
                        set: function(e) {
                            u.b.log("set firstLevel:" + e),
                            this.levelController.firstLevel = e
                        }
                    }, {
                        key: "startLevel",
                        get: function() {
                            return this.levelController.startLevel
                        },
                        set: function(e) {
                            u.b.log("set startLevel:" + e),
                            -1 !== e && (e = Math.max(e, this.minAutoLevel)),
                            this.levelController.startLevel = e
                        }
                    }, {
                        key: "capLevelToPlayerSize",
                        get: function() {
                            return this.config.capLevelToPlayerSize
                        },
                        set: function(e) {
                            var t = !!e;
                            t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(),
                            this.autoLevelCapping = -1,
                            this.streamController.nextLevelSwitch()),
                            this.config.capLevelToPlayerSize = t)
                        }
                    }, {
                        key: "autoLevelCapping",
                        get: function() {
                            return this._autoLevelCapping
                        },
                        set: function(e) {
                            this._autoLevelCapping !== e && (u.b.log("set autoLevelCapping:" + e),
                            this._autoLevelCapping = e)
                        }
                    }, {
                        key: "bandwidthEstimate",
                        get: function() {
                            var e = this.abrController.bwEstimator;
                            return e ? e.getEstimate() : NaN
                        }
                    }, {
                        key: "autoLevelEnabled",
                        get: function() {
                            return -1 === this.levelController.manualLevel
                        }
                    }, {
                        key: "manualLevel",
                        get: function() {
                            return this.levelController.manualLevel
                        }
                    }, {
                        key: "minAutoLevel",
                        get: function() {
                            var e = this.levels
                              , t = this.config.minAutoBitrate;
                            if (!e)
                                return 0;
                            for (var r = e.length, i = 0; i < r; i++)
                                if (e[i].maxBitrate > t)
                                    return i;
                            return 0
                        }
                    }, {
                        key: "maxAutoLevel",
                        get: function() {
                            var e = this.levels
                              , t = this.autoLevelCapping;
                            return -1 === t && e && e.length ? e.length - 1 : t
                        }
                    }, {
                        key: "nextAutoLevel",
                        get: function() {
                            return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
                        },
                        set: function(e) {
                            this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
                        }
                    }, {
                        key: "audioTracks",
                        get: function() {
                            var e = this.audioTrackController;
                            return e ? e.audioTracks : []
                        }
                    }, {
                        key: "audioTrack",
                        get: function() {
                            var e = this.audioTrackController;
                            return e ? e.audioTrack : -1
                        },
                        set: function(e) {
                            var t = this.audioTrackController;
                            t && (t.audioTrack = e)
                        }
                    }, {
                        key: "subtitleTracks",
                        get: function() {
                            var e = this.subtitleTrackController;
                            return e ? e.subtitleTracks : []
                        }
                    }, {
                        key: "subtitleTrack",
                        get: function() {
                            var e = this.subtitleTrackController;
                            return e ? e.subtitleTrack : -1
                        },
                        set: function(e) {
                            var t = this.subtitleTrackController;
                            t && (t.subtitleTrack = e)
                        }
                    }, {
                        key: "media",
                        get: function() {
                            return this._media
                        }
                    }, {
                        key: "subtitleDisplay",
                        get: function() {
                            var e = this.subtitleTrackController;
                            return !!e && e.subtitleDisplay
                        },
                        set: function(e) {
                            var t = this.subtitleTrackController;
                            t && (t.subtitleDisplay = e)
                        }
                    }, {
                        key: "lowLatencyMode",
                        get: function() {
                            return this.config.lowLatencyMode
                        },
                        set: function(e) {
                            this.config.lowLatencyMode = e
                        }
                    }, {
                        key: "liveSyncPosition",
                        get: function() {
                            return this.latencyController.liveSyncPosition
                        }
                    }, {
                        key: "latency",
                        get: function() {
                            return this.latencyController.latency
                        }
                    }, {
                        key: "maxLatency",
                        get: function() {
                            return this.latencyController.maxLatency
                        }
                    }, {
                        key: "targetLatency",
                        get: function() {
                            return this.latencyController.targetLatency
                        }
                    }, {
                        key: "drift",
                        get: function() {
                            return this.latencyController.drift
                        }
                    }, {
                        key: "forceStartLoad",
                        get: function() {
                            return this.streamController.forceStartLoad
                        }
                    }], [{
                        key: "version",
                        get: function() {
                            return "1.57.5"
                        }
                    }, {
                        key: "Events",
                        get: function() {
                            return c.a
                        }
                    }, {
                        key: "ErrorTypes",
                        get: function() {
                            return h.b
                        }
                    }, {
                        key: "ErrorDetails",
                        get: function() {
                            return h.a
                        }
                    }, {
                        key: "DefaultConfig",
                        get: function() {
                            return e.defaultConfig ? e.defaultConfig : wt
                        },
                        set: function(t) {
                            e.defaultConfig = t
                        }
                    }, {
                        key: "ColorPrimaries",
                        get: function() {
                            return At.d
                        }
                    }, {
                        key: "TransferCharacteristics",
                        get: function() {
                            return At.e
                        }
                    }])
                }();
                _t.defaultConfig = void 0
            }
            ]).default)
        }
    }
      , t = {};
    function r(i) {
        var n = t[i];
        if (void 0 !== n)
            return n.exports;
        var a = t[i] = {
            exports: {}
        };
        return e[i].call(a.exports, a, a.exports, r),
        a.exports
    }
    r.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return r.d(t, {
            a: t
        }),
        t
    }
    ,
    r.d = function(e, t) {
        for (var i in t)
            r.o(t, i) && !r.o(e, i) && Object.defineProperty(e, i, {
                enumerable: !0,
                get: t[i]
            })
    }
    ,
    r.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    r.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    r.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ;
    var i = {};
    !function() {
        "use strict";
        r.r(i),
        r.d(i, {
            BUILD_TIME: function() {
                return ai
            },
            HLS_ERR_CODE_MAP: function() {
                return d
            },
            Hls: function() {
                return l()
            },
            HlsErrorCode: function() {
                return f
            },
            UrlParamKeys: function() {
                return o
            },
            VERSION: function() {
                return oi
            }
        });
        var e = window.ThumbPlayerCore;
        e.defaultI18nConfig.txhlsjsKernel = {
            ERR_INNER_EXCEPTION: "",
            ERR_NET: ""
        };
        var t, n, a, o, s = r(291), l = r.n(s), c = function(e, t, r, i) {
            var n, a = arguments.length, o = a < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, r) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
                o = Reflect.decorate(e, t, r, i);
            else
                for (var s = e.length - 1; s >= 0; s--)
                    (n = e[s]) && (o = (a < 3 ? n(o) : a > 3 ? n(t, r, o) : n(t, r)) || o);
            return a > 3 && o && Object.defineProperty(t, r, o),
            o
        }, h = function(e, t) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
                return Reflect.metadata(e, t)
        }, u = function() {
            function t(e) {
                this.isAppendingFrag = null,
                this.isOver = !1,
                this.instanceId = e
            }
            return t.prototype.destroy = function() {
                this.isAppendingFrag = null
            }
            ,
            t.prototype.start = function() {
                this.isOver = !1,
                this.isAppendingFrag = null,
                this.timeStart(e.KernelStepKey.ATTACH_MEDIA)
            }
            ,
            t.prototype.over = function() {
                if (!this.isOver) {
                    this.isOver = !0;
                    var t = this.isAppendingFrag;
                    this.isAppendingFrag = null;
                    var r = (t || {}).stats;
                    if (r) {
                        var i = r.transmuxing
                          , n = r.loading;
                        this.timeEnd(e.KernelStepKey.APPEND_CHUNK),
                        n && e.StepTimer.push(e.KernelStepKey.LOAD_CHUNK, n.start, n.first, this.instanceId),
                        i && e.StepTimer.push(e.KernelStepKey.TRANSMUX_CHUNK, i.start, i.end, this.instanceId)
                    }
                }
            }
            ,
            t.prototype.pushEvts = function(t, r) {
                var i, n, a;
                if (!this.isOver) {
                    var o = ((i = {})[l().Events.MEDIA_ATTACHED] = {
                        type: "end",
                        key: e.KernelStepKey.ATTACH_MEDIA
                    },
                    i[l().Events.MANIFEST_LOADING] = {
                        type: "start",
                        key: e.KernelStepKey.LOAD_MANIFAST
                    },
                    i[l().Events.MANIFEST_LOADED] = {
                        type: "end",
                        key: e.KernelStepKey.LOAD_MANIFAST
                    },
                    i[l().Events.BUFFER_APPENDING] = {
                        type: "start",
                        key: e.KernelStepKey.APPEND_CHUNK
                    },
                    i)[t];
                    o && ("start" === o.type ? this.timeStart : this.timeEnd).apply(this, [o.key]),
                    t === l().Events.FRAG_LOADING ? null === (n = performance.mark) || void 0 === n || n.call(performance, e.KernelStepKey.LOAD_CHUNK) : t === l().Events.BUFFER_APPENDED && (this.isAppendingFrag || "main" !== (null === (a = r.frag) || void 0 === a ? void 0 : a.type) || (this.isAppendingFrag = r.frag))
                }
            }
            ,
            t = c([e.stepTimerClassDecorator, h("design:paramtypes", [String])], t)
        }(), d = ((t = {
            HLS_UNKNOWN_ERR: "70030000"
        })[l().ErrorTypes.KEY_SYSTEM_ERROR] = "70030001",
        t["".concat(l().ErrorTypes.MEDIA_ERROR, ".").concat(l().ErrorDetails.BUFFER_STALLED_ERROR)] = "70030002",
        t["".concat(l().ErrorTypes.MEDIA_ERROR, ".").concat(l().ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR)] = "70030003",
        t["".concat(l().ErrorTypes.MEDIA_ERROR, ".").concat(l().ErrorDetails.FRAG_DECRYPT_ERROR)] = "70030004",
        t["".concat(l().ErrorTypes.MEDIA_ERROR, ".").concat(l().ErrorDetails.FRAG_PARSING_ERROR)] = "70030005",
        t[l().ErrorTypes.OTHER_ERROR] = "70030006",
        t["".concat(l().ErrorTypes.NETWORK_ERROR, ".").concat(l().ErrorDetails.MANIFEST_LOAD_TIMEOUT)] = "70030007",
        t["".concat(l().ErrorTypes.NETWORK_ERROR, ".").concat(l().ErrorDetails.MANIFEST_LOAD_ERROR)] = "70030008",
        t["".concat(l().ErrorTypes.NETWORK_ERROR, ".").concat(l().ErrorDetails.LEVEL_LOAD_TIMEOUT)] = "70030009",
        t["".concat(l().ErrorTypes.NETWORK_ERROR, ".").concat(l().ErrorDetails.LEVEL_LOAD_ERROR)] = "70030010",
        t["".concat(l().ErrorTypes.NETWORK_ERROR, ".").concat(l().ErrorDetails.FRAG_LOAD_TIMEOUT)] = "70030011",
        t["".concat(l().ErrorTypes.NETWORK_ERROR, ".").concat(l().ErrorDetails.FRAG_LOAD_ERROR)] = "70030012",
        t[l().ErrorTypes.FRAG_DECRYPT_ERROR] = "70030013",
        t), f = {
            general: (n = {
                uncategorized: 0
            },
            n[l().ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR] = 3,
            n[l().ErrorDetails.FRAG_DECRYPT_ERROR] = 4,
            n[l().ErrorDetails.FRAG_PARSING_ERROR] = 5,
            n),
            network: (a = {
                uncategorized: 100,
                unexpectedLoadingError: 199
            },
            a[l().ErrorDetails.MANIFEST_LOAD_TIMEOUT] = 101,
            a[l().ErrorDetails.MANIFEST_LOAD_ERROR] = 102,
            a[l().ErrorDetails.LEVEL_LOAD_TIMEOUT] = 103,
            a[l().ErrorDetails.LEVEL_LOAD_ERROR] = 104,
            a[l().ErrorDetails.FRAG_LOAD_TIMEOUT] = 105,
            a[l().ErrorDetails.FRAG_LOAD_ERROR] = 106,
            a),
            custom: {
                currentFragmentNotParsed: 101,
                currentFragmentNotBuffered: 102
            }
        };
        function p(e, t) {
            var r = e.bitrate
              , i = e.name
              , n = e.height
              , a = e.width
              , o = e.codecSet;
            return {
                value: i,
                label: i,
                width: a,
                height: n,
                masterUrl: t,
                bitrate: r,
                url: e.uri,
                codecs: o
            }
        }
        !function(e) {
            e.enableHlsProgressive = "__enableHlsProgressive",
            e.enableP2P = "__enableP2P",
            e.enableDumpFmp4 = "__enableDumpFmp4"
        }(o || (o = {}));
        var g = !1
          , v = function() {
            function t() {
                this.createDumpFmp4DataBtn()
            }
            return t.prototype.destroy = function() {
                this.fmp4Data = null
            }
            ,
            t.prototype.append = function(e, t) {
                this.fmp4Data[e] && this.fmp4Data[e].push(t)
            }
            ,
            t.prototype.reset = function() {
                this.fmp4Data = {
                    audio: [],
                    video: [],
                    audiovideo: []
                }
            }
            ,
            t.prototype.createDumpFmp4DataBtn = function() {
                var t = this;
                if (!g) {
                    g = !0;
                    for (var r = ["video", "audio", "audiovideo"], i = function(i) {
                        var n = '\n        <button type="button" style="position: fixed;left: '.concat(10 + 70 * i, 'px;top: 10px;z-index: 9999;">').concat(r[i], "</button>\n      ")
                          , a = e.domTool.creatDom(n.trim());
                        e.domTool.append(document.body, a),
                        a.addEventListener("click", (function() {
                            t.downloadFmp4File(r[i])
                        }
                        ))
                    }, n = 0; n < r.length; n++)
                        i(n)
                }
            }
            ,
            t.prototype.downloadFmp4File = function(t) {
                if (this.fmp4Data[t].length <= 0)
                    console.error("no available fmp4 data for saving.");
                else {
                    var r, i, n, a, o = this.fmp4Data[t].concat(), s = new Blob([(r = o,
                    i = r.reduce((function(e, t) {
                        return e + t.length
                    }
                    ), 0),
                    n = new Uint8Array(i),
                    a = 0,
                    r.forEach((function(e) {
                        n.set(e, a),
                        a += e.length
                    }
                    )),
                    n)],{
                        type: "application/octet-stream"
                    }), l = "".concat(t, "-").concat(e.commonTool.dateFormat("yyyy-MM-dd_hh:mm:ss", new Date), ".mp4");
                    e.domTool.creatDom('\n      <a download="hlsjs-'.concat(l, '" href="').concat(self.URL.createObjectURL(s), '">Download ').concat(l, " track</a><br>\n    ").trim()).click()
                }
            }
            ,
            t.enableDumpFmp4Data = "1" === e.urlTool.getUrlParamByKey(location.href, o.enableDumpFmp4),
            t
        }();
        var y, m, T = [e.PlayerError.NativeError({
            code: e.PlaybackErrorCode.ORG_LOAD_TIMEOUT
        }), e.PlayerError.NativeError({
            code: e.PlaybackErrorCode.ORG_PLAY_STUCK_ERR
        }), e.PlayerError.NativeError({
            code: e.PlaybackErrorCode.STATE_STUCK
        })];
        function S(t) {
            return new e.ErrorBase("hlsKernel",t)
        }
        e.ErrorTypeCodeMap.hlsKernel = 30;
        var I = ((y = {})[l().ColorPrimaries.BT709] = e.TPColorPrimaries.BT709,
        y[l().ColorPrimaries.BT601] = e.TPColorPrimaries.BT601,
        y[l().ColorPrimaries.BT2020] = e.TPColorPrimaries.BT2020,
        y[l().ColorPrimaries.BT2100] = e.TPColorPrimaries.BT2100,
        y)
          , P = ((m = {})[l().TransferCharacteristics.BT709] = e.TPTransferCharacteristics.BT709,
        m[l().TransferCharacteristics.BT601] = e.TPTransferCharacteristics.BT601,
        m[l().TransferCharacteristics.GAMMA22] = e.TPTransferCharacteristics.GAMMA22,
        m[l().TransferCharacteristics.GAMMA28] = e.TPTransferCharacteristics.GAMMA28,
        m[l().TransferCharacteristics.SRGB] = e.TPTransferCharacteristics.SRGB,
        m[l().TransferCharacteristics.BT2020] = e.TPTransferCharacteristics.BT2020,
        m[l().TransferCharacteristics.BT2100PQ] = e.TPTransferCharacteristics.BT2100PQ,
        m[l().TransferCharacteristics.BT2100HLG] = e.TPTransferCharacteristics.BT2100HLG,
        m)
          , b = function(e, t) {
            return b = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(e, t) {
                e.__proto__ = t
            }
            || function(e, t) {
                for (var r in t)
                    Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
            }
            ,
            b(e, t)
        };
        function E(e, t) {
            if ("function" != typeof t && null !== t)
                throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            b(e, t),
            e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype,
            new r)
        }
        function D(e, t, r, i) {
            return new (r || (r = Promise))((function(n, a) {
                function o(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function s(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? n(e.value) : (t = e.value,
                    t instanceof r ? t : new r((function(e) {
                        e(t)
                    }
                    ))).then(o, s)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        }
        function k(e, t) {
            var r, i, n, a, o = {
                label: 0,
                sent: function() {
                    if (1 & n[0])
                        throw n[1];
                    return n[1]
                },
                trys: [],
                ops: []
            };
            return a = {
                next: s(0),
                throw: s(1),
                return: s(2)
            },
            "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                return this
            }
            ),
            a;
            function s(s) {
                return function(l) {
                    return function(s) {
                        if (r)
                            throw new TypeError("Generator is already executing.");
                        for (; a && (a = 0,
                        s[0] && (o = 0)),
                        o; )
                            try {
                                if (r = 1,
                                i && (n = 2 & s[0] ? i.return : s[0] ? i.throw || ((n = i.return) && n.call(i),
                                0) : i.next) && !(n = n.call(i, s[1])).done)
                                    return n;
                                switch (i = 0,
                                n && (s = [2 & s[0], n.value]),
                                s[0]) {
                                case 0:
                                case 1:
                                    n = s;
                                    break;
                                case 4:
                                    return o.label++,
                                    {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    o.label++,
                                    i = s[1],
                                    s = [0];
                                    continue;
                                case 7:
                                    s = o.ops.pop(),
                                    o.trys.pop();
                                    continue;
                                default:
                                    if (!(n = o.trys,
                                    (n = n.length > 0 && n[n.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                        o = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
                                        o.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && o.label < n[1]) {
                                        o.label = n[1],
                                        n = s;
                                        break
                                    }
                                    if (n && o.label < n[2]) {
                                        o.label = n[2],
                                        o.ops.push(s);
                                        break
                                    }
                                    n[2] && o.ops.pop(),
                                    o.trys.pop();
                                    continue
                                }
                                s = t.call(e, o)
                            } catch (e) {
                                s = [6, e],
                                i = 0
                            } finally {
                                r = n = 0
                            }
                        if (5 & s[0])
                            throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }([s, l])
                }
            }
        }
        Object.create;
        function C(e) {
            var t = "function" == typeof Symbol && Symbol.iterator
              , r = t && e[t]
              , i = 0;
            if (r)
                return r.call(e);
            if (e && "number" == typeof e.length)
                return {
                    next: function() {
                        return e && i >= e.length && (e = void 0),
                        {
                            value: e && e[i++],
                            done: !e
                        }
                    }
                };
            throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }
        function L(e, t) {
            var r = "function" == typeof Symbol && e[Symbol.iterator];
            if (!r)
                return e;
            var i, n, a = r.call(e), o = [];
            try {
                for (; (void 0 === t || t-- > 0) && !(i = a.next()).done; )
                    o.push(i.value)
            } catch (e) {
                n = {
                    error: e
                }
            } finally {
                try {
                    i && !i.done && (r = a.return) && r.call(a)
                } finally {
                    if (n)
                        throw n.error
                }
            }
            return o
        }
        function w(e, t, r) {
            if (r || 2 === arguments.length)
                for (var i, n = 0, a = t.length; n < a; n++)
                    !i && n in t || (i || (i = Array.prototype.slice.call(t, 0, n)),
                    i[n] = t[n]);
            return e.concat(i || Array.prototype.slice.call(t))
        }
        Object.create;
        "function" == typeof SuppressedError && SuppressedError;
        var R, A, _, x, O, F, B, M, U, N, G, H, q, z, K, V, j, W, Y;
        !function(e) {
            e[e.UNCONNECTED = 0] = "UNCONNECTED",
            e[e.CONNECTING = 1] = "CONNECTING",
            e[e.CONNECTED = 2] = "CONNECTED",
            e[e.STOPED = 3] = "STOPED"
        }(R || (R = {})),
        function(e) {
            e[e.UNINIT = 0] = "UNINIT",
            e[e.RUNNING = 1] = "RUNNING",
            e[e.STOP = 2] = "STOP"
        }(A || (A = {})),
        function(e) {
            e[e.UNLOGIN = 0] = "UNLOGIN",
            e[e.WAIT_LOGIN = 1] = "WAIT_LOGIN",
            e[e.LOGINING = 2] = "LOGINING",
            e[e.LOGIN = 3] = "LOGIN",
            e[e.LOGOUT = 4] = "LOGOUT",
            e[e.LOG_ERROR = 5] = "LOG_ERROR"
        }(_ || (_ = {})),
        function(e) {
            e[e.UnKnown = 0] = "UnKnown",
            e[e.Start = 1] = "Start",
            e[e.Ing = 2] = "Ing",
            e[e.End = 3] = "End"
        }(x || (x = {})),
        function(e) {
            e[e.debug = 0] = "debug",
            e[e.info = 1] = "info",
            e[e.warn = 2] = "warn",
            e[e.error = 3] = "error"
        }(O || (O = {})),
        function(e) {
            e[e.Normal = 0] = "Normal",
            e[e.VideoIn = 1] = "VideoIn",
            e[e.AdInsert = 2] = "AdInsert"
        }(F || (F = {})),
        function(e) {
            e[e.Vod = 0] = "Vod",
            e[e.Live = 1] = "Live"
        }(B || (B = {})),
        function(e) {
            e[e.Playing = 0] = "Playing",
            e[e.Stoped = 1] = "Stoped",
            e[e.Paused = 2] = "Paused",
            e[e.Preload = 3] = "Preload"
        }(M || (M = {})),
        function(e) {
            e[e.HTTP = 0] = "HTTP",
            e[e.P2P = 1] = "P2P",
            e[e.IndexedDB = 2] = "IndexedDB"
        }(U || (U = {})),
        function(e) {
            e[e.Idel = 0] = "Idel",
            e[e.Connecting = 1] = "Connecting",
            e[e.Loading = 2] = "Loading",
            e[e.Stop = 3] = "Stop"
        }(N || (N = {})),
        function(e) {
            e[e.PC = 0] = "PC",
            e[e.Phone = 1] = "Phone"
        }(G || (G = {})),
        function(e) {
            e[e.FrontEnd = 0] = "FrontEnd",
            e[e.BackEnd = 2] = "BackEnd"
        }(H || (H = {})),
        function(e) {
            e[e.No_Buffer_Limit = 1] = "No_Buffer_Limit",
            e[e.Multithreading = 2] = "Multithreading"
        }(q || (q = {})),
        function(e) {
            e[e.Normal = 0] = "Normal",
            e[e.Peak_Time_Adjust = 1] = "Peak_Time_Adjust",
            e[e.Watch_Time_Adjust = 2] = "Watch_Time_Adjust"
        }(z || (z = {})),
        function(e) {
            e[e.Normal = 0] = "Normal",
            e[e.Part_TS_Download = 1] = "Part_TS_Download"
        }(K || (K = {})),
        function(e) {
            e[e.SUCCEED = 0] = "SUCCEED",
            e[e.NOT_USE_P2P = 1] = "NOT_USE_P2P",
            e[e.NOT_P2P_Flow = 2] = "NOT_P2P_Flow",
            e[e.PS_LOGIN_FAIL = 3] = "PS_LOGIN_FAIL",
            e[e.PUNCH_FAILED = 4] = "PUNCH_FAILED",
            e[e.TPT_NOT_GOT = 5] = "TPT_NOT_GOT",
            e[e.SEED_NOT_FOUND = 6] = "SEED_NOT_FOUND",
            e[e.WIFI_OFF = 7] = "WIFI_OFF",
            e[e.VINFO_NOT_P2P = 8] = "VINFO_NOT_P2P",
            e[e.ADV_DRIVE_P2P = 9] = "ADV_DRIVE_P2P",
            e[e.RTC_NOT_SUP = 21] = "RTC_NOT_SUP",
            e[e.RTC_CALL_FAIL = 22] = "RTC_CALL_FAIL",
            e[e.P2P_CLOSE_ONE_VID = 23] = "P2P_CLOSE_ONE_VID",
            e[e.P2P_CLOSE_ALWAYS = 24] = "P2P_CLOSE_ALWAYS",
            e[e.MACHINEID_DIFF = 25] = "MACHINEID_DIFF"
        }(V || (V = {})),
        function(e) {
            e[e.Succeed = 0] = "Succeed",
            e[e.NotOpen = 1] = "NotOpen",
            e[e.NotSupported = 2] = "NotSupported",
            e[e.OpenFailed = 3] = "OpenFailed"
        }(j || (j = {})),
        function(e) {
            e[e.Period = 0] = "Period",
            e[e.TaskBuffering = 1] = "TaskBuffering",
            e[e.TaskStop = 2] = "TaskStop",
            e[e.ServerQuality = 3] = "ServerQuality",
            e[e.FlowInterrupt = 4] = "FlowInterrupt",
            e[e.InitProxy = 5] = "InitProxy",
            e[e.ServerPeriod = 7] = "ServerPeriod"
        }(W || (W = {})),
        function(e) {
            e[e.SrvCfg = 0] = "SrvCfg",
            e[e.PeerServer = 2] = "PeerServer",
            e[e.CDNServer = 6] = "CDNServer",
            e[e.SwitchUrl = 10] = "SwitchUrl",
            e[e.WebSocket = 15] = "WebSocket",
            e[e.TPTServer = 16] = "TPTServer",
            e[e.SignalServer = 17] = "SignalServer",
            e[e.PlayerError = 18] = "PlayerError"
        }(Y || (Y = {}));
        var Q, X, Z, J = {
            version: "1.6.11",
            PIECE_SIZE: 1024,
            BLOCK_SIZE: 65536,
            secondTimer: 1e3,
            busiID: 0,
            configUrl: "https://appcfg.v.qq.com/getconf?cmd=h5_p2p",
            reportUrl: "https://h.trace.qq.com/bosskv",
            vodIceServer: [{
                ip: "webrtcice.video.qq.com",
                port: 3478
            }],
            vodPeerServer: [{
                ip: "webrtcpunch.video.qq.com",
                port: 0
            }, {
                ip: "bakwebrtcpunch.video.qq.com",
                port: 0
            }],
            liveIceServer: [{
                ip: "webrtczbice.video.qq.com",
                port: 3478
            }],
            livePeerServer: [{
                ip: "webrtczb.video.qq.com",
                port: 443
            }, {
                ip: "webrtczb.video.qq.com",
                port: 443
            }],
            attaIDServerQuality: "zd300003646",
            attaIDPlayQuality: "z9500003647",
            attaTokenPlayQuality: "6993152271",
            attaTokenServerQuality: "9363477297",
            playerInfo: {
                device: G.PC
            },
            osVer: "",
            browserVer: "",
            cpuThreads: -1,
            heapSizeLimit: -1,
            accessDBErrorTimes: 0,
            abTestID: -1
        };
        !function(e) {
            e[e.LOGIN = 59812] = "LOGIN",
            e[e.LOGOUT = 59813] = "LOGOUT",
            e[e.HEARTBEAT = 59814] = "HEARTBEAT",
            e[e.REPORT = 59815] = "REPORT",
            e[e.QUERY_SEED = 59816] = "QUERY_SEED",
            e[e.SIGNAL_RELAY = 61652] = "SIGNAL_RELAY",
            e[e.QUERY_TPT = 60287] = "QUERY_TPT"
        }(Q || (Q = {})),
        function(e) {
            e[e.OK = 0] = "OK",
            e[e.ERR_COMMON = 1] = "ERR_COMMON",
            e[e.ERR_INTERNAL = 1e4] = "ERR_INTERNAL",
            e[e.ERR_INVALID_PKG = 10001] = "ERR_INVALID_PKG",
            e[e.ERR_INVALID_CMD = 10002] = "ERR_INVALID_CMD",
            e[e.ERR_INVALID_SESSION = 10003] = "ERR_INVALID_SESSION",
            e[e.NEED_REPORT_FULL = 10004] = "NEED_REPORT_FULL",
            e[e.ERR_SVR_BUSY = 10005] = "ERR_SVR_BUSY",
            e[e.ERR_SVR_FILTER = 10006] = "ERR_SVR_FILTER",
            e[e.NOT_FIND_DSTUIN = 1e3] = "NOT_FIND_DSTUIN",
            e[e.TPT_NO_P2P = -40004] = "TPT_NO_P2P",
            e[e.TPT_REDIS_STORE_NULL = -40005] = "TPT_REDIS_STORE_NULL",
            e[e.TPT_FORMAT_INVALID = -40006] = "TPT_FORMAT_INVALID"
        }(X || (X = {})),
        function(e) {
            e.offer = "offer",
            e.candidate = "candidate",
            e.answer = "answer",
            e.bye = "bye"
        }(Z || (Z = {}));
        var $, ee = function() {
            function e() {}
            return e.getTask = function(e, t, r, i) {
                return {
                    obj: e,
                    func: t,
                    args: r,
                    seq: -1,
                    sendTick: Tr.getTick(),
                    retryCount: 0,
                    cmd: i,
                    name: "task"
                }
            }
            ,
            e.isTask = function(e) {
                return e && e instanceof Object && "task" === e.name
            }
            ,
            e.reqHeader = function(e, t, r) {
                return {
                    cmd: e,
                    uin: t.getUin(),
                    uin_token: t.getUinToken(),
                    appid: J.playerInfo.platform,
                    client_ver: J.playerInfo.playerVer,
                    seq: r
                }
            }
            ,
            e.loginReq = function(e) {
                return {
                    header: e
                }
            }
            ,
            e.logoutReq = function(e) {
                return {
                    header: e
                }
            }
            ,
            e.heartReq = function(e, t, r, i, n, a, o) {
                return {
                    header: e,
                    body: {
                        uploadbandwidth: t,
                        p2p_uploadspeed: r,
                        p2p_uploadsize: i,
                        server_num: n,
                        max_server_num: a,
                        file_num: o
                    }
                }
            }
            ,
            e.reportReq = function(e, t, r) {
                return {
                    header: e,
                    body: {
                        add_files: t,
                        delete_files: r
                    }
                }
            }
            ,
            e.querySeedReq = function(e, t, r) {
                return {
                    header: e,
                    body: {
                        fileid: t,
                        seed_num: r,
                        guid: J.playerInfo.guid
                    }
                }
            }
            ,
            e.forwardReq = function(e, t, r) {
                return {
                    header: e,
                    body: {
                        dst_uin: t,
                        msg: r
                    }
                }
            }
            ,
            e.getTPTReq = function(e, t, r) {
                return {
                    header: e,
                    body: {
                        busiid: t,
                        resourceid: r
                    }
                }
            }
            ,
            e.createOfferReq = function(e, t, r, i, n) {
                return {
                    type: Z.offer,
                    offer: t,
                    stype: n,
                    dst_uin: r,
                    keyid: i,
                    src_uin: e.getUin(),
                    ver: J.version
                }
            }
            ,
            e.createCandidateReq = function(e, t, r, i, n) {
                return {
                    type: Z.candidate,
                    stype: n,
                    candidate: t,
                    dst_uin: r,
                    keyid: i,
                    src_uin: e.getUin(),
                    ver: J.version
                }
            }
            ,
            e.createAnswerReq = function(e, t, r, i, n, a) {
                return {
                    type: Z.answer,
                    stype: n,
                    answer: t,
                    dst_uin: r,
                    keyid: i,
                    src_uin: e.getUin(),
                    ver: J.version,
                    busy: a
                }
            }
            ,
            e.byeNotify = function(e, t, r, i) {
                return {
                    type: Z.bye,
                    stype: r,
                    reason: i,
                    dst_uin: t,
                    keyid: "",
                    src_uin: e.getUin(),
                    ver: J.version
                }
            }
            ,
            e
        }(), te = function() {
            function e() {}
            return e.xhrSend = function(e) {
                var t = new XMLHttpRequest;
                return e.timeout && (t.timeout = e.timeout),
                e.responseType && (t.responseType = e.responseType),
                t.ontimeout = e.ontimeout,
                t.onprogress = e.onloadprogress,
                t.onloadstart = e.onloadstart,
                t.open(e.method || "get", e.url),
                e.range && t.setRequestHeader("Range", "bytes=" + e.range[0] + "-" + e.range[1]),
                e.enctype && t.setRequestHeader("enctype", e.enctype),
                e.contentType && t.setRequestHeader("Content-Type", e.contentType),
                t.onload = function() {
                    t.status >= 200 && t.status < 300 ? e.onloadsuccess && e.onloadsuccess(t) : e.onerror && e.onerror({
                        type: "xhrStatusCodeError",
                        target: t
                    })
                }
                ,
                t.onerror = function() {
                    e.onerror && e.onerror({
                        type: "xhrNetworkError",
                        target: t
                    })
                }
                ,
                e.body ? t.send(e.body) : t.send(),
                t
            }
            ,
            e.imgSend = function(e) {
                (new Image).src = encodeURI(e)
            }
            ,
            e
        }(), re = function() {
            function e() {
                this.reportCount = 0,
                this.totalCacheSize = 0,
                this.totalLocalSize = 0,
                this.maxAppLocalSize = 0,
                this.uploadFromFile = 0,
                this.initDB = j.NotOpen,
                this.supportWebRTC = 0,
                this.hasUnloadReport = !1
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.checkUnloadReport = function() {
                var e, t, r = null === (e = window.localStorage) || void 0 === e ? void 0 : e.getItem("unloadReport");
                r && (te.imgSend(r),
                null === (t = window.localStorage) || void 0 === t || t.removeItem("unloadReport"))
            }
            ,
            e.prototype.reportSvrQuality = function(e) {
                e.step = W.ServerQuality,
                1e3 * Math.random() < Lr.serverQualityReportRate && this.reportToAtta(e)
            }
            ,
            e.prototype.reportToAtta = function(e, t) {
                void 0 === t && (t = !1),
                e.deviceModel = J.playerInfo.device === G.Phone ? "H5" : "Browser";
                var r = e.step === W.Period || e.step === W.TaskStop || e.step === W.InitProxy ? J.attaIDPlayQuality : J.attaIDServerQuality
                  , i = e.step === W.Period || e.step === W.InitProxy || e.step === W.TaskStop ? J.attaTokenPlayQuality : J.attaTokenServerQuality;
                this.reportCount += 1,
                e.attaid = r,
                e.token = i,
                e.osVer = J.osVer + " " + J.browserVer,
                e.serial = this.reportCount,
                e.platform = J.playerInfo.platform,
                e.appVer = J.playerInfo.playerVer,
                e.p2pVer = Tr.getReportVersion(),
                e.guid = J.playerInfo.guid,
                e.qq = J.playerInfo.qq,
                e.wx = J.playerInfo.wx,
                e.clientTime = Math.floor(Date.now() / 1e3);
                var n = this.getReportUrl(J.reportUrl, e);
                !t || navigator.sendBeacon(n) || this.hasUnloadReport ? te.imgSend(n) : (window.localStorage.setItem("unloadReport", n),
                this.hasUnloadReport = !0)
            }
            ,
            e.prototype.getReportUrl = function(e, t) {
                var r, i, n = -1 !== e.indexOf("?"), a = "";
                if (t instanceof Object)
                    try {
                        for (var o = C(Object.entries(t)), s = o.next(); !s.done; s = o.next()) {
                            var l = L(s.value, 2)
                              , c = l[0]
                              , h = l[1];
                            "" !== h && (n ? a += "&" : (a += "?",
                            n = !0),
                            a += c.toString(),
                            a += "=",
                            void 0 !== h && (a += "number" == typeof h ? Math.floor(h) : h))
                        }
                    } catch (e) {
                        r = {
                            error: e
                        }
                    } finally {
                        try {
                            s && !s.done && (i = o.return) && i.call(o)
                        } finally {
                            if (r)
                                throw r.error
                        }
                    }
                return e + a
            }
            ,
            e
        }();
        !function(e) {
            e[e.TSFetchErrorBase = 19e3] = "TSFetchErrorBase",
            e[e.TSXhrErrorBase = 19050] = "TSXhrErrorBase",
            e[e.TSFetchCatchError = 19001] = "TSFetchCatchError",
            e[e.TSXhrOnError = 19051] = "TSXhrOnError",
            e[e.HTTPLowSpeed = 19003] = "HTTPLowSpeed",
            e[e.HTTPConnectTimeOut = 19004] = "HTTPConnectTimeOut",
            e[e.HTTPRevDataTimeout = 19005] = "HTTPRevDataTimeout",
            e[e.HTTPFilesizeError = 19006] = "HTTPFilesizeError",
            e[e.HTTPRangeSupportError = 19007] = "HTTPRangeSupportError",
            e[e.P2PDataRspFailed = 20001] = "P2PDataRspFailed",
            e[e.P2PDataCheckFailed = 20002] = "P2PDataCheckFailed",
            e[e.P2PUploadCheckFailed = 20003] = "P2PUploadCheckFailed",
            e[e.PSLoginSuccess = 22505] = "PSLoginSuccess",
            e[e.PSLoginTimeout = 22506] = "PSLoginTimeout",
            e[e.PSQuerySeedSuccess = 22508] = "PSQuerySeedSuccess",
            e[e.PSQuerySeedFailed = 22509] = "PSQuerySeedFailed",
            e[e.PSReportResFailed = 22511] = "PSReportResFailed",
            e[e.PSLoginFail = 22512] = "PSLoginFail",
            e[e.PSLogout = 22513] = "PSLogout",
            e[e.PSHeartBeatTimeout = 22514] = "PSHeartBeatTimeout",
            e[e.PSQuerySeedTimeout = 22515] = "PSQuerySeedTimeout",
            e[e.PSHeartBeatError = 22516] = "PSHeartBeatError",
            e[e.PSReportTimeout = 22517] = "PSReportTimeout",
            e[e.CSRecvSuccess = 23001] = "CSRecvSuccess",
            e[e.CSSocketConnectTimeout = 23002] = "CSSocketConnectTimeout",
            e[e.CSSvrRetError = 23006] = "CSSvrRetError",
            e[e.CSUnknownError = 23008] = "CSUnknownError",
            e[e.CSNoContext = 23009] = "CSNoContext",
            e[e.WebSocketonConnect = 26001] = "WebSocketonConnect",
            e[e.WebSocketonError = 26002] = "WebSocketonError",
            e[e.TPTHlsError = 27001] = "TPTHlsError",
            e[e.TPTTimeout = 27002] = "TPTTimeout",
            e[e.TPTSucceed = 27003] = "TPTSucceed",
            e[e.SignalRelayError = 28001] = "SignalRelayError",
            e[e.SignalRelayTimeout = 28002] = "SignalRelayTimeout"
        }($ || ($ = {}));
        var ie, ne = $, ae = {
            UnKnown: {
                code: 0,
                reason: "UnKnown"
            },
            Refuse: {
                code: 1,
                reason: "Remote peer refuse to Connect"
            },
            Timeout: {
                code: 2,
                reason: "Remote peer no response"
            },
            ConnectTimeout: {
                code: 3,
                reason: "Connect Remote peer Timeout"
            },
            PeerNoInServer: {
                code: 4,
                reason: "Server can't found this peer's uin"
            },
            QosLow: {
                code: 5,
                reason: "Qos Low"
            },
            NoDataExchange: {
                code: 6,
                reason: "No data exchange"
            },
            Exit: {
                code: 7,
                reason: "Client exit"
            },
            KeyIdNotExsit: {
                code: 8,
                reason: "Remote Keyid not exsit"
            },
            DstUinIsWrong: {
                code: 9,
                reason: "Dst uin is wrong"
            },
            RemoteNotInQueue: {
                code: 10,
                reason: "Remote is not in queue"
            },
            BusyInEmergencyTime: {
                code: 12,
                reason: "Remote is busy in emergency time"
            },
            ConnectFailed: {
                code: 13,
                reason: "Can't connect remote peer"
            }
        };
        !function(e) {
            e[e.Down = 1] = "Down",
            e[e.Up = 2] = "Up"
        }(ie || (ie = {}));
        var oe = function() {
            function e() {}
            return e.getReasonStr = function(e) {
                var t, r;
                try {
                    for (var i = C(Object.values(ae)), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value;
                        if (a.code === e)
                            return a.reason
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return "no found this code"
            }
            ,
            e
        }()
          , se = function() {
            function e() {
                this.lastHttpRepeatBytes = 0,
                this.lastP2PRepeatBytes = 0,
                this.lastCheckSuccTimes = 0,
                this.lastCheckFailTimes = 0,
                this.lastDataRspFailedCount = 0,
                this.lastCDNDownloadBytes = 0,
                this.lastP2PDownloadBytes = 0,
                this.lastP2PKeyIDWrongByte = 0,
                this.lastP2PFileSizeWrongBtye = 0,
                this.lastP2PRspFailByte = 0,
                this.lastP2PCheckFailByte = 0,
                this.lastP2PNotAllowByte = 0,
                this.lastP2PUploadWrongdataCount = 0,
                this.lastBitmapReqCount = 0,
                this.lastBitmapRspCount = 0,
                this.lastP2PDataReqCount = 0,
                this.lastP2PDataRspCount = 0,
                this.lastP2PUploadBytes = 0,
                this.lastQrySeedTimes = 0,
                this.lastQrySeedOkTimes = 0,
                this.lastHasSeedTimes = 0,
                this.lastReadFromFile = 0,
                this.lastSavedBytes = 0,
                this.lastHTTPRecvElapseSum = 0,
                this.lastConnectElapseSum = 0,
                this.lastFirstRecvElapseSum = 0,
                this.lastTotalRecvElapseSum = 0,
                this.lastTSCount = 0,
                this.lastCaculateTime = performance.now(),
                this.lastRTCDNDownloadBytes = 0,
                this.lastRTP2PDownloadBytes = 0,
                this.lastRTP2PUploadBytes = 0,
                this.lastRTHTTPRecvElapseSum = 0
            }
            return e.prototype.updateTraffic = function(e, t, r, i, n, a, o, s, l, c, h, u, d, f, p, g, v, y, m, T, S, I, P, b, E, D, k, C) {
                var L = performance.now()
                  , w = {
                    httpRepeat: n - this.lastHttpRepeatBytes,
                    p2pRepeat: a - this.lastP2PRepeatBytes,
                    checkSuccTimes: T - this.lastCheckSuccTimes,
                    checkFailTimes: S - this.lastCheckFailTimes,
                    dataRspFailedCount: I - this.lastDataRspFailedCount,
                    httpLoad: e - this.lastCDNDownloadBytes,
                    readFromFile: k - this.lastReadFromFile,
                    savedBytes: C - this.lastSavedBytes,
                    httpSpeedAvg: 1e3 * (e - this.lastCDNDownloadBytes) / (t - this.lastHTTPRecvElapseSum),
                    p2pLoad: r - this.lastP2PDownloadBytes,
                    p2pSpeedAvg: Number(1e3 * (r - this.lastP2PDownloadBytes) / (L - this.lastCaculateTime)),
                    p2pUpload: i - this.lastP2PUploadBytes,
                    uploadSpeedAvg: Number(1e3 * (i - this.lastP2PUploadBytes) / (L - this.lastCaculateTime)),
                    p2pKeyIDWrongByte: o - this.lastP2PKeyIDWrongByte,
                    p2pFileSizeWrongBtye: s - this.lastP2PFileSizeWrongBtye,
                    p2pRspFailByte: l - this.lastP2PRspFailByte,
                    p2pCheckFailByte: c - this.lastP2PCheckFailByte,
                    p2pNotAllowByte: h - this.lastP2PNotAllowByte,
                    p2pUploadWrongdataCount: u - this.lastP2PUploadWrongdataCount,
                    bitmapReqCount: d - this.lastBitmapReqCount,
                    bitmapRspCount: f - this.lastBitmapRspCount,
                    p2pDataReqCount: p - this.lastP2PDataReqCount,
                    p2pDataRspCount: g - this.lastP2PDataRspCount,
                    qrySeedTimes: v - this.lastQrySeedTimes,
                    qrySeedOkTimes: y - this.lastQrySeedOkTimes,
                    hasSeedTimes: m - this.lastHasSeedTimes,
                    connectElapseAvg: (P - this.lastConnectElapseSum) / (D - this.lastTSCount),
                    firstRecvElapseAvg: (b - this.lastFirstRecvElapseSum) / (D - this.lastTSCount),
                    totalRecvElapseAvg: (E - this.lastTotalRecvElapseSum) / (D - this.lastTSCount)
                };
                return w.httpSpeedAvg = isNaN(w.httpSpeedAvg) ? 0 : w.httpSpeedAvg,
                w.connectElapseAvg = isNaN(w.connectElapseAvg) ? 0 : w.connectElapseAvg,
                w.firstRecvElapseAvg = isNaN(w.firstRecvElapseAvg) ? 0 : w.firstRecvElapseAvg,
                w.totalRecvElapseAvg = isNaN(w.totalRecvElapseAvg) ? 0 : w.totalRecvElapseAvg,
                this.lastHttpRepeatBytes = n,
                this.lastP2PRepeatBytes = a,
                this.lastCheckSuccTimes = T,
                this.lastCheckFailTimes = S,
                this.lastDataRspFailedCount = I,
                this.lastCDNDownloadBytes = e,
                this.lastReadFromFile = k,
                this.lastSavedBytes = C,
                this.lastHTTPRecvElapseSum = t,
                this.lastP2PDownloadBytes = r,
                this.lastP2PUploadBytes = i,
                this.lastP2PKeyIDWrongByte = o,
                this.lastP2PFileSizeWrongBtye = s,
                this.lastP2PRspFailByte = l,
                this.lastP2PCheckFailByte = c,
                this.lastP2PNotAllowByte = h,
                this.lastBitmapReqCount = d,
                this.lastBitmapRspCount = f,
                this.lastP2PDataReqCount = p,
                this.lastP2PDataRspCount = g,
                this.lastQrySeedTimes = v,
                this.lastQrySeedOkTimes = y,
                this.lastHasSeedTimes = m,
                this.lastConnectElapseSum = P,
                this.lastFirstRecvElapseSum = b,
                this.lastTotalRecvElapseSum = E,
                this.lastTSCount = D,
                this.lastCaculateTime = L,
                w
            }
            ,
            e.prototype.updateTrafficForRealTimeSpeed = function(e, t, r, i) {
                var n = i - this.lastRTHTTPRecvElapseSum
                  , a = [0 === n ? 0 : 1e3 * (e - this.lastRTCDNDownloadBytes) / n, t - this.lastRTP2PDownloadBytes, r - this.lastRTP2PUploadBytes];
                return this.lastRTCDNDownloadBytes = e,
                this.lastRTP2PDownloadBytes = t,
                this.lastRTP2PUploadBytes = r,
                this.lastRTHTTPRecvElapseSum = i,
                a
            }
            ,
            e
        }()
          , le = function() {
            function e() {
                this.createTime = -1,
                this.startTime = -1,
                this.firstLoadTime = -1,
                this.firstSendDataTime = -1,
                this.firstFinishSendDataTime = -1,
                this.canPlayTime = -1,
                this.totalDuration = 0,
                this.qrySeedTimes = 0,
                this.qrySeedOkTimes = 0,
                this.hasSeedTimes = 0,
                this.p2pDownloadBytes = 0,
                this.httpDownloadBytes = 0,
                this.p2pRepeatByte = 0,
                this.httpRepeatByte = 0,
                this.p2pKeyIDWrongByte = 0,
                this.p2pFileSizeWrongBtye = 0,
                this.p2pRspFailByte = 0,
                this.p2pCheckFailByte = 0,
                this.p2pNotAllowByte = 0,
                this.p2pUploadWrongdataCount = 0,
                this.checkSuccTimes = 0,
                this.checkFailTimes = 0,
                this.natPunchCount = 0,
                this.natPunchOKCount = 0,
                this.natPunchElapse = 0,
                this.hasPublicAddrTimes = 0,
                this.sendOfferTimes = 0,
                this.recvOfferTimes = 0,
                this.sendAnswerTimes = 0,
                this.recvAnswerTimes = 0,
                this.sendCandidateTimes = 0,
                this.recvCandidateTimes = 0,
                this.recvAnswerButRejectTimes = 0,
                this.dataRspCount = 0,
                this.dataRspFailedCount = 0,
                this.p2pUploadByte = 0,
                this.bitmapRspCount = 0,
                this.bitmapReqCount = 0,
                this.dataReqCount = 0,
                this.validDataRspCount = 0,
                this.redundancyDataCount = 0,
                this.playerRemainTime = 0,
                this.playableTime = 0,
                this.httpRecvElapseSum = 0,
                this.readFromFile = 0,
                this.savedBytes = 0,
                this.isVideoIn = !1,
                this.isAdInsert = !1,
                this.isVideoInTSDiff = !1,
                this.isGenFileID = !1,
                this.reduceLevel = 1,
                this.avgSpeedInHttpCheckInterval = 0,
                this.httpCheckInterval = 0,
                this.lastCheckCDNLoadBytes = 0,
                this.speedArray = [],
                this.lastCheckP2PLoadBytes = 0,
                this.avgSpeedInP2P = 0,
                this.bitrateLatest = [],
                this.connectElapseSum = 0,
                this.firstRecvElapseSum = 0,
                this.totalRecvElapseSum = 0,
                this.tsCount = 0,
                this.isGotTPT = !1,
                this.trafficStats = new se
            }
            return e.getItem = function(t) {
                var r = this.instances.get(t);
                return r || (r = new e,
                this.instances.set(t, r)),
                r
            }
            ,
            e.prototype.start = function(e) {
                void 0 === e && (e = H.FrontEnd),
                this.processMode = e,
                this.reportInterval = this.taskState === M.Preload ? Lr.preloadReportInterval : Lr.reportInterval,
                void 0 === this.reportTimer && (this.reportTimer = self.setInterval(this.onReportSchedule.bind(this), J.secondTimer))
            }
            ,
            e.prototype.stop = function() {
                this.reportTimer && (this.report(W.TaskStop),
                clearInterval(this.reportTimer),
                this.reportTimer = void 0)
            }
            ,
            e.prototype.report = function(t, r) {
                void 0 === t && (t = W.Period),
                void 0 === r && (r = !1);
                var i = {};
                i.processMode = this.processMode,
                i.taskType = this.taskInfo.taskType === B.Vod ? 0 : 9999,
                i.taskState = this.taskState,
                i.keyID = this.taskInfo.keyID,
                i.flowID = this.taskInfo.flowID,
                i.vid = this.taskInfo.vid,
                i.format = this.taskInfo.format,
                i.isCharge = this.taskInfo.isCharge ? 1 : 0,
                i.vip = J.playerInfo.vip ? 1 : 0,
                i.sceneId = J.playerInfo.sceneID;
                var n = this.trafficStats.updateTraffic(this.httpDownloadBytes, this.httpRecvElapseSum, this.p2pDownloadBytes, this.p2pUploadByte, this.httpRepeatByte, this.p2pRepeatByte, this.p2pKeyIDWrongByte, this.p2pFileSizeWrongBtye, this.p2pRspFailByte, this.p2pCheckFailByte, this.p2pNotAllowByte, this.p2pUploadWrongdataCount, this.bitmapReqCount, this.bitmapRspCount, this.dataReqCount, this.dataRspCount, this.qrySeedTimes, this.qrySeedOkTimes, this.hasSeedTimes, this.checkSuccTimes, this.checkFailTimes, this.dataRspFailedCount, this.connectElapseSum, this.firstRecvElapseSum, this.totalRecvElapseSum, this.tsCount, this.readFromFile, this.savedBytes);
                i.step = t,
                i.http = n.httpLoad,
                i.httpSpeedAvg = n.httpSpeedAvg,
                i.httpRepeated = n.httpRepeat,
                i.qrySeedTimes = n.qrySeedTimes,
                i.qrySeedOkTimes = n.qrySeedOkTimes,
                i.hasSeedTimes = n.hasSeedTimes,
                i.p2p = n.p2pLoad + n.readFromFile,
                i.upload = n.p2pUpload,
                i.p2pSpeedAvg = n.p2pSpeedAvg,
                i.uploadSpeedAvg = n.uploadSpeedAvg,
                i.p2pRepeated = n.p2pRepeat,
                i.httpSpeed = this.realTimeHttp,
                i.p2pSpeed = this.realTimeP2P,
                i.uploadSpeed = this.realTimeP2PUpload,
                i.totalCacheSize = Math.floor(re.getInstance().totalCacheSize / 1024 / 1024),
                i.vodMaxCacheSize = Math.floor(Lr.maxCacheSize / 1024 / 1024),
                i.readFromFile = n.readFromFile,
                i.savedBytes = n.savedBytes,
                i.totalLocalSize = Math.floor(re.getInstance().totalLocalSize / 1024 / 1024),
                i.maxAppLocalSize = Math.floor(re.getInstance().maxAppLocalSize / 1024 / 1024),
                i.writeCacheLastErrorCode = J.accessDBErrorTimes,
                i.playerRemainTime = this.playerRemainTime,
                i.playableTime = this.playableTime,
                i.dataReqCount = n.p2pDataReqCount,
                i.dataRspCount = n.p2pDataRspCount,
                i.bitmapReqCount = n.bitmapReqCount,
                i.bitmapRspCount = n.bitmapRspCount;
                var a = $t.getInstance().getPeerNumForReport(this.taskInfo.keyID);
                i.peerPoolSize = a.downIdle + a.downConnected + a.downConnecting,
                i.connectedPeerNum = a.downConnected,
                i.uploadPeerNum = a.up,
                i.nat5PeerNum = a.upAndDown,
                i.p2pFlag = this.getP2PFlag(),
                i.checkFailTimes = n.checkFailTimes,
                i.checkSuccTimes = n.checkSuccTimes,
                i.dataRspFailedCount = n.dataRspFailedCount,
                i.nat0PunchCount = this.natPunchCount,
                i.nat0PunchOkCount = this.natPunchOKCount,
                i.nat0PunchElapse = this.natPunchElapse,
                i.nat1PunchCount = this.sendOfferTimes,
                i.nat1PunchOkCount = this.recvOfferTimes,
                i.nat2PunchCount = this.sendAnswerTimes,
                i.nat2PunchOkCount = this.recvAnswerTimes,
                i.nat3PunchCount = this.sendCandidateTimes,
                i.nat3PunchOkCount = this.recvCandidateTimes,
                i.peerChannelNum3 = this.recvAnswerButRejectTimes,
                i.peerChannelNum4 = this.hasPublicAddrTimes,
                this.resetPunchData(),
                i.nat1PunchElapse = n.connectElapseAvg,
                i.nat2PunchElapse = n.firstRecvElapseAvg,
                i.nat3PunchElapse = n.totalRecvElapseAvg,
                i.totalDuration = this.totalDuration;
                var o = this.setExtInfo(n);
                t !== W.TaskStop && t !== W.Period || (o.IsVideoIn = this.isVideoIn,
                o.IsADMid = this.isAdInsert),
                t === W.InitProxy && (i.loadingDuration = Math.round(this.canPlayTime - this.createTime),
                o.ct = Math.round(this.createTime),
                o.st = Math.round(this.startTime),
                o.fl = Math.round(this.firstLoadTime),
                o.fs = Math.round(this.firstSendDataTime),
                o.ffs = Math.round(this.firstFinishSendDataTime),
                o.cp = Math.round(this.canPlayTime),
                o.ipx = Math.round(e.initProxyTime),
                o.ipp = Math.round(e.initP2PTime)),
                i.extInfo = JSON.stringify(o),
                this.isNeedReport(i) && (re.getInstance().reportToAtta(i, r),
                r || this.printReportInfo(i))
            }
            ,
            e.prototype.updateLatestBitrate = function(e) {
                this.bitrateLatest.length >= Lr.maxLastBitrateCount && this.bitrateLatest.shift(),
                this.bitrateLatest.push(e)
            }
            ,
            e.prototype.getAvgBitrate = function() {
                var e = this.bitrateLatest.length;
                if (0 === e)
                    return 0;
                for (var t = 0, r = 0; r < e; r++)
                    t += this.bitrateLatest[r];
                return t / e
            }
            ,
            e.prototype.getDownloadInfo = function() {
                var e = (1 * this.realTimeP2P / 1024).toFixed(2)
                  , t = (1 * this.realTimeP2PUpload / 1024).toFixed(2)
                  , r = (this.p2pDownloadBytes / 1024 / 1024).toFixed(2)
                  , i = this.p2pDownloadBytes + this.httpDownloadBytes
                  , n = i ? (100 * this.p2pDownloadBytes / i).toFixed(2) : 0
                  , a = (1 * this.realTimeHttp / 1024).toFixed(2)
                  , o = (this.httpDownloadBytes / 1024 / 1024).toFixed(2)
                  , s = (this.p2pUploadByte / 1024 / 1024).toFixed(2)
                  , l = 0
                  , c = 0
                  , h = 0
                  , u = 0;
                return 0 !== this.dataReqCount && (l = 100 * (this.dataReqCount - this.validDataRspCount) / this.dataReqCount),
                0 !== this.dataRspCount && (c = 100 * this.redundancyDataCount / this.dataRspCount),
                0 !== this.httpDownloadBytes && (h = 100 * this.httpRepeatByte / this.httpDownloadBytes),
                0 !== this.p2pDownloadBytes && (u = 100 * this.p2pRepeatByte / this.p2pDownloadBytes),
                {
                    httpDownload: o,
                    p2pDownload: r,
                    p2pUpload: s,
                    p2pScore: n,
                    httpSpeed: a,
                    p2pDownloadSpeed: e,
                    p2pUploadSpeed: t,
                    httpRepeat: h,
                    p2pRepeat: u,
                    loss: l,
                    redundance: c
                }
            }
            ,
            e.prototype.getSpeedArrayStr = function() {
                var e, t, r = "speed:";
                try {
                    for (var i = C(this.speedArray), n = i.next(); !n.done; n = i.next()) {
                        r += n.value + " "
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getRealHttpSpeed = function() {
                return this.realTimeHttp
            }
            ,
            e.prototype.getRealP2PSpeed = function() {
                return this.realTimeP2P
            }
            ,
            e.prototype.setTaskInfo = function(e) {
                this.taskInfo = e,
                this.taskInfo.taskType === B.Live && (this.isGotTPT = !0)
            }
            ,
            e.prototype.getP2PFlag = function() {
                if (!Lr.useP2P)
                    return V.NOT_USE_P2P;
                if (!this.taskInfo.useP2P)
                    return V.NOT_P2P_Flow;
                if (0 !== re.getInstance().supportWebRTC)
                    return re.getInstance().supportWebRTC;
                if (!this.psIsLogin())
                    return V.PS_LOGIN_FAIL;
                if (!this.isGotTPT)
                    return V.TPT_NOT_GOT;
                var e = $t.getInstance().getPeerNumForReport(this.taskInfo.keyID);
                return e.downIdle + e.downConnected + e.downConnecting <= 0 ? V.SEED_NOT_FOUND : e.downConnected + e.up - e.upAndDown <= 0 ? V.PUNCH_FAILED : V.SUCCEED
            }
            ,
            e.prototype.addTsElapse = function(e, t, r) {
                this.connectElapseSum += e,
                this.firstRecvElapseSum += t,
                this.totalRecvElapseSum += r,
                this.tsCount += 1
            }
            ,
            e.prototype.onReportSchedule = function() {
                this.calRealTimeSpeed(),
                this.reportInterval -= 1,
                -1 === this.reportInterval && (this.reportInterval = this.taskState === M.Preload ? Lr.preloadReportInterval : Lr.reportInterval,
                this.report()),
                this.httpCheckInterval -= 1,
                -1 === this.httpCheckInterval && (this.httpCheckInterval = Lr.httpCheckInterval,
                this.calcCheckSpeed())
            }
            ,
            e.prototype.calRealTimeSpeed = function() {
                var e;
                e = L(this.trafficStats.updateTrafficForRealTimeSpeed(this.httpDownloadBytes, this.p2pDownloadBytes, this.p2pUploadByte, this.httpRecvElapseSum), 3),
                this.realTimeHttp = e[0],
                this.realTimeP2P = e[1],
                this.realTimeP2PUpload = e[2]
            }
            ,
            e.prototype.calcCheckSpeed = function() {
                var e = this.httpDownloadBytes - this.lastCheckCDNLoadBytes;
                if (this.avgSpeedInHttpCheckInterval = e / Lr.httpCheckInterval,
                this.lastCheckCDNLoadBytes = this.httpDownloadBytes,
                this.speedArray.length >= 12 && this.speedArray.splice(0, 1),
                this.speedArray.push(this.avgSpeedInHttpCheckInterval),
                Lr.useP2P) {
                    var t = this.p2pDownloadBytes - this.lastCheckP2PLoadBytes;
                    this.avgSpeedInP2P = t / Lr.httpCheckInterval,
                    this.lastCheckP2PLoadBytes = this.p2pDownloadBytes
                }
            }
            ,
            e.prototype.setExtInfo = function(e) {
                var t = {};
                return -1 !== J.cpuThreads && (t.cpuThreads = J.cpuThreads),
                -1 !== J.heapSizeLimit && (t.heapSizeLimit = J.heapSizeLimit),
                this.isGenFileID && (t.isGenFileID = !0),
                void 0 !== this.taskInfo.encoding && (t.encoding = this.taskInfo.encoding),
                e.p2pCheckFailByte && (t.checkFail = e.p2pCheckFailByte),
                e.p2pFileSizeWrongBtye && (t.filesizeWrong = e.p2pFileSizeWrongBtye),
                e.p2pRspFailByte && (t.rspFail = e.p2pRspFailByte),
                e.p2pKeyIDWrongByte && (t.keyIDWrong = e.p2pKeyIDWrongByte),
                e.p2pUploadWrongdataCount && (t.wrongData = e.p2pUploadWrongdataCount),
                e.p2pNotAllowByte && (t.notAllow = e.p2pNotAllowByte),
                this.processMode === H.FrontEnd && this.taskInfo.taskType === B.Vod && (t.initDB = re.getInstance().initDB,
                t.initDB === j.OpenFailed && (t.initDBFailReason = re.getInstance().initDBFailReason)),
                t.reduceLevel = this.reduceLevel,
                t
            }
            ,
            e.prototype.printReportInfo = function(e) {
                Ar.info("TaskStats", "keyID:" + e.keyID, "printReportInfo :\nversion=" + Tr.getReportVersion() + "\nosVer=" + J.osVer + "\nguid=" + J.playerInfo.guid + "\nbroVer=" + J.browserVer + "\nplatform=" + J.playerInfo.platform + "\nqq=" + J.playerInfo.qq + "\nwx=" + J.playerInfo.wx + "\nkeyID=" + e.keyID + "\nisCharge=" + e.isCharge + "\np2pFlag=" + e.p2pFlag + "\nhttp=" + e.http + "\nhttpSpeed=" + (e.httpSpeed / 1024).toFixed(2) + " KB/s\nhttpSpeedAvg=" + (e.httpSpeedAvg / 1024).toFixed(2) + " KB/s\n")
            }
            ,
            e.prototype.resetPunchData = function() {
                this.natPunchCount = 0,
                this.natPunchOKCount = 0,
                this.natPunchElapse = 0,
                this.sendOfferTimes = 0,
                this.recvOfferTimes = 0,
                this.sendAnswerTimes = 0,
                this.recvAnswerTimes = 0,
                this.sendCandidateTimes = 0,
                this.recvCandidateTimes = 0,
                this.recvAnswerButRejectTimes = 0,
                this.hasPublicAddrTimes = 0
            }
            ,
            e.prototype.psIsLogin = function() {
                return (this.taskInfo.taskType === B.Vod ? hr : ur).getInstance().isLogin()
            }
            ,
            e.prototype.isNeedReport = function(e) {
                return (2 !== e.processMode || e.http + e.p2p + e.upload + e.uploadSpeed + e.uploadPeerNum + e.nat1PunchOkCount + e.nat2PunchCount + e.nat3PunchCount + e.nat3PunchOkCount !== 0) && (e.http + e.p2p + e.upload > 0 || 1e3 * Math.random() < Lr.playQualityReportRate)
            }
            ,
            e.initProxyTime = 0,
            e.initP2PTime = 0,
            e.instances = new Map,
            e
        }()
          , ce = function() {
            function e() {
                this.cacheMap = new Map,
                this.snMap = new Map,
                this.p2pMap = new Map
            }
            return e.prototype.snToIndex = function(e) {
                return this.snMap.get(e)
            }
            ,
            e.prototype.p2pToIndex = function(e) {
                return this.p2pMap.get(e)
            }
            ,
            e.prototype.cacheToIndex = function(e) {
                return this.cacheMap.get(e)
            }
            ,
            e
        }()
          , he = function(e) {
            function t(t) {
                var r = e.call(this) || this;
                return r.setIndexMap(t),
                r
            }
            return E(t, e),
            t.prototype.setIndexMap = function(e) {
                var t = this
                  , r = 0
                  , i = -1;
                e.forEach((function(e) {
                    var n = {
                        sn: e.sn,
                        cache: r,
                        p2p: void 0
                    };
                    switch (e.tsType) {
                    case F.AdInsert:
                        n.cache = i,
                        i -= 1;
                        break;
                    case F.VideoIn:
                        n.p2p = null,
                        r += 1;
                        break;
                    case F.Normal:
                    default:
                        n.p2p = r,
                        r += 1
                    }
                    t.snMap.set(n.sn, n),
                    t.cacheMap.set(n.cache, n),
                    null !== n.p2p && void 0 !== n.p2p && t.p2pMap.set(n.p2p, n)
                }
                ))
            }
            ,
            t.prototype.getIterator = function(e) {
                var t, r, i, n, a, o;
                return k(this, (function(s) {
                    switch (s.label) {
                    case 0:
                        s.trys.push([0, 5, 6, 7]),
                        t = C(this.snMap),
                        r = t.next(),
                        s.label = 1;
                    case 1:
                        return r.done ? [3, 4] : (i = r.value,
                        !e || i[0] >= e.sn ? [4, i[1]] : [3, 3]);
                    case 2:
                        s.sent(),
                        s.label = 3;
                    case 3:
                        return r = t.next(),
                        [3, 1];
                    case 4:
                        return [3, 7];
                    case 5:
                        return n = s.sent(),
                        a = {
                            error: n
                        },
                        [3, 7];
                    case 6:
                        try {
                            r && !r.done && (o = t.return) && o.call(t)
                        } finally {
                            if (a)
                                throw a.error
                        }
                        return [7];
                    case 7:
                        return [2]
                    }
                }
                ))
            }
            ,
            t
        }(ce)
          , ue = function(e) {
            function t(t) {
                var r = e.call(this) || this;
                return r.cacheLength = 0,
                r.minSn = Number.MAX_SAFE_INTEGER,
                r.maxSn = Number.MIN_SAFE_INTEGER,
                r.setIndexMap(t),
                r
            }
            return E(t, e),
            t.prototype.setIndexMap = function(e) {
                var t = this;
                e.forEach((function(e) {
                    if (!t.snMap.has(e.sn)) {
                        var r = {
                            sn: e.sn,
                            cache: t.cacheLength,
                            p2p: void 0
                        };
                        e.tsType === F.Normal && (r.p2p = e.sn,
                        t.maxSn = Math.max(t.maxSn, e.sn),
                        t.minSn = Math.min(t.minSn, e.sn)),
                        t.cacheLength += 1,
                        t.snMap.set(r.sn, r),
                        t.cacheMap.set(r.cache, r),
                        void 0 !== r.p2p && t.p2pMap.set(r.p2p, r)
                    }
                }
                ))
            }
            ,
            t.prototype.getIterator = function(e) {
                var t;
                return k(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        t = null == e ? void 0 : e.sn,
                        e || (t = this.minSn),
                        r.label = 1;
                    case 1:
                        return t <= this.maxSn ? void 0 === this.snToIndex(t) ? [3, 3] : [4, this.snToIndex(t)] : [3, 4];
                    case 2:
                        r.sent(),
                        r.label = 3;
                    case 3:
                        return t++,
                        [3, 1];
                    case 4:
                        return [2]
                    }
                }
                ))
            }
            ,
            t
        }(ce)
          , de = function() {
            function e() {
                this.indexAdapterList = new Map
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.prototype.setIndexAdapter = function(e, t, r) {
                var i = r === B.Live ? new ue(t) : new he(t);
                return this.indexAdapterList.set(e, i),
                i
            }
            ,
            e.prototype.getIndexAdapter = function(e) {
                return this.indexAdapterList.get(e)
            }
            ,
            e.prototype.deleteAdapter = function(e) {
                this.indexAdapterList.delete(e)
            }
            ,
            e.prototype.updateIndexAdapter = function(e, t) {
                this.indexAdapterList.get(e).setIndexMap(t)
            }
            ,
            e
        }();
        function fe(e, t, r) {
            var i = function(e) {
                return parseFloat("0." + Math.sin(e).toString().substr(6))
            }(r);
            return Math.floor(i * (t - e)) + e
        }
        var pe = function() {
            function e() {
                this.isGotConfig = !1,
                this.tryTimes = 0,
                this.configServerHost = "",
                this.configServerPort = 0,
                this.lastConnectTime = 0
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.prototype.reqConfig = function() {
                if (this.isGotConfig = !1,
                this.tryTimes += 1,
                !(this.tryTimes > 5)) {
                    Ar.info("Config", "", "Request server config.");
                    var e = this.getConfigUrl()
                      , t = Tr.parseUrl(e);
                    this.configServerHost = t.host,
                    this.configServerPort = t.port,
                    this.lastConnectTime = performance.now();
                    var r = {
                        url: e,
                        timeout: 6e3,
                        onloadsuccess: this.loadSuccess.bind(this),
                        onerror: this.loadError.bind(this),
                        ontimeout: this.loadTimeout.bind(this)
                    };
                    te.xhrSend(r)
                }
            }
            ,
            e.prototype.getConfigUrl = function() {
                return J.configUrl + "&subver=V_0." + J.version + "&platform=" + J.playerInfo.platform + "&guid=" + J.playerInfo.guid
            }
            ,
            e.prototype.loadSuccess = function(e) {
                var t = JSON.parse(e.response);
                return 0 !== t.code ? (Ar.info("Config", "", "Request config fail, return:" + t.code),
                void this.reportCSSvrQuality(ne.CSSvrRetError, t.code)) : t.data ? (ve(JSON.parse(t.data)),
                Ar.info("Config", "", "Request config success, config:" + t.data),
                this.reportCSSvrQuality(ne.CSRecvSuccess, 0),
                this.tryTimes = 0,
                this.isGotConfig = !0,
                void (this.reqTimer = self.setTimeout(this.reqConfig.bind(this), 1e3 * Lr.reqConfigInterval))) : (Ar.info("Config", "", "Request config fail, no context, data:" + e.response),
                void this.reportCSSvrQuality(ne.CSNoContext, 0))
            }
            ,
            e.prototype.loadError = function(e) {
                Ar.info("Config", "", "Request config fail, err: " + e.target.status),
                this.reportCSSvrQuality(ne.CSUnknownError, 0),
                this.reqConfig()
            }
            ,
            e.prototype.loadTimeout = function() {
                Ar.info("Config", "", "Request config fail err: timeout"),
                this.reportCSSvrQuality(ne.CSSocketConnectTimeout, 0),
                this.reqConfig()
            }
            ,
            e.prototype.reportCSSvrQuality = function(e, t) {
                var r = {
                    tryTimes: this.tryTimes,
                    svrType: Y.SrvCfg,
                    svrIP: this.configServerHost,
                    svrPort: this.configServerPort,
                    errCode: e,
                    svrRetCode: t,
                    connectElapse: performance.now() - this.lastConnectTime
                };
                re.getInstance().reportSvrQuality(r)
            }
            ,
            e
        }();
        function ge(e) {
            var t;
            t = e,
            Er = Object.assign(Er, t),
            ye()
        }
        function ve(e) {
            ge(e),
            function() {
                var e, t;
                if (J.abTestID = -1,
                !Lr.isOpenABTest)
                    return !0;
                var r = Lr.abTestOption.split(";");
                if (r.length <= 0)
                    return Ar.warn("Config", "", "Abtest open but options is empty"),
                    !0;
                var i = -1
                  , n = -1;
                try {
                    for (var a = C(r), o = a.next(); !o.done; o = a.next()) {
                        var s = o.value.split(":");
                        if (2 !== s.length)
                            return !1;
                        var l = s[0]
                          , c = s[1].split("/");
                        if (c.length < 2)
                            return !1;
                        if (-1 === i)
                            i = c.length,
                            n = Lr.abTestHashKeyUseGUID ? fe(0, i, parseInt(J.playerInfo.guid, 16)) : fe(0, i, (new Date).getTime());
                        else if (i !== c.length)
                            return !1;
                        if (n >= c.length)
                            return !1;
                        "true" === c[n] ? Lr[l] = !0 : "false" === c[n] ? Lr[l] = !1 : isNaN(+c[n]) ? Lr[l] = c[n] : Lr[l] = +c[n],
                        Ar.info("Config", "", "ABTest Config: set " + l + " to testID: " + n + ", value: " + Lr[l] + ".")
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        o && !o.done && (t = a.return) && t.call(a)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return J.abTestID = n,
                ye(),
                !0
            }() || (Ar.warn("Config", "", "Abtest config check fail."),
            ge(e))
        }
        function ye() {
            Lr.vodAdjustHttpBufferTime !== br.vodAdjustHttpBufferTime && function() {
                var e, t, r, i, n, a, o = !0, s = 0, l = Lr.vodAdjustHttpBufferTime.split(",");
                try {
                    for (var c = C(l), h = c.next(); !h.done; h = c.next()) {
                        var u = h.value.split(" ");
                        if (3 !== u.length) {
                            o = !1;
                            break
                        }
                        var d = u[0].split("-");
                        if (2 !== d.length) {
                            o = !1;
                            break
                        }
                        if (r = parseInt(d[0], 10),
                        i = parseInt(d[1], 10),
                        n = parseInt(u[1], 10),
                        a = parseInt(u[2], 10),
                        !(r === s && i < 24 && i > 0 && n > 0 && a > 0)) {
                            o = !1;
                            break
                        }
                        s = i
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        h && !h.done && (t = c.return) && t.call(c)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                o || (Lr.vodAdjustHttpBufferTime = br.vodAdjustHttpBufferTime)
            }(),
            J.playerInfo.device === G.Phone ? Lr.maxCacheSize = Lr.defaultCacheSize : Lr.useAdaptiveCache ? J.heapSizeLimit >= 4e3 ? Lr.maxCacheSize = Lr.maxCacheSizeLevel3 : J.heapSizeLimit >= 2e3 ? Lr.maxCacheSize = Lr.maxCacheSizeLevel2 : J.heapSizeLimit >= 1e3 ? Lr.maxCacheSize = Lr.maxCacheSizeLevel1 : Lr.maxCacheSize = Lr.maxCacheSizeLevel0 : Lr.maxCacheSize = Lr.defaultCacheSize,
            J.playerInfo.device === G.Phone ? Lr.baseConnectPeerNumber = Lr.defaultConnectPeerNumber : Lr.useAdaptiveThreadConfig ? J.cpuThreads >= 16 ? Lr.baseConnectPeerNumber = Lr.baseConnectPeerNumberLevel3 : J.cpuThreads >= 12 ? Lr.baseConnectPeerNumber = Lr.baseConnectPeerNumberLevel2 : J.cpuThreads >= 8 ? Lr.baseConnectPeerNumber = Lr.baseConnectPeerNumberLevel1 : Lr.baseConnectPeerNumber = Lr.baseConnectPeerNumberLevel0 : Lr.baseConnectPeerNumber = Lr.defaultConnectPeerNumber,
            Lr.vodUseDbCache && Tr.vodP2POpended && !ut.getDBCache() && ut.getInstance().initDBCache()
        }
        var me = function() {
            function e(e, t, r) {
                this.connectTimes = 0,
                this.requestIndex = null,
                this.loadStatus = N.Idel,
                this.offset = 0,
                this.delayTimer = void 0,
                this.downloadTime = 0,
                this.recvTime = 0,
                this.rangeStart = void 0,
                this.rangeEnd = void 0,
                this.useRangeReq = !1,
                this.callbacks = e,
                this.config = t,
                this.connectTimeout = t.connectTimeout,
                this.recvTimeout = t.recvTimeout,
                this.loadStatus = N.Idel,
                this.seq = r
            }
            return e.prototype.load = function(e) {
                this.requestIndex = e.index,
                this.loadUrl = e.url,
                this.responseType = "arraybuffer",
                0 === e.start && -1 === e.end || (this.rangeStart = e.start,
                this.rangeEnd = e.end,
                this.useRangeReq = !0),
                this.retryDelay = this.config.retryDelay,
                this.maxRetry = 0,
                this.connectElapse = 0,
                this.firstRecvElapse = 0,
                this.totalRecvElapse = 0,
                this.loadInternal()
            }
            ,
            e.prototype.onDownloadFailed = function(e) {
                if (this.loadUrl && null !== this.requestIndex) {
                    var t = Tr.parseUrl(this.loadUrl)
                      , r = {
                        tryTimes: this.connectTimeout,
                        svrType: Y.CDNServer,
                        svrIP: t.host,
                        svrPort: t.port,
                        errCode: e,
                        svrRetCode: X.ERR_COMMON,
                        connectElapse: this.connectElapse ? this.connectElapse : 0,
                        firstRecvElapse: this.firstRecvElapse ? this.firstRecvElapse : 0,
                        totalRecvElapse: this.totalRecvElapse ? this.totalRecvElapse : 0,
                        url: this.loadUrl
                    };
                    re.getInstance().reportSvrQuality(r)
                }
            }
            ,
            e.prototype.isStop = function() {
                return this.loadStatus === N.Stop
            }
            ,
            e.prototype.unregisterCallBack = function() {
                this.callbacks = void 0
            }
            ,
            e.prototype.getrequestIndex = function() {
                return this.requestIndex
            }
            ,
            e.prototype.isIdle = function() {
                return this.loadStatus === N.Idel
            }
            ,
            e.prototype.getLogStatus = function() {
                return "Task:" + this.seq + ",status:" + N[this.loadStatus] + ",sn:" + this.requestIndex.sn
            }
            ,
            e.prototype.stop = function() {
                if (!this.isStop()) {
                    var e = 0;
                    void 0 !== this.offset && 0 !== this.totalRecvElapse && (e = 1e3 * this.offset / this.totalRecvElapse / 1024),
                    Ar.info(this.getLogScope(), this.getLogStatus(), "Stop. conn_time:" + this.connectElapse + "ms,cost first_recv_time:" + this.firstRecvElapse + "ms,total_recv_time:" + this.totalRecvElapse + "ms readLen:" + this.offset + "B speed:" + e.toFixed(2) + "KB/s"),
                    this.delayTimer && (clearInterval(this.delayTimer),
                    this.delayTimer = void 0),
                    this.loadStatus = N.Stop,
                    this.downloadTime = 0,
                    this.recvTime = 0
                }
            }
            ,
            e.prototype.loadInternal = function() {}
            ,
            e.prototype.onConnecting = function() {
                void 0 === this.delayTimer && (this.delayTimer = self.setInterval(this.onDelaySchedule.bind(this), J.secondTimer)),
                this.loadStatus = N.Connecting,
                this.downloadTime = performance.now()
            }
            ,
            e.prototype.onLoading = function() {
                this.connectElapse || (this.connectElapse = parseFloat((performance.now() - this.downloadTime).toFixed(2))),
                this.recvTime = performance.now(),
                this.loadStatus = N.Loading
            }
            ,
            e.prototype.onLoadSuccess = function(e, t, r) {
                var i, n;
                Ar.info(this.getLogScope(), this.getLogStatus(), "onLoadSuccess"),
                le.getItem(this.config.keyID).addTsElapse(this.connectElapse, this.firstRecvElapse, this.totalRecvElapse),
                this.stop(),
                null === (i = this.callbacks) || void 0 === i || i.onLoadHeaders(r),
                null === (n = this.callbacks) || void 0 === n || n.onSuccess(e, t),
                this.unregisterCallBack()
            }
            ,
            e.prototype.onLoadError = function(e, t, r) {
                var i;
                this.stop(),
                null === (i = this.callbacks) || void 0 === i || i.onError(e, t, r),
                this.unregisterCallBack()
            }
            ,
            e.prototype.onDelaySchedule = function() {
                if (Lr.useTimeoutCtrl) {
                    var e = performance.now();
                    if (this.loadStatus === N.Connecting)
                        e - this.downloadTime > this.config.connectTimeout && (Ar.info(this.getLogScope(), this.getLogStatus(), "Connecting: timeout"),
                        this.handleConnectTimeout());
                    else {
                        if (this.loadStatus !== N.Loading)
                            return;
                        if (e - this.recvTime > this.config.recvTimeout) {
                            var t = 0;
                            void 0 !== this.offset && 0 !== this.totalRecvElapse && (t = 1e3 * this.offset / this.totalRecvElapse / 1024),
                            Ar.info(this.getLogScope(), this.getLogStatus(), "Loading: timeout loaded:" + this.offset + "Bytes, speed:" + t.toFixed(2) + "KB/s"),
                            this.handleRecvTimeout()
                        }
                    }
                }
            }
            ,
            e.prototype.handleConnectTimeout = function() {
                this.stop(),
                this.callbacks && this.callbacks.onTimeout(this.requestIndex, ne.HTTPConnectTimeOut),
                this.unregisterCallBack()
            }
            ,
            e.prototype.handleRecvTimeout = function() {
                this.stop(),
                this.callbacks && this.callbacks.onTimeout(this.requestIndex, ne.HTTPRevDataTimeout),
                this.unregisterCallBack()
            }
            ,
            e
        }()
          , Te = 4
          , Se = function(e) {
            function t(t, r, i) {
                var n = e.call(this, t, r, i) || this;
                return n.downloadType = "xhr",
                n
            }
            return E(t, e),
            t.prototype.abort = function() {
                this.stop()
            }
            ,
            t.prototype.stop = function() {
                e.prototype.stop.call(this),
                this.loader && this.loader.readyState !== Te && this.loader.abort()
            }
            ,
            t.prototype.getLogScope = function() {
                return "XHRLoader"
            }
            ,
            t.prototype.loadInternal = function() {
                var e = {
                    method: "get",
                    url: this.loadUrl,
                    responseType: this.responseType,
                    onloadstart: this.loadstart.bind(this),
                    onloadprogress: this.loadprogress.bind(this),
                    onloadsuccess: this.loadsuccess.bind(this),
                    onerror: this.loaderror.bind(this)
                };
                this.useRangeReq && (e.range = [this.rangeStart, this.rangeEnd]),
                this.onConnecting(),
                Ar.info(this.getLogScope(), this.getLogStatus(), "loadInternal, " + (this.useRangeReq ? "range: " + this.rangeStart + "-" + this.rangeEnd + ", " : "") + "url = " + this.loadUrl),
                this.loader = te.xhrSend(e)
            }
            ,
            t.prototype.loadstart = function() {
                this.isStop() || (this.firstRecvElapse || (this.firstRecvElapse = performance.now() - this.downloadTime),
                this.onLoading())
            }
            ,
            t.prototype.loadsuccess = function(e) {
                if (!this.isStop()) {
                    var t, r;
                    if (r = "arraybuffer" === this.responseType ? (t = e.response).byteLength : (t = e.responseText).length,
                    this.useRangeReq && 206 !== e.status)
                        return Ar.warn(this.getLogScope(), this.getLogStatus(), "useRangeReq but status != 206, url: " + this.loadUrl),
                        void this.onLoadError(ne.HTTPRangeSupportError, this.requestIndex);
                    this.totalRecvElapse = parseFloat((performance.now() - this.downloadTime).toFixed(2));
                    var i = void 0;
                    if (this.useRangeReq) {
                        var n = e.getResponseHeader("content-range");
                        if (null === n)
                            return Ar.warn(this.getLogScope(), this.getLogStatus(), "cannot get content-range header: " + this.loadUrl),
                            void this.onLoadError(ne.HTTPRangeSupportError, this.requestIndex);
                        i = parseInt(n.match(/^bytes\s[0-9]+-[0-9]+\/([0-9]+)$/)[1], 10),
                        Ar.info(this.getLogScope(), this.getLogStatus(), "Get filesize: " + i + " from content-range.")
                    } else
                        i = r,
                        Ar.info(this.getLogScope(), this.getLogStatus(), "Get filesize: " + i + " from byteLength.");
                    i > 0 && this.callbacks.onFileSize(this.requestIndex, i),
                    this.offset = r;
                    var a = this.useRangeReq ? this.rangeStart : 0
                      , o = {
                        url: e.responseURL,
                        data: t,
                        offset: a
                    };
                    this.onLoadSuccess(o, this.requestIndex, this.getHeaders())
                }
            }
            ,
            t.prototype.loaderror = function(e) {
                "xhrNetworkError" === e.type ? (Ar.error(this.getLogScope(), this.getLogStatus(), "xhr.onerror url: " + this.loadUrl),
                this.onLoadError(ne.TSXhrOnError, this.requestIndex)) : (Ar.error(this.getLogScope(), this.getLogStatus(), "error status: " + e.target.status + ", url: " + this.loadUrl),
                this.onLoadError(ne.TSXhrErrorBase + e.target.status, this.requestIndex, this.getHeaders()))
            }
            ,
            t.prototype.loadprogress = function(e) {
                this.firstRecvElapse || (this.firstRecvElapse = performance.now() - this.downloadTime);
                var t = parseFloat((performance.now() - this.downloadTime).toFixed(2));
                le.getItem(this.config.keyID).httpDownloadBytes += e.loaded - this.offset,
                le.getItem(this.config.keyID).httpRecvElapseSum += t - this.totalRecvElapse,
                this.totalRecvElapse = t,
                this.offset = e.loaded
            }
            ,
            t.prototype.getHeaders = function() {
                var e, t = {};
                return (null === (e = this.loader) || void 0 === e ? void 0 : e.getAllResponseHeaders()).split("\r\n").filter((function(e) {
                    return "" !== e
                }
                )).forEach((function(e) {
                    var r = e.split(": ");
                    r.length >= 2 && (t[r.shift()] = r.join(": "))
                }
                )),
                t
            }
            ,
            t
        }(me)
          , Ie = function(e) {
            function t(t, r, i) {
                var n = e.call(this, t, r, i) || this;
                return n.headers = {},
                n.controller = new AbortController,
                n.downloadType = "fetch",
                n.cancel = !1,
                n.reader = void 0,
                n.readEnd = !1,
                n
            }
            return E(t, e),
            t.prototype.abort = function() {
                this.stop()
            }
            ,
            t.prototype.stop = function() {
                this.isStop() || (this.cancleFetch(),
                e.prototype.stop.call(this))
            }
            ,
            t.prototype.getLogScope = function() {
                return "FetchLoader"
            }
            ,
            t.prototype.readFinish = function() {
                this.reader = void 0,
                this.readEnd = !0
            }
            ,
            t.prototype.cancleFetch = function() {
                if (!this.readEnd)
                    if (void 0 !== this.reader)
                        try {
                            this.reader.cancel(),
                            this.controller.abort(),
                            this.readFinish(),
                            Ar.info(this.getLogScope(), this.getLogStatus(), "cancleFetch : reader cancel")
                        } catch (e) {
                            this.readFinish(),
                            Ar.error(this.getLogScope(), this.getLogStatus(), "cancleFetch : reader cancel fail:" + e)
                        }
                    else
                        this.cancel = !0,
                        Ar.info(this.getLogScope(), this.getLogStatus(), "cancleFetch : set cancel true")
            }
            ,
            t.prototype.loadInternal = function() {
                var e = this
                  , t = this.loadUrl
                  , r = new Headers;
                this.useRangeReq && r.append("Range", "bytes=" + this.rangeStart + "-" + this.rangeEnd);
                var i = new Request(t,{
                    mode: "cors",
                    headers: r
                });
                Ar.info(this.getLogScope(), this.getLogStatus(), "LoadInternal," + (this.useRangeReq ? "range: " + this.rangeStart + "-" + this.rangeEnd + "," : "") + " url = " + t),
                this.onConnecting(),
                fetch(i, {
                    signal: this.controller.signal
                }).then((function(t) {
                    var r;
                    if (!e.isStop()) {
                        if (e.onLoading(),
                        t.headers.forEach((function(t, r) {
                            e.headers[r] = t
                        }
                        )),
                        t.status >= 400 || t.status < 200)
                            return e.readFinish(),
                            void e.onLoadError(ne.TSFetchErrorBase + t.status, e.requestIndex, e.headers);
                        if (e.useRangeReq && 206 !== t.status)
                            return Ar.warn(e.getLogScope(), e.getLogStatus(), "useRangeReq but status " + t.status + " != 206, url: " + e.loadUrl),
                            void e.onLoadError(ne.HTTPRangeSupportError, e.requestIndex);
                        if (e.reader = null === (r = t.body) || void 0 === r ? void 0 : r.getReader(),
                        e.cancel)
                            e.cancleFetch();
                        else {
                            var i = void 0;
                            if (e.useRangeReq) {
                                var n = t.headers.get("content-range");
                                if (null === n)
                                    return Ar.warn(e.getLogScope(), e.getLogStatus(), "cannot get content-range header: " + e.loadUrl),
                                    void e.onLoadError(ne.HTTPRangeSupportError, e.requestIndex);
                                i = parseInt(n.match(/^bytes\s[0-9]+-[0-9]+\/([0-9]+)$/)[1], 10),
                                Ar.info(e.getLogScope(), e.getLogStatus(), "Get filesize: " + i + " from content-range.")
                            } else
                                i = parseInt(t.headers.get("Content-Length"), 10),
                                Ar.info(e.getLogScope(), e.getLogStatus(), "Get filesize: " + i + " from content-length.");
                            i > 0 && e.callbacks.onFileSize(e.requestIndex, i),
                            e.firstRecvElapse = parseFloat((performance.now() - e.downloadTime).toFixed(2)),
                            e.readData()
                        }
                    }
                }
                )).catch((function(t) {
                    e.readFinish(),
                    Ar.warn(e.getLogScope(), e.getLogStatus(), "LoadInternal, Catch error " + t + ", url: " + e.loadUrl),
                    e.onLoadError(ne.TSFetchCatchError, e.requestIndex)
                }
                ))
            }
            ,
            t.prototype.readData = function() {
                var e = this;
                if (!this.isStop() && void 0 !== this.reader)
                    return this.reader.read().then((function(t) {
                        if (!e.isStop()) {
                            var r = t.value;
                            if (void 0 === r && !t.done)
                                return Ar.warn(e.getLogScope(), e.getLogStatus(), "Read data undefined"),
                                void e.readFinish();
                            if (void 0 !== r && r.byteLength > 0) {
                                var i = e.offset;
                                e.useRangeReq && (i += e.rangeStart);
                                var n = {
                                    data: r,
                                    offset: i
                                }
                                  , a = parseFloat((performance.now() - e.downloadTime).toFixed(2));
                                le.getItem(e.config.keyID).httpDownloadBytes += r.byteLength,
                                le.getItem(e.config.keyID).httpRecvElapseSum += a - e.totalRecvElapse,
                                e.totalRecvElapse = a,
                                e.callbacks.onProgress(n, e.requestIndex),
                                e.offset += r.byteLength
                            }
                            if (!t.done)
                                return e.readData();
                            e.totalRecvElapse = parseFloat((performance.now() - e.downloadTime).toFixed(2)),
                            e.readFinish();
                            n = {
                                data: null
                            };
                            e.onLoadSuccess(n, e.requestIndex, e.headers)
                        }
                    }
                    )).catch((function(t) {
                        e.readFinish(),
                        Ar.error(e.getLogScope(), e.getLogStatus(), "ReadData, Catch error " + t + ", url: " + e.loadUrl),
                        e.onLoadError(ne.TSFetchCatchError, e.requestIndex)
                    }
                    ))
            }
            ,
            t
        }(me)
          , Pe = function() {
            function e() {}
            return e.isSupportWebRtc = function() {
                return function() {
                    var e = !1;
                    try {
                        var t = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
                        if (t)
                            e = "createDataChannel"in new t({
                                iceServers: [{
                                    urls: "stun:0"
                                }]
                            })
                    } catch (t) {
                        e = !1
                    }
                    return e
                }() && ["RTCPeerConnection", "webkitRTCPeerConnection", "mozRTCPeerConnection"].some((function(e) {
                    return e in window
                }
                ))
            }
            ,
            e.checkP2PSupport = function() {
                return void 0 === this.supportP2P && (this.isSupportWebRtc() ? this.supportP2P = !0 : (this.supportP2P = !1,
                re.getInstance().supportWebRTC = V.RTC_NOT_SUP)),
                this.supportP2P
            }
            ,
            e.isSupportFetch = function() {
                return void 0 === this.supportFetch && this.checkFetchAndContentLengthSupport(),
                this.supportFetch
            }
            ,
            e.isSupportContentLength = function() {
                return void 0 === this.supportContentLength && this.checkFetchAndContentLengthSupport(),
                this.supportContentLength
            }
            ,
            e.checkFetchAndContentLengthSupport = function() {
                var e = ((navigator.userAgent || "") + " " + (navigator.appVersion || "") + " " + (navigator.vendor || "")).toLowerCase()
                  , t = /(chrome)[ /]([\w.]+)/.exec(e) || /(webkit)[ /]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ /]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || /(trident)(?:.*? rv:([\w.]+)|)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || []
                  , r = t[0]
                  , i = Number(t[2].split(".")[0]);
                0 === r.indexOf("chrome") && i >= 76 ? (window.disableNativeFetch = !1,
                this.supportFetch = !0,
                this.supportContentLength = !0) : 0 === r.indexOf("chrome") && i >= 46 ? (window.disableNativeFetch = !1,
                this.supportFetch = !0,
                this.supportContentLength = !1) : (window.disableNativeFetch = !0,
                this.supportFetch = !1,
                this.supportContentLength = !1),
                Ar.info("Global", "", "FetchSupport: " + this.supportFetch + ", ContentLengthSupport: " + this.supportContentLength + " engine: " + r + ", mainVersion: " + i)
            }
            ,
            e
        }()
          , be = function() {
            function e(e) {
                this.keyID = e.keyID,
                this.task = e,
                this.haveConnectTimeout = !1,
                this.isStoped = !1,
                this.httpDownloadFailedTimes = 0,
                this.lowSpeedCount = 0
            }
            return e.prototype.destroy = function() {
                this.setHTTPChoosed(!1),
                this.isStoped = !0,
                this.loader && (this.loader.isStop() || this.loader.abort(),
                this.loader.unregisterCallBack()),
                this.loader = void 0
            }
            ,
            e.prototype.downloadSchedule = function() {
                var e;
                this.canHTTPDownload() && (this.getLoadInfo(),
                this.loadInfo.url && this.loadInfo.index && ((null === (e = this.loader) || void 0 === e ? void 0 : e.getrequestIndex()) !== this.loadInfo.index || this.loader.isStop()) && (this.constructHTTPLoader(),
                this.setHTTPChoosed(!0),
                Ar.info(this.getLogScope(), this.getLogStatus(), "Select sn:" + this.loadInfo.index.sn + (0 !== this.loadInfo.start || -1 !== this.loadInfo.end ? " start: " + this.loadInfo.start + ", end: " + this.loadInfo.end : "") + " to download."),
                this.loader.load(this.loadInfo)))
            }
            ,
            e.prototype.checkLowSpeed = function() {
                !Lr.enableCDNSlowCallback || void 0 === this.loader || this.loader.isStop() || this.loader.isIdle() || (le.getItem(this.keyID).getRealHttpSpeed() < le.getItem(this.keyID).getAvgBitrate() / Lr.lowSpeedRatio ? (this.lowSpeedCount += 1,
                this.lowSpeedCount >= Lr.maxLowSpeedCount && (this.task.callbackError(ne.HTTPLowSpeed),
                this.lowSpeedCount = 0,
                Ar.warn(this.getLogScope(), this.getLogStatus(), "Low speed count >= " + Lr.maxLowSpeedCount + "."))) : this.lowSpeedCount = 0)
            }
            ,
            e.prototype.getHTTPHeaders = function() {
                return this.httpHeaders
            }
            ,
            e.prototype.canHTTPDownload = function() {
                return !!ut.getInstance().hasMediaFile(this.keyID) && !(this.loader && !this.loader.isStop())
            }
            ,
            e.prototype.getLogStatus = function() {
                return "Task:" + this.task.seq
            }
            ,
            e.prototype.constructHTTPLoader = function() {
                var e = {
                    maxRetry: 0,
                    retryDelay: 0,
                    maxRetryDelay: 64e3,
                    keyID: this.keyID,
                    connectTimeout: Number.MAX_SAFE_INTEGER,
                    recvTimeout: Number.MAX_SAFE_INTEGER
                }
                  , t = {
                    onError: this.httpLoadError.bind(this),
                    onTimeout: this.httpLoadTimeout.bind(this),
                    onFileSize: this.setFileSize.bind(this),
                    onLoadHeaders: this.setHTTPHeaders.bind(this)
                };
                this.canUseFetch() ? (Object.assign(t, {
                    onSuccess: this.httpFetchSuccess.bind(this),
                    onProgress: this.httpFetchProgress.bind(this)
                }),
                e.recvTimeout = Lr.fetchRecvTimeout,
                this.haveConnectTimeout ? e.connectTimeout = 2 * Lr.fetchConnectTimeout : e.connectTimeout = Lr.fetchConnectTimeout,
                this.loader = new Ie(t,e,this.task.seq)) : (Object.assign(t, {
                    onSuccess: this.httpXHRSuccess.bind(this),
                    onProgress: this.httpXHRProgress.bind(this)
                }),
                e.recvTimeout = Lr.xhrRecvTimeout,
                this.haveConnectTimeout ? e.connectTimeout = 2 * Lr.xhrConnectTimeout : e.connectTimeout = Lr.xhrConnectTimeout,
                this.loader = new Se(t,e,this.task.seq))
            }
            ,
            e.prototype.setFileSize = function(e, t) {
                ut.getInstance().setTsFileSize(this.keyID, e, t)
            }
            ,
            e.prototype.setHTTPHeaders = function(e) {
                this.httpHeaders = e
            }
            ,
            e.prototype.httpXHRSuccess = function(e, t) {
                this.isStoped || (this.retryTimeForReport = 0,
                this.httpDownloadFailedTimes = 0,
                this.insertDataIntoCache(e.data, t, e.offset),
                this.setHTTPChoosed(!1),
                this.updateBitrate(t),
                this.task.isInImmediateTime() && (Ar.debug(this.getLogScope(), this.getLogStatus(), "Immediate download after sn: " + t.sn + "."),
                this.downloadSchedule()))
            }
            ,
            e.prototype.httpFetchSuccess = function(e, t) {
                this.isStoped || (this.retryTimeForReport = 0,
                this.httpDownloadFailedTimes = 0,
                null !== e.data && this.insertDataIntoCache(e.data, t),
                this.setHTTPChoosed(!1),
                this.updateBitrate(t),
                this.task.isInImmediateTime() && (Ar.debug(this.getLogScope(), this.getLogStatus(), "Immediate download after sn: " + t.sn + "."),
                this.downloadSchedule()))
            }
            ,
            e.prototype.httpXHRProgress = function() {}
            ,
            e.prototype.httpFetchProgress = function(e, t) {
                this.isStoped || e.data.byteLength > 0 && this.insertDataIntoCache(e.data, t, e.offset)
            }
            ,
            e.prototype.httpLoadTimeout = function(e, t) {
                if (!this.isStoped) {
                    var r = le.getItem(this.keyID).getSpeedArrayStr();
                    Ar.warn(this.getLogScope(), this.getLogStatus(), "load Timeout, sn: " + e.sn + " code: " + t + " speed:" + r + "."),
                    t === ne.HTTPConnectTimeOut && (this.haveConnectTimeout = !0),
                    this.retryTimeForReport || (this.retryTimeForReport = 0),
                    this.retryTimeForReport += 1,
                    this.loader.connectTimes = this.retryTimeForReport,
                    this.loader.onDownloadFailed(t),
                    this.handleHttpLoadFail(t)
                }
            }
            ,
            e.prototype.httpLoadError = function(e, t, r) {
                this.isStoped || (Ar.warn(this.getLogScope(), this.getLogStatus(), "load Error : sn = " + t.sn + ", code=" + e + "."),
                e === ne.HTTPRangeSupportError && (this.task.canUseRange = !1),
                this.httpErrorReport(e),
                this.handleHttpLoadFail(e, r))
            }
            ,
            e.prototype.httpErrorReport = function(e) {
                this.retryTimeForReport || (this.retryTimeForReport = 0),
                this.retryTimeForReport += 1,
                this.loader.connectTimes = this.retryTimeForReport,
                this.loader.onDownloadFailed(e)
            }
            ,
            e.prototype.handleHttpLoadFail = function(e, t) {
                this.setHTTPChoosed(!1),
                this.httpDownloadFailedTimes += 1,
                this.task.playableTime > Lr.minReportErrorTime && (this.httpDownloadFailedTimes <= Lr.httpMaxFailedTimes || this.isTimeout(e)) ? this.downloadSchedule() : this.task.callbackError(e, t)
            }
            ,
            e.prototype.isTimeout = function(e) {
                return e === ne.HTTPConnectTimeOut || e === ne.HTTPRevDataTimeout
            }
            ,
            e.prototype.insertDataIntoCache = function(e, t, r) {
                void 0 === r && (r = 0),
                ut.getInstance().writeTsData(this.keyID, t, e, r, U.HTTP)
            }
            ,
            e.prototype.updateBitrate = function(e) {
                var t = ut.getInstance().getBitrateByIndex(this.keyID, e);
                le.getItem(this.keyID).updateLatestBitrate(t)
            }
            ,
            e.prototype.setHTTPChoosed = function(e) {
                if (0 !== this.loadInfo.start || -1 !== this.loadInfo.end)
                    for (var t = J.BLOCK_SIZE / J.PIECE_SIZE, r = this.loadInfo.headBlockID; r < this.loadInfo.tailBlockID; r++) {
                        var i = 0
                          , n = t;
                        r === this.loadInfo.headBlockID ? i = this.loadInfo.headPieceID : r === this.loadInfo.tailBlockID - 1 && (n = this.loadInfo.tailPieceID),
                        ut.getInstance().setPieceChoosed(this.keyID, this.loadInfo.index, r, i, n, U.HTTP, e)
                    }
                else
                    ut.getInstance().setTsChoosed(this.keyID, this.loadInfo.index, U.HTTP, e)
            }
            ,
            e.prototype.canUseFetch = function() {
                return !!(this.task.needFileSizeFromResponse && Pe.isSupportContentLength() && Pe.isSupportFetch()) || !(this.task.needFileSizeFromResponse || !Pe.isSupportFetch())
            }
            ,
            e
        }()
          , Ee = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.prototype.checkAbortLoader = function(e) {
                this.task.readSn !== e && this.loader && !this.loader.isStop() && this.loader.getrequestIndex().sn < e && this.loader.abort()
            }
            ,
            t.prototype.getLogScope = function() {
                return "LiveHTTPSchedule(" + this.task.seq + ")"
            }
            ,
            t.prototype.getLoadInfo = function() {
                if (this.loadInfo = {
                    index: null,
                    url: null,
                    start: 0,
                    end: -1,
                    headBlockID: 0,
                    headPieceID: 0,
                    tailBlockID: 0,
                    tailPieceID: 0
                },
                this.task.needDownloadExpiredTs()) {
                    var e = de.getInstance().getIndexAdapter(this.keyID);
                    this.loadInfo.index = ut.getInstance().getLiveExpiredTs(this.keyID, e.snToIndex(this.task.getReadSn()))
                }
                !this.loadInfo.index && this.task.needHTTPDownload() && this.setLoadIndex(),
                this.loadInfo.index && (this.loadInfo.url = ut.getInstance().getUrl(this.keyID, this.loadInfo.index),
                Lr.isUseRange && this.task.canUseRange && this.setLoadRange())
            }
            ,
            t.prototype.getPartNum = function() {
                var e = ur.getInstance().getUin();
                return 0 !== e ? e % Lr.liveDownloadPartNum : -1
            }
            ,
            t.prototype.canDownloadPart = function() {
                return Lr.isUseRange && this.task.canUseRange && this.task.startPlaying && this.task.isInMixTime() && Lr.liveDownloadStrategy === K.Part_TS_Download && -1 !== this.getPartNum()
            }
            ,
            t.prototype.setLoadIndex = function() {
                var e = de.getInstance().getIndexAdapter(this.keyID)
                  , t = this.canDownloadPart() ? this.getPartNum() : void 0;
                this.loadInfo.index = ut.getInstance().getUnloadIndex(this.keyID, e.snToIndex(this.task.getReadSn()), U.HTTP, t)
            }
            ,
            t.prototype.setLoadRange = function() {
                var e = void 0;
                if (this.canDownloadPart())
                    e = this.getPartNum();
                else if (!this.task.isInImmediateTime() && Lr.liveDownloadStrategy === K.Part_TS_Download)
                    for (var t = 0; t < Lr.liveDownloadPartNum; t++)
                        if (!ut.getInstance().isTsFinished(this.keyID, this.loadInfo.index, t)) {
                            e = t;
                            break
                        }
                this.loadInfo = Object.assign(this.loadInfo, ut.getInstance().getFirstRange(this.keyID, this.loadInfo.index, e))
            }
            ,
            t
        }(be)
          , De = function() {
            function e(e) {
                this.peerDownPool = null,
                this.connectPeerInterval = 1,
                this.querySeedInterval = 1,
                this.exchangeBitmapInterval = 1,
                this.downloadPieces = [],
                this.stoped = !0,
                this.keyID = e.keyID,
                this.task = e
            }
            return e.prototype.destroy = function() {
                this.stoped || this.stop(),
                this.peerContainer = void 0,
                this.peerDownPool = void 0
            }
            ,
            e.prototype.start = function() {
                Lr.useP2P && this.stoped && (this.downloadScheduleInterval = Lr.downloadScheduleInterval,
                this.routineTimer || (Ar.info(this.getLogScope(), this.getLogStatus(), "Start P2P RoutineWork."),
                this.routineTimer = self.setInterval(this.routineWork.bind(this), this.downloadScheduleInterval)),
                this.peerContainer || (this.initPeerContainer(),
                Ar.info(this.getLogScope(), this.getLogStatus(), "Init Peer Container.")),
                this.stoped = !1,
                this.getTorrent())
            }
            ,
            e.prototype.downloadSchedule = function() {
                if (this.task.isDownloadFinishAfterReadIndex())
                    this.stop();
                else if (this.stoped && this.start(),
                Lr.useP2P && this.peerContainer && this.task.needP2PDownload() && this.peerDownPool.getConnectedPeerLen() > 0) {
                    var e = de.getInstance().getIndexAdapter(this.keyID)
                      , t = this.task.getReadSn();
                    this.downloadPieces = ut.getInstance().constructDownloadPieceInfoForP2P(this.keyID, e.snToIndex(t), this.getMaxChooseTsNum()),
                    this.peerDownPool.chooseBlockWithPeers(this.downloadPieces)
                }
            }
            ,
            e.prototype.stop = function() {
                var e;
                this.stoped || (this.routineTimer && (Ar.info(this.getLogScope(), this.getLogStatus(), "Stop P2P RoutineWork."),
                clearInterval(this.routineTimer),
                this.routineTimer = void 0),
                null === (e = this.peerDownPool) || void 0 === e || e.releaseDownload(),
                this.stoped = !0)
            }
            ,
            e.prototype.querySeed = function() {
                if (ut.getInstance().hasTorrent(this.keyID)) {
                    var e = de.getInstance().getIndexAdapter(this.keyID)
                      , t = ut.getInstance().getUnloadIndex(this.keyID, e.snToIndex(this.task.getReadSn()), U.P2P);
                    if (t && this.peerDownPool && this.peerDownPool.getPeerPoolLen() <= Lr.maxPeerNum) {
                        var r = this.getFileID(t)
                          , i = {
                            onQueryCompleteCall: this.onQrySeedRsp.bind(this)
                        };
                        r && this.serverInterface.querySeed(r, Lr.maxQuerySeedNum, i, this.keyID),
                        Ar.info(this.getLogScope(), this.getLogStatus(), "QuerySeed fileID:" + r)
                    }
                }
            }
            ,
            e.prototype.getLogStatus = function() {
                return "Task:" + this.task.seq
            }
            ,
            e.prototype.routineWork = function() {
                Lr.useP2P && this.peerContainer && !this.stoped && (this.getTorrent(),
                this.canP2PAction() && (this.querySeedInterval -= 1,
                0 === this.querySeedInterval && (this.querySeed(),
                this.querySeedInterval = Lr.querySeedInterval),
                this.connectPeerInterval -= 1,
                0 === this.connectPeerInterval && (Oe.getInstance().canConnectDownload(this.task.dropFrameReduceLevel) && this.peerDownPool.connectPeer(),
                this.setConnectPeerInterval()),
                this.exchangeBitmapInterval -= 1,
                0 === this.exchangeBitmapInterval && (this.swapBitmap(),
                this.exchangeBitmapInterval = this.getExchangeBitmapInterval())),
                this.peerDownPool && this.peerDownPool.checkP2PTimeoutRequest()),
                this.downloadScheduleInterval !== Lr.downloadScheduleInterval && (this.downloadScheduleInterval = Lr.downloadScheduleInterval,
                clearInterval(this.routineTimer),
                this.routineTimer = self.setInterval(this.routineWork.bind(this), this.downloadScheduleInterval))
            }
            ,
            e.prototype.initPeerContainer = function() {
                var e = {
                    onPeerDataPingPang: this.onPeerDataPingPang.bind(this),
                    onPeerConnectSuccess: this.onPeerConnectSuccess.bind(this),
                    onPeerWebRTCError: this.onPeerWebRTCError.bind(this)
                };
                this.peerContainer = $t.getInstance().createPeerContainer(this.keyID, e),
                this.peerContainer && (this.peerDownPool = this.peerContainer.getPeerDownPool())
            }
            ,
            e.prototype.onPeerDataPingPang = function(e, t, r) {
                !this.stoped && this.task.needP2PDownload() && (Ar.debug(this.getLogScope(), this.getLogStatus(), "PingPang with peerID " + e + " to download p2pIndex " + t + " blockNo " + r + "."),
                this.peerDownPool.choosePingPangBlockWithPeer(e, this.downloadPieces, t, r),
                this.peerDownPool.chooseBlockByPeerID(e, this.downloadPieces))
            }
            ,
            e.prototype.onPeerConnectSuccess = function(e) {
                if (ut.getInstance().hasMediaFile(this.keyID) && Lr.exchangeBitmapImmediate) {
                    var t = de.getInstance().getIndexAdapter(this.keyID)
                      , r = ut.getInstance().getUnloadIndex(this.keyID, t.snToIndex(this.task.getReadSn()), U.P2P);
                    if (!r)
                        return;
                    var i = r.p2p;
                    null != i && this.peerDownPool && this.peerDownPool.exchangeBitmapForPeer(e, i, Lr.maxBitmapNumber)
                }
            }
            ,
            e.prototype.onPeerWebRTCError = function() {
                Tr.stopP2P(),
                this.destroy()
            }
            ,
            e.prototype.onQrySeedRsp = function(e, t, r, i, n) {
                this.stoped || 0 !== e || (i < Lr.reducePeerCount && (this.querySeedInterval += Lr.addQuerySeedInterval),
                Ar.info(this.getLogScope(), this.getLogStatus(), "onQrySeedRsp retCode:" + e + " fileID:" + t + " peerIDArray:" + r.toString() + " peerSum:" + i + ", totalPeerSum:" + n),
                this.peerDownPool && this.peerDownPool.insertPeersIntoPeerPool(r))
            }
            ,
            e.prototype.swapBitmap = function() {
                if (ut.getInstance().hasMediaFile(this.keyID)) {
                    var e = de.getInstance().getIndexAdapter(this.keyID)
                      , t = ut.getInstance().getUnloadIndex(this.keyID, e.snToIndex(this.task.getReadSn()), U.P2P);
                    if (!t)
                        return;
                    var r = t.p2p;
                    null != r && this.peerDownPool && this.peerDownPool.exchangeBitmap(r, Lr.maxBitmapNumber)
                }
            }
            ,
            e
        }()
          , ke = function(e) {
            function t(t) {
                var r = e.call(this, t) || this;
                return r.serverInterface = ur.getInstance(),
                r
            }
            return E(t, e),
            t.prototype.canP2PAction = function() {
                return this.task.playableTime >= Lr.liveP2PStartTime
            }
            ,
            t.prototype.getLogScope = function() {
                return "LiveP2PSchedule"
            }
            ,
            t.prototype.getTorrent = function() {}
            ,
            t.prototype.getFileID = function(e) {
                return this.keyID + ".h5"
            }
            ,
            t.prototype.getExchangeBitmapInterval = function() {
                return Lr.liveExchangeBitmapInterval
            }
            ,
            t.prototype.getMaxChooseTsNum = function() {
                return Lr.liveMaxChooseTsNum
            }
            ,
            t.prototype.setConnectPeerInterval = function() {
                Lr.reduceIntervalByConnectedNum ? this.peerDownPool.getConnectedPeerLen() < 4 ? this.connectPeerInterval = Lr.liveConnectPeerInterval : this.peerDownPool.getConnectedPeerLen() < 8 ? this.connectPeerInterval = 4 * Lr.liveConnectPeerInterval : this.connectPeerInterval = 6 * Lr.liveConnectPeerInterval : this.connectPeerInterval = Lr.liveConnectPeerInterval,
                this.connectPeerInterval = Math.floor(this.connectPeerInterval * this.task.dropFrameReduceLevel)
            }
            ,
            t
        }(De)
          , Ce = function() {
            this.aborted = !1,
            this.loaded = 0,
            this.retry = 0,
            this.total = 0,
            this.chunkCount = 0,
            this.bwEstimate = 0,
            this.loading = {
                start: 0,
                first: 0,
                end: 0
            },
            this.parsing = {
                start: 0,
                end: 0
            },
            this.buffering = {
                start: 0,
                first: 0,
                end: 0
            }
        }
          , Le = function() {
            function e() {
                this.hours = -1
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.prototype.getBufferTime = function(e) {
                if (e.downloadMode & q.No_Buffer_Limit)
                    return {
                        emergencyTime: Number.MAX_SAFE_INTEGER,
                        safePlayTime: Number.MAX_SAFE_INTEGER,
                        canUploadTime: Number.MAX_SAFE_INTEGER,
                        immediateTime: Number.MAX_SAFE_INTEGER
                    };
                var t = {};
                return t = e.taskType === B.Live ? this.getLiveStrategy(e) : this.getVodStrategy(e),
                e.playState !== M.Playing && (t.emergencyTime /= 2,
                t.safePlayTime /= 2,
                t.canUploadTime /= 2,
                t.immediateTime /= 2),
                t
            }
            ,
            e.prototype.getVodStrategy = function(e) {
                switch (Lr.vodDownloadStrategy) {
                case z.Peak_Time_Adjust:
                    return this.getVodPeakTimeAdjustStrategy();
                case z.Watch_Time_Adjust:
                    return this.getVodWatchTimeAdjust(e);
                default:
                    return this.getVodDefaultStrategy(e)
                }
            }
            ,
            e.prototype.getVodDefaultStrategy = function(e) {
                var t = {};
                return t.canUploadTime = Lr.vodCanUploadTime,
                t.immediateTime = Lr.vodImmediateDownloadTime,
                e.useP2P && e.hasP2P ? (t.emergencyTime = Lr.vodDefaultEmergencyTime,
                t.safePlayTime = Lr.vodDefaultSafeTime) : (t.emergencyTime = Lr.vodNotP2PEmergencyTime,
                t.safePlayTime = Lr.vodNotP2PSafeTime),
                t
            }
            ,
            e.prototype.getVodPeakTimeAdjustStrategy = function() {
                var e, t, r = {};
                r.canUploadTime = Lr.vodCanUploadTime,
                r.immediateTime = Lr.vodImmediateDownloadTime;
                var i = new Date;
                if (this.vodAdjustHttpBufferTime !== Lr.vodAdjustHttpBufferTime || this.hours !== i.getHours()) {
                    this.hours = i.getHours(),
                    this.vodAdjustHttpBufferTime = Lr.vodAdjustHttpBufferTime;
                    var n = this.vodAdjustHttpBufferTime.split(",");
                    try {
                        for (var a = C(n), o = a.next(); !o.done; o = a.next()) {
                            var s = o.value.split(" ");
                            if (3 === s.length) {
                                var l = s[0].split("-");
                                if (2 === l.length) {
                                    var c = parseInt(l[0], 10)
                                      , h = parseInt(l[1], 10);
                                    if (c >= 0 && h <= 24 && c < h && this.hours >= c && this.hours < h) {
                                        this.vodPeakTimeAdjustStrategyEmergencyTime = parseInt(s[1], 10),
                                        this.vodPeakTimeAdjustStrategyEmergencyTime = parseInt(s[2], 10);
                                        break
                                    }
                                }
                            }
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            o && !o.done && (t = a.return) && t.call(a)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
                    this.vodPeakTimeAdjustStrategyEmergencyTime > 0 && this.vodPeakTimeAdjustStrategyEmergencyTime > 0 || (this.vodPeakTimeAdjustStrategyEmergencyTime = Lr.vodDefaultEmergencyTime,
                    this.vodPeakTimeAdjustStrategyEmergencyTime = Lr.vodDefaultSafeTime)
                }
                return r.emergencyTime = this.vodPeakTimeAdjustStrategyEmergencyTime,
                r.safePlayTime = this.vodPeakTimeAdjustStrategySafeTime,
                r
            }
            ,
            e.prototype.getVodWatchTimeAdjust = function(e) {
                var t = {};
                return t.canUploadTime = Lr.vodCanUploadTime,
                t.immediateTime = Lr.vodImmediateDownloadTime,
                e.watchTime <= 10 ? (t.emergencyTime = Lr.vodWatchTime10EmergencyTime,
                t.safePlayTime = Lr.vodWatchTime10SafeTime) : e.watchTime <= 30 ? (t.emergencyTime = Lr.vodWatchTime30EmergencyTime,
                t.safePlayTime = Lr.vodWatchTime30SafeTime) : e.watchTime <= 60 ? (t.emergencyTime = Lr.vodWatchTime60EmergencyTime,
                t.safePlayTime = Lr.vodWatchTime60SafeTime) : e.useP2P && e.hasP2P ? (t.emergencyTime = Lr.vodDefaultEmergencyTime,
                t.safePlayTime = Lr.vodDefaultSafeTime) : (t.emergencyTime = Lr.vodNotP2PEmergencyTime,
                t.safePlayTime = Lr.vodNotP2PSafeTime),
                t
            }
            ,
            e.prototype.getLiveStrategy = function(e) {
                return Lr.liveDownloadStrategy,
                this.getLiveDefaultStrategy(e)
            }
            ,
            e.prototype.getLiveDefaultStrategy = function(e) {
                var t = {};
                return t.canUploadTime = Lr.liveCanUploadTime,
                t.immediateTime = Lr.liveImmediateDownloadTime,
                e.useP2P && e.hasP2P ? (t.emergencyTime = Lr.liveDefaultEmergencyTime,
                t.safePlayTime = Lr.liveDefaultSafeTime) : (t.emergencyTime = Lr.liveNotP2PEmergencyTime,
                t.safePlayTime = Lr.liveNotP2PSafeTime),
                t
            }
            ,
            e
        }()
          , we = function() {
            function e(e, t, r) {
                this.readSn = -1,
                this.isStopSendData = !0,
                this.playableTime = 0,
                this.playerRemainTime = 0,
                this.needFileSizeFromResponse = !1,
                this.canGetFileSizeFromServer = !0,
                this.startPlaying = !1,
                this.dropFrameReduceLevel = 1,
                this.canUseRange = !0,
                this.preloadRemainTime = Number.MAX_SAFE_INTEGER,
                this.commitOffset = 0,
                this.finishSendReadSn = !1,
                this.firstSn = -1,
                this.printInfoLogTick = 0,
                this.watchTime = 0,
                this.lastFramesInfo = {
                    droppedFrames: 0,
                    totalFrames: 0
                },
                this.lastFramesWatchTime = -1,
                this.isReadingData = !1,
                this.loadTime = -1,
                this.hasReportCanPlay = !1,
                this.stats = le.getItem(e.keyID),
                this.stats.createTime = Tr.getTick(),
                this.seq = r,
                this.taskInfo = e,
                this.playState = t,
                this.keyID = e.keyID
            }
            return e.prototype.init = function(e) {
                le.getItem(this.keyID).taskState = this.playState,
                le.getItem(this.keyID).setTaskInfo(this.taskInfo),
                this.initInfo(),
                this.updateBufferTime(),
                this.createSchedule(),
                this.setPlaylist(e),
                this.startDownload()
            }
            ,
            e.prototype.destroy = function() {
                var e;
                this.playState !== M.Stoped && (this.stopDownload(),
                this.playState = M.Stoped),
                this.keyID = void 0,
                this.httpSchedule.destroy(),
                null === (e = this.p2pSchedule) || void 0 === e || e.destroy()
            }
            ,
            e.prototype.setPlaylist = function(e) {
                -1 === this.readSn && (this.firstSn = e[0].sn),
                this.processFragments(e),
                de.getInstance().setIndexAdapter(this.keyID, e, this.taskInfo.taskType);
                var t = {
                    taskType: this.taskInfo.taskType,
                    useP2P: this.taskInfo.useP2P,
                    isPlayTask: !0
                };
                ut.getInstance().setMediaFile(this.keyID, e, t)
            }
            ,
            e.prototype.updatePlaylist = function(e) {
                this.processFragments(e),
                de.getInstance().updateIndexAdapter(this.keyID, e),
                ut.getInstance().updateMediaFile(this.keyID, e)
            }
            ,
            e.prototype.setTaskInfo = function(e) {
                this.taskInfo = e
            }
            ,
            e.prototype.setPlayState = function(e) {
                this.playState !== e && (this.playState === M.Preload && le.getItem(this.keyID).report(W.TaskStop),
                Ar.info(this.getLogScope(), this.getLogStatus(), "SetPlayState to " + M[e] + "."),
                this.playState = e,
                this.playState === M.Preload && (this.preloadRemainTime = Number.MAX_SAFE_INTEGER),
                le.getItem(this.keyID).taskState = this.playState)
            }
            ,
            e.prototype.isInUploadTime = function() {
                return this.playState === M.Stoped || !!(this.playableTime >= this.bufferStrategy.canUploadTime || this.isDownloadFinishAfterReadIndex())
            }
            ,
            e.prototype.isInEmergencyTime = function() {
                return this.playState !== M.Stoped && (this.playableTime < this.bufferStrategy.emergencyTime && !this.isDownloadFinishAfterReadIndex())
            }
            ,
            e.prototype.isInMixTime = function() {
                return this.playState !== M.Stoped && (this.playableTime < this.bufferStrategy.safePlayTime && this.bufferStrategy.emergencyTime < this.playableTime && !this.isDownloadFinishAfterReadIndex())
            }
            ,
            e.prototype.load = function(e, t) {
                var r = this;
                this.loaderCallbacks = t,
                this.isStopSendData = !1,
                this.loadTime = Tr.getTick(),
                -1 === this.stats.firstLoadTime && (this.stats.firstLoadTime = this.loadTime),
                this.httpSchedule.checkAbortLoader(e);
                var i = this.readSn;
                this.readSn = e,
                this.finishSendReadSn = !1,
                this.readTSBlockIndex = 0,
                this.commitOffset = 0,
                Ar.info(this.getLogScope(), this.getLogStatus(), "Player load sn: " + this.readSn + "."),
                this.readSn < i && setTimeout((function() {
                    ut.getInstance().onCacheManage(),
                    ut.getInstance().releaseCacheFromEnd(r.keyID)
                }
                ), 0),
                this.updatePlayableTime(),
                this.httpSchedule.downloadSchedule()
            }
            ,
            e.prototype.abort = function() {
                var e;
                this.isStopSendData = !0,
                null === (e = this.loaderCallbacks) || void 0 === e || e.onAbort()
            }
            ,
            e.prototype.isInImmediateTime = function() {
                return this.updatePlayableTime(),
                this.playableTime < Math.min(this.bufferStrategy.immediateTime, this.bufferStrategy.emergencyTime)
            }
            ,
            e.prototype.needP2PDownload = function() {
                if ("visible" !== document.visibilityState && this.taskInfo.taskType === B.Vod && Lr.vodDisableP2PInBackground)
                    return !1;
                if (ut.getInstance().isP2POverMemory())
                    return !1;
                if (this.playState === M.Preload && this.playableTime >= Lr.preloadP2PDownloadTime)
                    return !1;
                switch (this.playState) {
                case M.Stoped:
                    return !1;
                case M.Preload:
                    return !0;
                default:
                    if (this.playableTime > this.bufferStrategy.emergencyTime)
                        return !0
                }
                return !1
            }
            ,
            e.prototype.callbackError = function(e, t) {
                var r, i;
                e === ne.HTTPConnectTimeOut || e === ne.HTTPRevDataTimeout || e === ne.HTTPLowSpeed ? (null === (r = this.loaderCallbacks) || void 0 === r || r.onTimeout({
                    code: e
                }),
                Ar.warn(this.getLogScope(), this.getLogStatus(), "Callback timeout: " + e + ".")) : (null === (i = this.loaderCallbacks) || void 0 === i || i.onError({
                    code: e
                }, {
                    headers: t
                }),
                Ar.warn(this.getLogScope(), this.getLogStatus(), "Callback error: " + e + "."))
            }
            ,
            e.prototype.getStartSn = function() {
                return Number.isNaN(this.taskInfo.startSn) ? this.firstSn : this.taskInfo.startSn
            }
            ,
            e.prototype.getReadSn = function() {
                return -1 === this.readSn ? this.getStartSn() : this.readSn
            }
            ,
            e.prototype.recoverDownload = function(e, t, r) {
                this.setRemainTime(0),
                this.setTaskInfo(e),
                this.playState === M.Preload && t !== M.Preload || this.updatePlaylist(r),
                this.startDownload(),
                this.setPlayState(t)
            }
            ,
            e.prototype.setRemainTime = function(e, t) {
                return this.playerRemainTime = e,
                -1
            }
            ,
            e.prototype.setDropFrameInfo = function(e) {
                this.totalFramesInfo = e
            }
            ,
            e.prototype.setPreloadRemainTime = function(e) {
                e >= 0 && (this.preloadRemainTime = e)
            }
            ,
            e.prototype.isDownloadFinishAfterReadIndex = function() {
                var e, t = null === (e = de.getInstance().getIndexAdapter(this.keyID)) || void 0 === e ? void 0 : e.snToIndex(this.getReadSn());
                return ut.getInstance().isDownloadFinishAfterIndex(this.keyID, t)
            }
            ,
            e.prototype.getInfo = function() {
                var e = this.downloadInfo
                  , t = e.httpDownload
                  , r = e.p2pDownload
                  , i = e.p2pUpload
                  , n = e.p2pScore
                  , a = e.httpSpeed
                  , o = e.p2pDownloadSpeed
                  , s = e.p2pUploadSpeed
                  , l = this.peerInfo
                  , c = l.downIdle
                  , h = l.downConnecting
                  , u = l.downConnected
                  , d = l.up
                  , f = l.upAndDown;
                return {
                    playableTime: this.playableTime.toFixed(2),
                    httpDownload: t,
                    p2pDownload: r,
                    p2pUpload: i,
                    p2pScore: n,
                    httpSpeed: a,
                    p2pDownloadSpeed: o,
                    p2pUploadSpeed: s,
                    downIdle: c,
                    downConnecting: h,
                    downConnected: u,
                    up: d,
                    upAndDown: f
                }
            }
            ,
            e.prototype.getRecentHTTPHeaders = function() {
                return this.httpSchedule.getHTTPHeaders()
            }
            ,
            e.prototype.notifyCanPlay = function() {
                this.stats.canPlayTime = Tr.getTick(),
                Lr.reportLoadingTime && !this.hasReportCanPlay && (this.hasReportCanPlay = !0,
                this.stats.report(W.InitProxy))
            }
            ,
            e.prototype.hasP2PDownload = function() {
                return le.getItem(this.keyID).getP2PFlag() === V.SUCCEED
            }
            ,
            e.prototype.getPlayableBufferTime = function() {
                var e, t = null === (e = de.getInstance().getIndexAdapter(this.keyID)) || void 0 === e ? void 0 : e.snToIndex(this.getReadSn());
                return this.playerRemainTime + ut.getInstance().getPlayableTime(this.keyID, t, this.finishSendReadSn)
            }
            ,
            e.prototype.getLogStatus = function() {
                return "Task:" + this.seq
            }
            ,
            e.prototype.startDownload = function() {
                var e;
                Ar.info(this.getLogScope(), this.getLogStatus(), "Start download schedule."),
                this.watchTime = 0,
                le.getItem(this.keyID).start(),
                null === (e = this.p2pSchedule) || void 0 === e || e.start(),
                this.httpSchedule.downloadSchedule(),
                this.downloadScheduleInterval = Lr.downloadScheduleInterval,
                this.sendDataScheduleInterval = Lr.sendDataScheduleInterval,
                this.downloadTimer || (this.downloadTimer = self.setInterval(this.onSchedule.bind(this), this.downloadScheduleInterval)),
                this.sendDataTimer || (this.sendDataTimer = self.setInterval(this.onSendDataToPlayer.bind(this), this.sendDataScheduleInterval)),
                -1 === this.stats.startTime && (this.stats.startTime = Tr.getTick())
            }
            ,
            e.prototype.stopDownload = function() {
                var e, t;
                Ar.info(this.getLogScope(), this.getLogStatus(), "Stop download schedule."),
                (null === (e = this.httpSchedule) || void 0 === e ? void 0 : e.loader) && !this.httpSchedule.loader.isStop() && this.httpSchedule.loader.abort(),
                this.downloadTimer && (clearInterval(this.downloadTimer),
                this.downloadTimer = void 0),
                this.sendDataTimer && (clearInterval(this.sendDataTimer),
                this.sendDataTimer = void 0),
                le.getItem(this.keyID).processMode = 2,
                null === (t = this.p2pSchedule) || void 0 === t || t.stop(),
                this.isStopSendData = !0,
                this.loaderCallbacks = void 0,
                this.watchTime = 0
            }
            ,
            e.prototype.onSchedule = function() {
                var e;
                this.updatePlayableTime(),
                this.updateInfo(),
                this.updateBufferTime(),
                this.watchDropFrames();
                var t = "WatchTime: " + this.watchTime + ", PlayState: " + this.playState + ", " + (this.playState === M.Preload ? "PreloadRemain: " + this.preloadRemainTime + ", " : "") + "PlayerRemain: " + this.playerRemainTime.toFixed(2) + ", Playable: " + this.playableTime.toFixed(2) + ", Emergency: " + this.bufferStrategy.emergencyTime + ", Safe: " + this.bufferStrategy.safePlayTime
                  , r = "Speed:[" + this.downloadInfo.httpSpeed + "KB/s," + this.downloadInfo.p2pDownloadSpeed + "KB/s," + this.downloadInfo.p2pUploadSpeed + "KB/s] download:[" + this.downloadInfo.httpDownload + "MB," + this.downloadInfo.p2pDownload + "MB] upload:" + this.downloadInfo.p2pUpload + "MB p2pScore:" + this.downloadInfo.p2pScore + " wrong:[" + this.downloadInfo.httpRepeat.toFixed(2) + "," + this.downloadInfo.p2pRepeat.toFixed(2) + "," + this.downloadInfo.loss.toFixed(2) + "," + this.downloadInfo.redundance.toFixed(2) + "]";
                this.printInfoLogTick % 10 == 0 ? (Ar.info(this.getLogScope(), this.getLogStatus(), t),
                Ar.info(this.getLogScope(), this.getLogStatus(), r)) : (Ar.debug(this.getLogScope(), this.getLogStatus(), t),
                Ar.debug(this.getLogScope(), this.getLogStatus(), r)),
                this.printInfoLogTick += 1,
                this.playState === M.Playing && (this.watchTime += 1),
                this.taskInfo.taskType === B.Vod && this.httpSchedule.checkLowSpeed(),
                this.httpSchedule.downloadSchedule(),
                null === (e = this.p2pSchedule) || void 0 === e || e.downloadSchedule(),
                this.downloadScheduleInterval !== Lr.downloadScheduleInterval && (this.downloadScheduleInterval = Lr.downloadScheduleInterval,
                clearInterval(this.downloadTimer),
                this.downloadTimer = self.setInterval(this.onSchedule.bind(this), this.downloadScheduleInterval))
            }
            ,
            e.prototype.onSendDataToPlayer = function() {
                this.playState !== M.Stoped && (this.sendDataToPlayer(),
                this.sendDataScheduleInterval !== Lr.sendDataScheduleInterval && (this.sendDataScheduleInterval = Lr.sendDataScheduleInterval,
                clearInterval(this.sendDataTimer),
                this.sendDataTimer = self.setInterval(this.onSendDataToPlayer.bind(this), this.sendDataScheduleInterval)))
            }
            ,
            e.prototype.sendDataToPlayer = function() {
                var e, t, r, i = this;
                if (!(!ut.getInstance().hasMediaFile(this.keyID) || !0 === this.isStopSendData || this.finishSendReadSn || !this.loaderCallbacks || this.playState === M.Preload && this.preloadRemainTime >= Lr.preloadStartHTTPTime || this.isReadingData)) {
                    this.isReadingData = !0;
                    var n = this.loadTime
                      , a = null === (e = de.getInstance().getIndexAdapter(this.keyID)) || void 0 === e ? void 0 : e.snToIndex(this.readSn);
                    this.loaderCallbacks.onProgress ? null === (t = ut.getInstance().readBlocksData(this.keyID, a, this.readTSBlockIndex, Lr.commitBlockCntPerTime)) || void 0 === t || t.then((function(e) {
                        if (e && i.loaderCallbacks && n === i.loadTime) {
                            var t = e.buff;
                            i.commitOffset += t.byteLength;
                            var r = new Ce;
                            r.loaded = i.commitOffset,
                            r.total = e.tsLen,
                            i.loaderCallbacks.onProgress(r, t),
                            i.readTSBlockIndex += e.readBlockNum,
                            Ar.debug(i.getLogScope(), i.getLogStatus(), "SendDataToPlayer onprogress, readSn: " + i.readSn + ", blockNum: " + e.readBlockNum + ", offset: " + i.commitOffset),
                            -1 === i.stats.firstSendDataTime && (i.stats.firstSendDataTime = Tr.getTick()),
                            e.readFinish && (i.commitOffset = 0,
                            i.loaderCallbacks.onSuccess(new Ce, new ArrayBuffer(0)),
                            i.finishSendReadSn = !0,
                            Ar.info(i.getLogScope(), i.getLogStatus(), "SendDataToPlayer success by onprogress: readSn " + i.readSn + " [" + e.downloadSource + "]"),
                            -1 === i.stats.firstFinishSendDataTime && (i.stats.firstFinishSendDataTime = Tr.getTick()),
                            i.startPlaying = !0)
                        }
                        i.isReadingData = !1
                    }
                    )) : ut.getInstance().isTsFinished(this.keyID, a) && (null === (r = ut.getInstance().readTsData(this.keyID, a)) || void 0 === r || r.then((function(e) {
                        e && i.loaderCallbacks && n === i.loadTime && (i.commitOffset = 0,
                        i.loaderCallbacks.onSuccess(new Ce, e.buff),
                        i.finishSendReadSn = !0,
                        Ar.info(i.getLogScope(), i.getLogStatus(), "SendDataToPlayer send success by onSuccess: readSn " + i.readSn + " [" + e.downloadSource + "]"),
                        -1 === i.stats.firstFinishSendDataTime && (i.stats.firstSendDataTime = Tr.getTick(),
                        i.stats.firstFinishSendDataTime = i.stats.firstSendDataTime),
                        i.isReadingData = !1,
                        i.startPlaying = !0)
                    }
                    )))
                }
            }
            ,
            e.prototype.updatePlayableTime = function() {
                le.getItem(this.keyID).playerRemainTime = this.playerRemainTime,
                this.playableTime = this.getPlayableBufferTime(),
                le.getItem(this.keyID).playableTime = this.playableTime
            }
            ,
            e.prototype.updateBufferTime = function() {
                var e = {
                    taskType: this.taskInfo.taskType,
                    playState: this.playState,
                    useP2P: Lr.useP2P && this.taskInfo.useP2P,
                    hasP2P: this.hasP2PDownload(),
                    downloadMode: this.taskInfo.downloadMode,
                    watchTime: this.watchTime
                };
                this.bufferStrategy = Le.getInstance().getBufferTime(e)
            }
            ,
            e.prototype.watchDropFrames = function() {
                if (Lr.useDropFrames) {
                    if (this.watchTime - this.lastFramesWatchTime >= Lr.dropFramesWatchInterval && this.totalFramesInfo) {
                        var e = (this.totalFramesInfo.droppedFrames - this.lastFramesInfo.droppedFrames) / (this.totalFramesInfo.totalFrames - this.lastFramesInfo.totalFrames) * 100;
                        e >= Lr.dropRateLevel3 ? this.dropFrameReduceLevel = Lr.dropFrameReduceLevel3 : e >= Lr.dropRateLevel2 ? this.dropFrameReduceLevel = Lr.dropFrameReduceLevel2 : e >= Lr.dropRateLevel1 ? this.dropFrameReduceLevel = Lr.dropFrameReduceLevel1 : this.dropFrameReduceLevel = 1,
                        Ar.info(this.getLogScope(), this.getLogStatus(), "dropFramesRate: " + e.toFixed(2) + "%, reduceLevel: " + this.dropFrameReduceLevel),
                        le.getItem(this.keyID).reduceLevel = this.dropFrameReduceLevel,
                        this.lastFramesWatchTime = this.watchTime,
                        this.lastFramesInfo = this.totalFramesInfo
                    }
                } else
                    this.dropFrameReduceLevel = 1
            }
            ,
            e.prototype.processFragments = function(e) {
                var t = this
                  , r = 0;
                e.forEach((function(e, i, n) {
                    var a, o;
                    (null === (a = e.ext) || void 0 === a ? void 0 : a.keyID) !== t.keyID ? (Ar.error(t.getLogScope(), t.getLogStatus(), "playlist frag keyID: " + (null === (o = e.ext) || void 0 === o ? void 0 : o.KeydID) + " != this.keyID"),
                    n.splice(i, 1)) : e.url ? (t.praseFragType(e),
                    t.praseFileSize(e),
                    r += e.duration,
                    e.fileSize > 0 || (Ar.warn(t.getLogScope(), t.getLogStatus(), "playlist have no filesize"),
                    t.needFileSizeFromResponse = !0)) : (Ar.error(t.getLogScope(), t.getLogStatus(), "playlist frag sn: " + e.sn + " has no url"),
                    n.splice(i, 1))
                }
                )),
                le.getItem(this.keyID).totalDuration = r
            }
            ,
            e.prototype.updateInfo = function() {
                this.downloadInfo = le.getItem(this.keyID).getDownloadInfo(),
                this.peerInfo = $t.getInstance().getPeerNumForReport(this.keyID)
            }
            ,
            e.prototype.initInfo = function() {
                this.downloadInfo = {
                    httpDownload: 0,
                    p2pDownload: 0,
                    p2pUpload: 0,
                    p2pScore: 0,
                    httpSpeed: 0,
                    p2pDownloadSpeed: 0,
                    p2pUploadSpeed: 0,
                    loss: 0,
                    redundance: 0
                },
                this.peerInfo = {
                    upAndDown: 0,
                    up: 0,
                    downIdle: 0,
                    downConnecting: 0,
                    downConnected: 0
                }
            }
            ,
            e
        }()
          , Re = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.prototype.needDownloadExpiredTs = function() {
                return Lr.liveDownloadExpiredTs && this.playableTime < Lr.liveDownloadExpiredTsTime
            }
            ,
            t.prototype.needHTTPDownload = function() {
                return this.isInEmergencyTime() || this.isInMixTime()
            }
            ,
            t.prototype.isDownloadFinishAfterReadIndex = function() {
                return !1
            }
            ,
            t.prototype.createSchedule = function() {
                this.httpSchedule = new Ee(this),
                this.taskInfo.useP2P && Lr.useP2P && Pe.checkP2PSupport() && (this.p2pSchedule = new ke(this))
            }
            ,
            t.prototype.getLogScope = function() {
                return "LiveTask"
            }
            ,
            t.prototype.praseFragType = function(e) {
                e.tsType = F.Normal
            }
            ,
            t.prototype.praseFileSize = function(e) {
                var t, r, i = new RegExp("SZ=(.*)&CK=(.*)");
                try {
                    for (var n = C(e.tagList), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        if ("EXT-SC" === o[0])
                            return void (e.fileSize = parseInt(i.exec(o[1])[1], 10))
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (r = n.return) && r.call(n)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
            }
            ,
            t
        }(we)
          , Ae = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.prototype.checkAbortLoader = function(e) {
                var t = de.getInstance().getIndexAdapter(this.keyID);
                this.task.readSn === e || ut.getInstance().isTsFinished(this.keyID, t.snToIndex(e)) || !this.loader || this.loader.isStop() || this.loader.getrequestIndex().sn === e || this.loader.abort()
            }
            ,
            t.prototype.getLogScope = function() {
                return "VodHTTPSchedule"
            }
            ,
            t.prototype.getLoadInfo = function() {
                var e = de.getInstance().getIndexAdapter(this.keyID);
                this.loadInfo = {
                    index: null,
                    url: null,
                    start: 0,
                    end: -1,
                    headBlockID: 0,
                    headPieceID: 0,
                    tailBlockID: 0,
                    tailPieceID: 0
                },
                this.task.needHTTPDownload() && (this.loadInfo.index = ut.getInstance().getUnloadIndex(this.keyID, e.snToIndex(this.task.getReadSn()), U.HTTP),
                this.loadInfo.index && (this.loadInfo.url = ut.getInstance().getUrl(this.keyID, this.loadInfo.index),
                Lr.isUseRange && this.task.canUseRange && (this.loadInfo = Object.assign(this.loadInfo, ut.getInstance().getFirstRange(this.keyID, this.loadInfo.index)))))
            }
            ,
            t
        }(be)
          , _e = function(e) {
            function t(t) {
                var r = e.call(this, t) || this;
                return r.haveRequestTPT = !1,
                r.serverInterface = hr.getInstance(),
                r
            }
            return E(t, e),
            t.prototype.destroy = function() {
                this.haveRequestTPT = !1,
                e.prototype.destroy.call(this)
            }
            ,
            t.prototype.canP2PAction = function() {
                return this.task.playState === M.Preload || this.task.playableTime >= Lr.vodP2PStartTime
            }
            ,
            t.prototype.getLogScope = function() {
                return "VodP2PSchedule"
            }
            ,
            t.prototype.getTorrent = function() {
                if (!ut.getInstance().hasTorrent(this.keyID) && !this.haveRequestTPT && this.keyID) {
                    var e = {
                        onTPTReturn: this.onTPTReturn.bind(this),
                        onTPTTimeout: this.onTPTTimeout.bind(this),
                        onTPTError: this.onTPTError.bind(this)
                    };
                    this.haveRequestTPT = !0,
                    this.serverInterface.queryTPT(this.keyID, e),
                    Ar.info(this.getLogScope(), this.getLogStatus(), "GetTorrent KeyID " + this.keyID)
                }
            }
            ,
            t.prototype.getFileID = function(e) {
                return ut.getInstance().getFileID(this.keyID, e)
            }
            ,
            t.prototype.getExchangeBitmapInterval = function() {
                return Lr.vodExchangeBitmapInterval
            }
            ,
            t.prototype.getMaxChooseTsNum = function() {
                return Lr.vodMaxChooseTsNum
            }
            ,
            t.prototype.setConnectPeerInterval = function() {
                Lr.reduceIntervalByConnectedNum ? this.peerDownPool.getConnectedPeerLen() < 4 ? this.connectPeerInterval = Lr.vodConnectPeerInterval : this.peerDownPool.getConnectedPeerLen() < 8 ? this.connectPeerInterval = 4 * Lr.vodConnectPeerInterval : this.connectPeerInterval = 6 * Lr.vodConnectPeerInterval : this.connectPeerInterval = Lr.vodConnectPeerInterval,
                this.connectPeerInterval = Math.floor(this.connectPeerInterval * this.task.dropFrameReduceLevel)
            }
            ,
            t.prototype.onTPTReturn = function(e, t, r) {
                ut.getInstance().setFileID(this.keyID, t, r),
                this.haveRequestTPT = !1,
                Ar.info(this.getLogScope(), this.getLogStatus(), "onTPTReturn retCode:" + e + " fileIDArray:" + t.toString() + " tsNumArray:" + r.toString()),
                this.querySeed()
            }
            ,
            t.prototype.onTPTTimeout = function() {}
            ,
            t.prototype.onTPTError = function(e) {
                e === X.TPT_NO_P2P && (Ar.info(this.getLogScope(), this.getLogStatus(), "onTPTReturn retCode:" + e + ", has no fileID."),
                Lr.vodGenerateFileID && BigInt ? (ut.getInstance().generateFileID(this.keyID),
                le.getItem(this.keyID).isGenFileID = !0,
                this.querySeed()) : (ut.getInstance().setAllowP2P(this.keyID, !1),
                this.stop()))
            }
            ,
            t
        }(De)
          , xe = function(e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.hasVideoIn = !1,
                t.hasAdInsert = !1,
                t.isHTTPPullTime = !1,
                t
            }
            return E(t, e),
            t.prototype.needHTTPDownload = function() {
                return !ut.getInstance().isHTTPOverMemory() && (!(this.playState === M.Preload && this.preloadRemainTime >= Lr.preloadStartHTTPTime) && (this.isInEmergencyTime() && !this.isHTTPPullTime ? (this.isHTTPPullTime = !0,
                !0) : !(!this.isHTTPPullTime || !this.isInMixTime() && !this.isInEmergencyTime()) || (this.isHTTPPullTime = !1,
                !1)))
            }
            ,
            t.prototype.setRemainTime = function(e, t) {
                return this.playerRemainTime = e,
                this.playPoint = t,
                this.getPlayableBufferTime()
            }
            ,
            t.prototype.createSchedule = function() {
                this.httpSchedule = new Ae(this),
                this.taskInfo.useP2P && Lr.useP2P && Pe.checkP2PSupport() && (this.p2pSchedule = new _e(this))
            }
            ,
            t.prototype.getLogScope = function() {
                return "VodTask"
            }
            ,
            t.prototype.praseFileSize = function(e) {
                if (e.relurl) {
                    var t = e.relurl.split("?");
                    if (t.length >= 2) {
                        var r = parseInt(Tr.getReurlValue(t[1], "brs"), 10)
                          , i = parseInt(Tr.getReurlValue(t[1], "bre"), 10);
                        e.fileSize = i <= r ? 0 : i - r + 1
                    }
                }
            }
            ,
            t.prototype.praseFragType = function(e) {
                var t, r = Tr.parseUrl(e.relurl);
                switch (parseInt(null === (t = null == r ? void 0 : r.params) || void 0 === t ? void 0 : t.segmenttype, 10)) {
                case 1:
                    e.tsType = F.VideoIn,
                    this.hasVideoIn = !0,
                    Ar.info(this.getLogScope(), "Task:" + this.seq, "hasVideoIn: " + this.hasVideoIn + " sn: " + e.sn + ".");
                    break;
                case 2:
                    e.tsType = F.AdInsert,
                    this.hasAdInsert = !0,
                    Ar.info(this.getLogScope(), "Task:" + this.seq, "hasAdInsert: " + this.hasAdInsert + " sn: " + e.sn + ".");
                    break;
                default:
                    e.tsType = F.Normal
                }
                le.getItem(this.keyID).isVideoIn = this.hasVideoIn,
                le.getItem(this.keyID).isAdInsert = this.hasAdInsert
            }
            ,
            t.prototype.getPlayableBufferTime = function() {
                return Lr.vodUsePlayPoint && this.playPoint ? ut.getInstance().getPlayableTimeByPlayPoint(this.keyID, this.playPoint) : e.prototype.getPlayableBufferTime.call(this)
            }
            ,
            t
        }(we)
          , Oe = function() {
            function e() {
                var e = this;
                this.taskList = new Map,
                this.taskSeq = -1,
                Tr.setUserAgentInfo(),
                ve({}),
                pe.getInstance().isGotConfig || pe.getInstance().reqConfig(),
                window.addEventListener("beforeunload", (function() {
                    return e.onUnloadReport
                }
                ))
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.prototype.destroy = function() {
                var e, t, r = this;
                if (Tr.stopP2P(),
                this.taskList)
                    try {
                        for (var i = C(this.taskList), n = i.next(); !n.done; n = i.next()) {
                            var a = n.value;
                            this.destroyTask(a[0])
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            n && !n.done && (t = i.return) && t.call(i)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
                window.removeEventListener("beforeunload", (function() {
                    return r.onUnloadReport
                }
                )),
                this.taskList = void 0,
                this.taskSeq = -1
            }
            ,
            e.prototype.createTask = function(e, t, r) {
                if ("string" != typeof (null == e ? void 0 : e.keyID) || "" === (null == e ? void 0 : e.keyID))
                    return null;
                var i;
                if (Lr.useP2P && e.useP2P && Pe.checkP2PSupport() && Tr.openP2P(e.taskType),
                this.taskList.has(e.keyID)) {
                    if ((i = this.taskList.get(e.keyID)).playState !== M.Preload)
                        return Ar.warn("TaskManager", "", "Task KeyID " + e.keyID + ", seq: " + i.seq + " has playing on another player!"),
                        null;
                    i.recoverDownload(e, t, r),
                    Ar.info("TaskManager", "", "Recover task keyID: " + e.keyID + ", seq: " + i.seq + ", state: " + t + ", startSn: " + e.startSn + ".")
                } else
                    this.taskSeq += 1,
                    i = e.taskType === B.Live ? new Re(e,t,this.taskSeq) : new xe(e,t,this.taskSeq),
                    Ar.info("TaskManager", "", "Create " + (e.taskType === B.Live ? "live" : "vod") + " task keyID: " + e.keyID + ", seq: " + i.seq + ", state: " + t + ", startSn: " + e.startSn + "."),
                    this.taskList.set(e.keyID, i),
                    i.init(r);
                return i
            }
            ,
            e.prototype.stopTask = function(e, t) {
                void 0 === t && (t = !1),
                this.destroyTask(e, t)
            }
            ,
            e.prototype.destroyTask = function(e, t) {
                if (void 0 === t && (t = !1),
                this.taskList.has(e)) {
                    var r = this.taskList.get(e)
                      , i = r.seq;
                    r.destroy(),
                    this.taskList.delete(e),
                    ut.getInstance().stopPlay(e, t),
                    Ar.info("TaskManager", "", "Destroy task keyID: " + e + ", seq: " + i + ", disableCache: " + t + ".")
                } else
                    Ar.warn("TaskManager", "", "Try to destroy a task not exist, keyID: " + e)
            }
            ,
            e.prototype.getTask = function(e) {
                return this.taskList.get(e)
            }
            ,
            e.prototype.getTaskType = function(e) {
                var t;
                return null === (t = this.taskList.get(e)) || void 0 === t ? void 0 : t.taskInfo.taskType
            }
            ,
            e.prototype.getTaskSeq = function(e) {
                return this.taskList.get(e).seq
            }
            ,
            e.prototype.canConnectUpload = function() {
                if (!Lr.useP2P)
                    return !1;
                var e = $t.getInstance()
                  , t = e.getConnectCountUpload()
                  , r = e.getAllConnectPeerCount();
                return t <= Lr.baseConnectPeerNumber || !(t > 2 * Lr.baseConnectPeerNumber) && t + r <= 3 * Lr.baseConnectPeerNumber
            }
            ,
            e.prototype.canConnectDownload = function(e) {
                var t = $t.getInstance()
                  , r = t.getConnectCountUpload()
                  , i = t.getAllConnectPeerCount();
                return i <= Lr.baseConnectPeerNumber / e || !(i > 2 * Lr.baseConnectPeerNumber / e) && r + i <= 3 * Lr.baseConnectPeerNumber / e
            }
            ,
            e.prototype.canUploadData = function() {
                if (!Lr.useP2P)
                    return !1;
                var e = !0;
                return this.taskList.forEach((function(t) {
                    t.isInUploadTime() || (e = !1)
                }
                )),
                e
            }
            ,
            e.prototype.onUnloadReport = function() {
                this.taskList.forEach((function(e) {
                    e.playState !== M.Stoped && le.getItem(e.keyID).report(W.TaskStop, !0)
                }
                ))
            }
            ,
            e
        }()
          , Fe = function() {
            function e(e, t) {
                this.fileSize = 0,
                this.getFromHTTP = !1,
                this.getFromP2P = !1,
                this.getFromDB = !1,
                this.isDownloadToDB = !1,
                this.sn = t.sn,
                this.mediaFile = e,
                this.duration = Math.max(t.duration, 0),
                this.url = t.url,
                this.cacheSize = 0,
                this.haveAssignBlock = !1,
                this.blocks = [],
                this.allocBuffer = !1,
                this.allowP2P = t.tsType === F.Normal,
                this.fileSize = t.fileSize || 0,
                this.blockSum = Math.floor(this.fileSize / J.BLOCK_SIZE),
                this.fileSize % J.BLOCK_SIZE > 0 && (this.blockSum += 1),
                this.lastBlockSize = this.fileSize % J.BLOCK_SIZE == 0 ? J.BLOCK_SIZE : this.fileSize % J.BLOCK_SIZE,
                this.type = t.tsType,
                this.isInDB = !!t.isInDB && t.isInDB,
                this.lastAccessTime = 0,
                this.checkFailTimes = 0,
                this.fileSize || this.mediaFile.getTaskType() !== B.Live || this.getFileSizeFromServer(),
                Ar.debug(this.getLogScope(), this.getLogStatus(), "Create cache duration: " + t.duration + ", fileSize: " + t.fileSize + ", blockSum: " + this.blockSum)
            }
            return e.prototype.setFragInfo = function(e) {
                e.fileSize !== this.fileSize && Ar.warn(this.getLogScope(), this.getLogStatus(), "Update cache sn: " + e.sn + ", fileSize: " + e.fileSize),
                this.allowP2P = e.tsType === F.Normal,
                this.fileSize = e.fileSize || this.fileSize,
                this.duration = Math.max(e.duration, 0) || this.duration || 0,
                this.blockSum = Math.floor(this.fileSize / J.BLOCK_SIZE),
                this.fileSize % J.BLOCK_SIZE > 0 && (this.blockSum += 1),
                this.lastBlockSize = this.fileSize % J.BLOCK_SIZE == 0 ? J.BLOCK_SIZE : this.fileSize % J.BLOCK_SIZE,
                this.type = e.tsType,
                this.url = e.url || this.url,
                this.sn = e.sn,
                this.allowP2P || (this.lastAccessTime = 0,
                this.checkFailTimes = 0,
                this.isInDB = !1,
                this.releaseData(!1))
            }
            ,
            e.prototype.getUrl = function() {
                return this.url
            }
            ,
            e.prototype.setFilesize = function(e) {
                0 === this.fileSize ? this.fileSize = e : 0 !== e && this.fileSize !== e && (Ar.warn(this.getLogScope(), this.getLogStatus(), "setFileSize: this.filesize:" + this.fileSize + " != that.filesize:" + e + ", unallow P2P."),
                this.releaseData(!1),
                this.fileSize = e)
            }
            ,
            e.prototype.checkFileSize = function(e) {
                0 === this.fileSize ? this.fileSize = e : 0 !== e && this.fileSize !== e && (Ar.warn(this.getLogScope(), this.getLogStatus(), "CheckFileSize: this.filesize:" + this.fileSize + " != that.filesize:" + e + ", unallow P2P."),
                this.allowP2P = !1)
            }
            ,
            e.prototype.getDuration = function() {
                return this.duration
            }
            ,
            e.prototype.getTsBitmap = function() {
                return this.isInDB ? new Uint8Array(Math.floor((this.blockSum + 7) / 8)).fill(255).buffer : this.bitmap
            }
            ,
            e.prototype.getMetaData = function() {
                return [this.sn, this.fileSize, this.type]
            }
            ,
            e.prototype.releaseData = function(e) {
                Ar.info(this.getLogScope(), this.getLogStatus(), "Release data cacheSize:" + this.cacheSize + " bytes, blockSum:" + this.blockSum + "."),
                e && this.isFullInCache(),
                this.cacheSize = 0,
                this.blocks = [],
                this.bitmap = null,
                this.buffer = void 0,
                this.allocBuffer = !1,
                this.haveAssignBlock = !1,
                this.assignBlock()
            }
            ,
            e.prototype.hasAllocBuffer = function() {
                return !0 === this.allocBuffer
            }
            ,
            e.prototype.releaseCache = function() {
                Ar.info(this.getLogScope(), this.getLogStatus(), "Release cache cacheSize:" + this.cacheSize + " bytes, blockSum:" + this.blockSum + "."),
                !0 === this.haveAssignBlock && (this.cacheSize = 0,
                this.blocks = [],
                this.bitmap = null,
                this.allocBuffer = !1,
                this.haveAssignBlock = !1),
                this.buffer = void 0
            }
            ,
            e.prototype.readTsData = function() {
                return D(this, void 0, void 0, (function() {
                    return k(this, (function(e) {
                        switch (e.label) {
                        case 0:
                            return [4, this.checkDB()];
                        case 1:
                            return e.sent() && !this.isDownloadToDB && (le.getItem(this.mediaFile.keyID).readFromFile += this.fileSize),
                            this.isFullInCache() ? [2, {
                                buff: this.readBytes(0, this.fileSize),
                                readBlockNum: this.blockSum,
                                readOffset: this.fileSize,
                                tsLen: this.fileSize,
                                readFinish: !0,
                                downloadSource: this.getDownloadSource()
                            }] : [2, null]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.readBlocksData = function(e, t) {
                return D(this, void 0, void 0, (function() {
                    var r, i, n, a, o, s, l;
                    return k(this, (function(c) {
                        switch (c.label) {
                        case 0:
                            return [4, this.checkDB()];
                        case 1:
                            if (c.sent() && !this.isDownloadToDB && (le.getItem(this.mediaFile.keyID).readFromFile += this.fileSize),
                            !this.haveAssignBlock || !this.allocBuffer)
                                return [2, null];
                            if (e >= this.blocks.length)
                                return [2, null];
                            for (r = 0,
                            i = e * J.BLOCK_SIZE,
                            n = 0,
                            a = !1,
                            o = e; o < e + t && (o < this.blocks.length && this.isBlockFullInCache(o)); o++)
                                r += 1,
                                s = this.blocks[o],
                                n += s.blockSize,
                                o === this.blocks.length - 1 && (a = !0);
                            return 0 === n || null === (l = this.readBytes(i, n)) ? [2, null] : [2, {
                                buff: l,
                                readBlockNum: r,
                                readOffset: i,
                                tsLen: this.fileSize,
                                readFinish: a,
                                downloadSource: this.getDownloadSource()
                            }]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.readPiecesData = function(e, t, r) {
                return D(this, void 0, void 0, (function() {
                    var i, n, a;
                    return k(this, (function(o) {
                        switch (o.label) {
                        case 0:
                            return this.lastAccessTime = +new Date,
                            [4, this.checkDB()];
                        case 1:
                            return o.sent(),
                            null !== (i = this.blockWithID(e)) && null !== i.bitmap && this.isSetUint8Bitmap(i.bitmap, t) ? (n = J.BLOCK_SIZE * e + J.PIECE_SIZE * t,
                            a = J.PIECE_SIZE * r,
                            n + a > this.fileSize && (a = this.fileSize - n),
                            [2, this.readBytes(n, a)]) : [2, null]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.writeStream = function(e, t, r) {
                switch (this.lastAccessTime = +new Date,
                r) {
                case U.HTTP:
                    this.getFromHTTP = !0;
                    break;
                case U.P2P:
                    this.getFromP2P = !0;
                    break;
                case U.IndexedDB:
                    this.getFromDB = !0
                }
                this.haveAssignBlock || this.assignBlock(),
                !this.allocBuffer && this.fileSize > 0 && (this.buffer = new ArrayBuffer(this.fileSize),
                this.allocBuffer = !0);
                for (var i = this.blockIndexWithPos(e), n = e % J.BLOCK_SIZE, a = 0, o = t.byteLength, s = Math.min(o, J.BLOCK_SIZE - n); o > 0; ) {
                    if (i >= this.blocks.length)
                        return;
                    var l = e + a;
                    !1 === this.isBitSet(this.bitmap, i) ? this.writeBytes(l, t, a, s) : (Ar.debug(this.getLogScope(), this.getLogStatus(), "Write data repeat position " + l + ", length " + t.byteLength + ", blockIndex " + i + " offset " + a + ", writeLen " + s + "."),
                    r === U.P2P ? le.getItem(this.mediaFile.keyID).p2pRepeatByte += s : r === U.HTTP && (le.getItem(this.mediaFile.keyID).httpRepeatByte += s)),
                    a += s,
                    o -= s;
                    var c = Math.floor(l / J.PIECE_SIZE)
                      , h = Math.floor((s + l % J.PIECE_SIZE) / J.PIECE_SIZE)
                      , u = this.blocks[i].blockID;
                    u * J.BLOCK_SIZE + l % J.BLOCK_SIZE + s >= this.fileSize - 1 ? ((l + s) % J.PIECE_SIZE != 0 && (h += 1),
                    this.writeBitmap(u, c, h, !0)) : this.writeBitmap(u, c, h, !1),
                    s = Math.min(J.BLOCK_SIZE, o),
                    i += 1
                }
            }
            ,
            e.prototype.isFinish = function(e) {
                return this.isInDB || this.isFullInCache(e)
            }
            ,
            e.prototype.isBlockFull = function(e) {
                return this.isInDB || this.isBlockFullInCache(e)
            }
            ,
            e.prototype.getUnfinishPieceInfoForP2P = function() {
                var e = [];
                if (!this.haveAssignBlock && !this.assignBlock())
                    return e;
                for (var t = 0; t < this.blockSum; t++)
                    if (!this.isBitSet(this.bitmap, t)) {
                        var r = this.getUnfinishedPieceInfoForP2P(t);
                        e.push(r)
                    }
                return e
            }
            ,
            e.prototype.setTsChoosed = function(e, t) {
                if (this.haveAssignBlock || this.assignBlock())
                    for (var r = J.BLOCK_SIZE / J.PIECE_SIZE, i = 0; i < this.blockSum; i++)
                        this.setPieceChoosed(i, 0, r, e, t)
            }
            ,
            e.prototype.setPieceChoosed = function(e, t, r, i, n) {
                if (this.haveAssignBlock) {
                    if (e < this.blockSum && e > -1)
                        for (var a = this.blocks[e], o = J.BLOCK_SIZE / J.PIECE_SIZE, s = Math.min(t + r, o), l = t; l < s; l++)
                            switch (i) {
                            case U.HTTP:
                                a.httpChoosed[l] = !0 === n ? 1 : 0;
                                break;
                            case U.P2P:
                                a.p2pChoosed[l] = !0 === n ? 1 : 0
                            }
                } else
                    Ar.error(this.getLogScope(), this.getLogStatus(), "setPieceChoosed error, no assign block.")
            }
            ,
            e.prototype.getChecksum = function(e) {
                if (!this.haveAssignBlock)
                    return Ar.error(this.getLogScope(), this.getLogStatus(), "getChecksum error, no assign block."),
                    0;
                var t;
                if (e < this.blockSum && e > -1) {
                    var r = this.blocks[e];
                    if (r || (this.assignBlock(),
                    r = this.blocks[e]),
                    void 0 !== r)
                        return 0 === (t = r.check) && (t = this.calChecksum(e),
                        this.setChecksum(e, t)),
                        t
                }
                return 0
            }
            ,
            e.prototype.calChecksum = function(e) {
                if (e < this.blockSum && e > -1 && this.isBitSet(this.bitmap, e)) {
                    var t = this.readBlockData(e);
                    return Tr.getChecksum(t)
                }
                return 0
            }
            ,
            e.prototype.setChecksum = function(e, t) {
                if (this.haveAssignBlock) {
                    if (e < this.blockSum && e > -1) {
                        var r = this.blocks[e];
                        r || (this.assignBlock(),
                        r = this.blocks[e]),
                        r.check = t
                    }
                } else
                    Ar.error(this.getLogScope(), this.getLogStatus(), "setChecksum error, no assign block.")
            }
            ,
            e.prototype.resetBlockData = function(e) {
                if (this.haveAssignBlock) {
                    if (e < this.blockSum && e > -1 && this.isBitSet(this.bitmap, e)) {
                        var t = this.blocks[e];
                        this.unSetBit(this.bitmap, e),
                        t.bitmap = new Uint8Array(J.BLOCK_SIZE / J.PIECE_SIZE),
                        t.p2pChoosed = new Uint8Array(J.BLOCK_SIZE / J.PIECE_SIZE),
                        t.httpChoosed = new Uint8Array(J.BLOCK_SIZE / J.PIECE_SIZE),
                        t.check = 0,
                        e === this.blockSum - 1 && this.setLastBlockBitmap(e),
                        Ar.debug(this.getLogScope(), this.getLogStatus(), "Reset block data blockID:" + e)
                    }
                } else
                    Ar.error(this.getLogScope(), this.getLogStatus(), "resetBlockData error, no assign block.")
            }
            ,
            e.prototype.getBlockCount = function() {
                return this.blocks.length
            }
            ,
            e.prototype.getCacheSize = function() {
                return this.cacheSize
            }
            ,
            e.prototype.getFileSize = function() {
                return this.fileSize
            }
            ,
            e.prototype.getFirstRange = function(e) {
                var t = {
                    start: 0,
                    end: -1,
                    headBlockID: 0,
                    headPieceID: 0,
                    tailBlockID: 0,
                    tailPieceID: 0
                };
                if (!this.haveAssignBlock && !this.assignBlock())
                    return null;
                var r = J.BLOCK_SIZE / J.PIECE_SIZE
                  , i = this.getFirstUnfinishedBlock(e);
                if (null === i)
                    return null;
                for (var n = this.blocks[i], a = 0; a < r; a++)
                    if (!this.isSetUint8Bitmap(n.bitmap, a)) {
                        t.start = i * J.BLOCK_SIZE + a * J.PIECE_SIZE,
                        t.headBlockID = i,
                        t.headPieceID = a;
                        break
                    }
                var o = this.getEndUnfinishedBlock(e);
                if (null === o)
                    return null;
                var s = this.blocks[o];
                for (a = r - 1; a >= 0; a--)
                    if (!this.isSetUint8Bitmap(s.bitmap, a)) {
                        var l = o * J.BLOCK_SIZE + (a + 1) * J.PIECE_SIZE;
                        t.end = l > this.fileSize - 1 ? this.fileSize - 1 : l,
                        t.tailBlockID = o + 1,
                        t.tailPieceID = a + 1;
                        break
                    }
                return 0 === t.start && t.end === this.fileSize - 1 && (t.end = -1),
                t
            }
            ,
            e.prototype.getAllowP2P = function() {
                return this.mediaFile.allowP2P && this.allowP2P
            }
            ,
            e.prototype.setAllowP2P = function(e) {
                this.allowP2P = e
            }
            ,
            e.prototype.addCheckFail = function() {
                this.checkFailTimes += 1,
                this.checkFailTimes >= Lr.maxTsCheckFailTimes && (this.allowP2P = !1)
            }
            ,
            e.prototype.getDownloadSource = function() {
                return [+this.getFromHTTP, +this.getFromP2P, +this.getFromDB]
            }
            ,
            e.prototype.assignBlock = function() {
                if (0 === this.fileSize || void 0 === this.fileSize)
                    return Ar.warn(this.getLogScope(), this.getLogStatus(), "Assign block, has no fileSize."),
                    !1;
                if (!0 === this.haveAssignBlock)
                    return !0;
                this.blockSum = Math.floor(this.fileSize / J.BLOCK_SIZE),
                this.fileSize % J.BLOCK_SIZE > 0 && (this.blockSum += 1),
                this.lastBlockSize = this.fileSize % J.BLOCK_SIZE == 0 ? J.BLOCK_SIZE : this.fileSize % J.BLOCK_SIZE;
                var e, t = Math.floor((this.blockSum + 7) / 8);
                this.bitmap = new ArrayBuffer(t);
                for (var r = this.blockSum; r < 8 * this.bitmap.byteLength; r++)
                    this.setBit(this.bitmap, r);
                Ar.info(this.getLogScope(), this.getLogStatus(), "AssignBlock blockSum = " + this.blockSum + ", this.fileSize = " + this.fileSize + ", lastBlockSize = " + this.lastBlockSize);
                for (var i = 0; i < this.blockSum; i++)
                    e = {
                        blockID: i,
                        bitmap: new Uint8Array(J.BLOCK_SIZE / J.PIECE_SIZE),
                        p2pChoosed: new Uint8Array(J.BLOCK_SIZE / J.PIECE_SIZE),
                        httpChoosed: new Uint8Array(J.BLOCK_SIZE / J.PIECE_SIZE),
                        check: 0,
                        blockSize: J.BLOCK_SIZE
                    },
                    this.blocks.push(e),
                    i === this.blockSum - 1 && (this.setLastBlockBitmap(i),
                    this.fileSize % J.BLOCK_SIZE > 0 && (e.blockSize = this.fileSize % J.BLOCK_SIZE));
                return this.haveAssignBlock = !0,
                !0
            }
            ,
            e.prototype.getUnfinishedPieceInfoForP2P = function(e) {
                if (!this.haveAssignBlock)
                    return Ar.error(this.getLogScope(), this.getLogStatus(), "getUnfinishedPieceInfoForP2P error, no assign block."),
                    null;
                var t = this.blocks[e];
                if (void 0 === t)
                    return null;
                var r = {
                    p2pIndex: -1,
                    blockID: -1,
                    pieceArray: [],
                    fileSize: this.fileSize
                }
                  , i = J.BLOCK_SIZE / J.PIECE_SIZE;
                r.p2pIndex = de.getInstance().getIndexAdapter(this.mediaFile.keyID).snToIndex(this.sn).p2p,
                r.blockID = e;
                for (var n = 0; n < i; n++)
                    this.isSetUint8Bitmap(t.bitmap, n) || this.isSetUint8Bitmap(t.p2pChoosed, n) || this.isSetUint8Bitmap(t.httpChoosed, n) || r.pieceArray.push(n);
                return r
            }
            ,
            e.prototype.getFirstUnfinishedBlock = function(e) {
                for (var t = this.getPartBlockRange(e), r = t.start, i = t.end, n = r; n < i; n++)
                    if (!this.isBitSet(this.bitmap, n))
                        return n;
                return null
            }
            ,
            e.prototype.getEndUnfinishedBlock = function(e) {
                for (var t = this.getPartBlockRange(e), r = t.start, i = t.end - 1; i >= r; i--)
                    if (!this.isBitSet(this.bitmap, i))
                        return i;
                return null
            }
            ,
            e.prototype.isBitSet = function(e, t) {
                return void 0 !== e && !!(new Uint8Array(e)[t >> 3] << t % 8 & 128)
            }
            ,
            e.prototype.setBit = function(e, t) {
                new Uint8Array(e)[t >> 3] |= 128 >> t % 8
            }
            ,
            e.prototype.isSetUint8Bitmap = function(e, t) {
                return !!e[t]
            }
            ,
            e.prototype.unSetBit = function(e, t) {
                new Uint8Array(e)[t >> 3] &= ~(128 >> t % 8)
            }
            ,
            e.prototype.readBytes = function(e, t) {
                var r = null;
                return void 0 !== this.buffer && e >= 0 && e + t <= this.buffer.byteLength && (r = this.buffer.slice ? this.buffer.slice(e, e + t) : Array.prototype.slice.call(this.buffer, e, e + t)),
                r
            }
            ,
            e.prototype.writeBytes = function(e, t, r, i) {
                if (void 0 !== this.buffer) {
                    var n = new Uint8Array(this.buffer)
                      , a = new Uint8Array(t).subarray(r, r + i);
                    a.byteLength + e > n.byteLength ? Ar.debug(this.getLogScope(), this.getLogStatus(), "WriteBytes writeDataView.byteLength[" + a.byteLength + "] + postion[" + e + "] > writeDataView.byteLength[" + a.byteLength + "]") : n.set(a, e)
                }
            }
            ,
            e.prototype.writeBitmap = function(e, t, r, i) {
                void 0 === i && (i = !1);
                var n = this.blockWithID(e);
                if (null !== n) {
                    for (var a = n.bitmap, o = J.BLOCK_SIZE / J.PIECE_SIZE, s = t - e * o, l = s + r, c = s; c < o && c < l; c++)
                        this.isSetUint8Bitmap(a, c) || (n.bitmap[c] = 1,
                        this.cacheSize += i && c === l - 1 ? this.fileSize % J.PIECE_SIZE : J.PIECE_SIZE);
                    for (var h = 0; h < a.length && 1 === a[h]; h++)
                        ;
                    if (h >= a.length && (this.setBit(this.bitmap, e),
                    0 !== n.check)) {
                        var u = this.calChecksum(e);
                        if (n.check !== u) {
                            var d = de.getInstance().getIndexAdapter(this.mediaFile.keyID).snToIndex(this.sn);
                            this.resetBlockData(e),
                            this.mediaFile.addCheckFail(d),
                            le.getItem(this.mediaFile.keyID).checkFailTimes += 1,
                            le.getItem(this.mediaFile.keyID).p2pCheckFailByte += n.blockSize,
                            Ar.info(this.getLogScope(), this.getLogStatus(), "Check failed blockID " + e + "."),
                            Ar.uploadLog(ne.P2PDataCheckFailed, Lr.uploadLogRate2)
                        } else
                            le.getItem(this.mediaFile.keyID).checkSuccTimes += 1
                    }
                }
            }
            ,
            e.prototype.readBlockData = function(e) {
                if (null === this.blockWithID(e))
                    return Ar.error(this.getLogScope(), this.getLogStatus(), "readBlockData blockID " + e + " not exist."),
                    null;
                var t = e * J.BLOCK_SIZE;
                if (e === this.blocks.length - 1) {
                    var r = this.fileSize % J.BLOCK_SIZE;
                    if (this.isBitSet(this.bitmap, e))
                        return this.readBytes(t, r)
                } else if (this.isBitSet(this.bitmap, e))
                    return this.readBytes(t, J.BLOCK_SIZE);
                return null
            }
            ,
            e.prototype.blockIndexWithPos = function(e) {
                return Math.floor(e / J.BLOCK_SIZE)
            }
            ,
            e.prototype.blockWithID = function(e) {
                return e >= 0 && e < this.blocks.length ? this.blocks[e] : null
            }
            ,
            e.prototype.setLastBlockBitmap = function(e) {
                if (null !== this.blockWithID(e) && this.fileSize % J.BLOCK_SIZE != 0) {
                    var t = Math.floor(this.lastBlockSize / J.PIECE_SIZE);
                    this.lastBlockSize % J.PIECE_SIZE > 0 && (t += 1);
                    for (var r = t; r < J.BLOCK_SIZE / J.PIECE_SIZE; r++)
                        this.blockWithID(e).bitmap[r] = 1
                }
            }
            ,
            e.prototype.getPartBlockRange = function(e) {
                var t = 0
                  , r = this.blockSum;
                return void 0 !== e && (t = 8 * Math.floor(this.bitmap.byteLength * (e / Lr.liveDownloadPartNum)),
                e !== Lr.liveDownloadPartNum - 1 && (r = 8 * Math.floor(this.bitmap.byteLength * ((e + 1) / Lr.liveDownloadPartNum)))),
                {
                    start: t,
                    end: r
                }
            }
            ,
            e.prototype.getFileSizeFromServer = function() {
                if (Oe.getInstance().getTask(this.mediaFile.keyID).canGetFileSizeFromServer && Oe.getInstance().getTask(this.mediaFile.keyID).startPlaying) {
                    var e = {
                        method: "get",
                        url: this.url,
                        range: [0, 1],
                        timeout: 1e3,
                        onloadsuccess: this.loadFileSizeSuccess.bind(this)
                    };
                    te.xhrSend(e)
                }
            }
            ,
            e.prototype.loadFileSizeSuccess = function(e) {
                try {
                    var t = e.getResponseHeader("content-range");
                    if (null === t)
                        throw Ar.error("TSCache", "sn:" + this.sn, "cannot get content-range"),
                        "cannot get content-range";
                    this.fileSize = parseInt(t.match(/^bytes\s[0-9]+-[0-9]+\/([0-9]+)$/)[1], 10),
                    Ar.info("TSCache", "sn:" + this.sn, "get fileSize " + this.fileSize + " by xhr.")
                } catch (e) {
                    Oe.getInstance().getTask(this.mediaFile.keyID).canUseRange = !1,
                    Oe.getInstance().getTask(this.mediaFile.keyID).canGetFileSizeFromServer = !1
                }
            }
            ,
            e.prototype.getLogScope = function() {
                return "TSCache"
            }
            ,
            e.prototype.getLogStatus = function() {
                return "Seq:" + this.mediaFile.seq + ",sn:" + this.sn
            }
            ,
            e.prototype.isFullInCache = function(e) {
                if (!this.haveAssignBlock)
                    return !1;
                for (var t = new Uint8Array(this.bitmap), r = this.getPartBlockRange(e), i = r.start, n = r.end, a = i / 8; a < n / 8; a++)
                    if (255 !== t[a])
                        return !1;
                return ut.getInstance().canWriteDB() && this.mediaFile.getTaskType() === B.Vod && this.getAllowP2P() && void 0 === e && !this.isInDB && this.writeToDB(),
                !0
            }
            ,
            e.prototype.isBlockFullInCache = function(e) {
                return !!(e > -1 && this.buffer && this.blocks && e < this.blocks.length && this.isBitSet(this.bitmap, e))
            }
            ,
            e.prototype.checkDB = function() {
                return D(this, void 0, void 0, (function() {
                    var e;
                    return k(this, (function(t) {
                        switch (t.label) {
                        case 0:
                            return e = !1,
                            this.isInDB && this.getAllowP2P() ? this.isFullInCache() ? [3, 2] : [4, this.readFromDB()] : [2, e];
                        case 1:
                            e = t.sent(),
                            t.label = 2;
                        case 2:
                            return [2, e]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.readFromDB = function() {
                return D(this, void 0, void 0, (function() {
                    var e, t, r, i, n;
                    return k(this, (function(a) {
                        switch (a.label) {
                        case 0:
                            if (e = this.mediaFile.keyID,
                            t = ut.getDBCache(),
                            r = de.getInstance().getIndexAdapter(e).snToIndex(this.sn).p2p,
                            !t)
                                return [2, !1];
                            if (null == r)
                                return [2, !1];
                            a.label = 1;
                        case 1:
                            return a.trys.push([1, 3, , 4]),
                            [4, this.readWithTimeout({
                                keyID: e,
                                index: r
                            })];
                        case 2:
                            if (i = a.sent(),
                            !this.checkResourceValid(i))
                                throw new Error("readDB resource invalid");
                            return this.isInDB = !0,
                            this.isFullInCache() ? [3, 4] : i.data[0].data.byteLength !== this.fileSize ? (Ar.error(this.getLogScope(), this.getLogStatus(), "data read from db filesize: " + i.data[0].data.byteLength + " != this.filesize: " + this.fileSize + "."),
                            this.isInDB = !1,
                            [2, !1]) : (this.writeStream(0, i.data[0].data, U.IndexedDB),
                            Ar.info(this.getLogScope(), this.getLogStatus(), "readFromDB success."),
                            [2, !0]);
                        case 3:
                            return n = a.sent(),
                            J.accessDBErrorTimes += 1,
                            this.isInDB = !1,
                            Ar.error(this.getLogScope(), this.getLogStatus(), "readFromDB error:", n.message),
                            [2, !1];
                        case 4:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.readWithTimeout = function(e) {
                return D(this, void 0, void 0, (function() {
                    var t, r;
                    return k(this, (function(i) {
                        return t = ut.getDBCache().read(e),
                        r = new Promise((function(e, t) {
                            return setTimeout((function() {
                                return t(new Error("readDB timed out"))
                            }
                            ), Lr.readDBtimeout)
                        }
                        )),
                        [2, Promise.race([t, r])]
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.writeToDB = function() {
                return D(this, void 0, void 0, (function() {
                    var e, t, r, i = this;
                    return k(this, (function(n) {
                        switch (n.label) {
                        case 0:
                            return e = this.mediaFile.keyID,
                            null == (t = de.getInstance().getIndexAdapter(e).snToIndex(this.sn).p2p) ? [3, 3] : this.prepareWriteToDB() ? this.buffer ? "ok" !== (r = ut.getDBCache().write({
                                keyID: e,
                                index: t,
                                data: this.buffer
                            })).status ? [3, 1] : (this.isInDB = !0,
                            Ar.info(this.getLogScope(), this.getLogStatus(), "writeToDB success."),
                            r.data[0].then((function(e) {
                                "err" === e.status ? (i.isInDB = !1,
                                J.accessDBErrorTimes += 1,
                                Ar.warn(i.getLogScope(), i.getLogStatus(), "writeToDB failed finally.")) : (i.isDownloadToDB = !0,
                                le.getItem(i.mediaFile.keyID).savedBytes += i.fileSize)
                            }
                            )),
                            [3, 3]) : [2] : [3, 3];
                        case 1:
                            return "err" !== r.status || "QUOTA_EXCEEDED" !== r.reason ? [3, 3] : [4, ut.getInstance().releaseDBCache(this.mediaFile.keyID, this.fileSize)];
                        case 2:
                            if (n.sent())
                                return [2, this.writeToDB()];
                            Ar.debug(this.getLogScope(), this.getLogStatus(), "DB has no space to write."),
                            n.label = 3;
                        case 3:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.prepareWriteToDB = function() {
                var e = ut.getDBCache();
                if ("visible" !== document.visibilityState)
                    return !1;
                if (!this.mediaFile.hasTorrent())
                    return !1;
                if (!this.getAllowP2P())
                    return !1;
                var t = this.mediaFile.keyID;
                return !(!e.getMetadata(t) && !e.setMetadata(t, this.mediaFile.getMetadata()))
            }
            ,
            e.prototype.checkResourceValid = function(e) {
                var t, r, i = this.mediaFile.keyID, n = de.getInstance().getIndexAdapter(i).snToIndex(this.sn).p2p;
                return "ok" === e.status && (null === (t = e.data[0]) || void 0 === t ? void 0 : t.keyID) === i && (null === (r = e.data[0]) || void 0 === r ? void 0 : r.index) === n
            }
            ,
            e
        }()
          , Be = function() {
            function e(t, r, i) {
                e.publicSeq += 1,
                this.seq = e.publicSeq,
                this.keyID = r,
                this.taskType = i.taskType,
                this.isPlayTask = i.isPlayTask,
                this.allowP2P = i.useP2P,
                this.tsArray = [],
                this.adTsArray = [],
                this.fileIDArray = [],
                this.tsNumArray = [],
                this.checkFailTimes = 0,
                this.wrongDataTimes = 0,
                this.setTsInfo(t)
            }
            return e.prototype.getTaskType = function() {
                return this.taskType
            }
            ,
            e.prototype.getMetadata = function() {
                var e, t, r = [];
                try {
                    for (var i = C(this.tsArray), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value;
                        r.push(a.getMetaData())
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return [this.fileIDArray, this.tsNumArray, r]
            }
            ,
            e.prototype.getTsBitmap = function(e) {
                var t = this.getTSCache(e);
                return t ? t.getTsBitmap() : null
            }
            ,
            e.prototype.writeData = function(e, t, r, i) {
                var n = this.getTSCache(e);
                n && n.writeStream(t, r, i)
            }
            ,
            e.prototype.readTsData = function(e) {
                var t = this.getTSCache(e);
                return t ? t.readTsData() : null
            }
            ,
            e.prototype.readBlocksData = function(e, t, r) {
                var i = this.getTSCache(e);
                return i ? i.readBlocksData(t, r) : null
            }
            ,
            e.prototype.readPiecesData = function(e, t, r, i) {
                var n = this.getTSCache(e);
                return n ? n.readPiecesData(t, r, i) : null
            }
            ,
            e.prototype.isTsFinished = function(e, t) {
                var r = this.getTSCache(e);
                return !!r && r.isFinish(t)
            }
            ,
            e.prototype.getUnloadIndex = function(e, t, r) {
                var i, n, a = de.getInstance().getIndexAdapter(this.keyID);
                try {
                    for (var o = C(a.getIterator(e)), s = o.next(); !s.done; s = o.next()) {
                        var l = s.value;
                        if (this.getTSCache(l.cache) && !this.getTSCache(l.cache).isFinish(r) && (t === U.HTTP || l.p2p))
                            return l
                    }
                } catch (e) {
                    i = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (n = o.return) && n.call(o)
                    } finally {
                        if (i)
                            throw i.error
                    }
                }
                return null
            }
            ,
            e.prototype.getUrl = function(e) {
                var t = this.getTSCache(e);
                return t ? t.getUrl() : null
            }
            ,
            e.prototype.getBitrate = function(e) {
                var t = this.getTSCache(e);
                return (null == t ? void 0 : t.getDuration()) > 0 ? Math.floor(t.getFileSize() / t.getDuration()) : 0
            }
            ,
            e.prototype.setTsFileSize = function(e, t) {
                var r;
                null === (r = this.getTSCache(e)) || void 0 === r || r.setFilesize(t)
            }
            ,
            e.prototype.getTsSize = function(e) {
                var t = this.getTSCache(e);
                return t ? t.getFileSize() : 0
            }
            ,
            e.prototype.getTotalCacheSize = function() {
                var e, t, r, i, n = 0;
                try {
                    for (var a = C(this.tsArray), o = a.next(); !o.done; o = a.next()) {
                        (null == (c = o.value) ? void 0 : c.hasAllocBuffer()) && (n += c.getCacheSize())
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        o && !o.done && (t = a.return) && t.call(a)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                try {
                    for (var s = C(this.adTsArray), l = s.next(); !l.done; l = s.next()) {
                        var c;
                        (null == (c = l.value) ? void 0 : c.hasAllocBuffer()) && (n += c.getCacheSize())
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        l && !l.done && (i = s.return) && i.call(s)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                return n
            }
            ,
            e.prototype.hasAllocBuffer = function(e) {
                var t;
                return null === (t = this.getTSCache(e)) || void 0 === t ? void 0 : t.hasAllocBuffer()
            }
            ,
            e.prototype.getCacheSize = function(e) {
                var t = this.getTSCache(e);
                return t ? t.getCacheSize() : 0
            }
            ,
            e.prototype.deleteTsCache = function(e, t) {
                var r, i;
                void 0 === t && (t = !0),
                this.taskType === B.Live ? (null === (r = this.getTSCache(e)) || void 0 === r || r.releaseCache(),
                this.setTSCache(e)) : null === (i = this.getTSCache(e)) || void 0 === i || i.releaseData(t)
            }
            ,
            e.prototype.getTsSum = function() {
                return this.tsArray.length + this.adTsArray.length
            }
            ,
            e.prototype.hasTorrent = function() {
                return this.taskType === B.Live || 0 !== this.fileIDArray.length && 0 !== this.tsNumArray.length
            }
            ,
            e.prototype.setFileID = function(e, t) {
                var r, i;
                this.fileIDArray = e;
                var n = 0;
                this.tsNumArray = [];
                try {
                    for (var a = C(t), o = a.next(); !o.done; o = a.next()) {
                        n += o.value,
                        this.tsNumArray.push(n)
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        o && !o.done && (i = a.return) && i.call(a)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
            }
            ,
            e.prototype.setFileIDByMetadata = function(e, t) {
                this.fileIDArray = e,
                this.tsNumArray = t
            }
            ,
            e.prototype.getFileID = function(e) {
                if (e >= 0)
                    for (var t = 0; t < this.tsNumArray.length; t++)
                        if (e < this.tsNumArray[t] && t < this.fileIDArray.length)
                            return this.fileIDArray[t];
                return null
            }
            ,
            e.prototype.generateFileID = function() {
                var e = this.getP2PTSCount()
                  , t = Math.ceil(e / Er.vodFileIDTSNum);
                e % Er.vodFileIDTSNum < Er.vodFileIDTSNum / 2 && (t -= 1);
                for (var r = Math.floor(e / t), i = e % t, n = 0, a = 0; a < t; a++)
                    this.fileIDArray.push(Tr.bkdrHash(this.keyID + a)),
                    n += a < i ? r + 1 : r,
                    this.tsNumArray.push(n)
            }
            ,
            e.prototype.setAllowP2P = function(e, t) {
                var r;
                void 0 !== t ? null === (r = this.getTSCache(t)) || void 0 === r || r.setAllowP2P(e) : this.allowP2P = e
            }
            ,
            e.prototype.getAllowP2P = function(e) {
                var t = this.getTSCache(e);
                return !!t && t.getAllowP2P()
            }
            ,
            e.prototype.addCheckFail = function(e) {
                this.checkFailTimes += 1,
                this.checkFailTimes >= Er.maxKeyIDCheckFailTimes && (this.allowP2P = !1),
                this.getTSCache(e.cache).addCheckFail()
            }
            ,
            e.prototype.getReportFileIDs = function() {
                var e = [];
                do {
                    if (this.taskType === B.Vod) {
                        if (0 === this.fileIDArray.length || this.fileIDArray.length !== this.tsNumArray.length)
                            break;
                        if (!this.allowP2P)
                            break;
                        for (var t = 0, r = 0; r < this.fileIDArray.length; r++)
                            this.canReportFileID(r, t) && e.push(this.fileIDArray[r]),
                            t = this.tsNumArray[r]
                    } else
                        e.push(this.keyID + ".h5")
                } while (0);
                return {
                    add: e,
                    del: []
                }
            }
            ,
            e.prototype.constructDownloadPieceInfoForP2P = function(e, t) {
                for (var r = this.getUnfinishedTsForP2P(e, t), i = [], n = r.length, a = 0; a < n; a++)
                    i.push.apply(i, w([], L(r[a].getUnfinishPieceInfoForP2P())));
                return i
            }
            ,
            e.prototype.setTsChoosed = function(e, t, r) {
                var i;
                null === (i = this.getTSCache(e)) || void 0 === i || i.setTsChoosed(t, r)
            }
            ,
            e.prototype.setPieceChoosed = function(e, t, r, i, n, a) {
                var o;
                null === (o = this.getTSCache(e)) || void 0 === o || o.setPieceChoosed(t, r, i, n, a)
            }
            ,
            e.prototype.getChecksum = function(e, t) {
                var r = this.getTSCache(e);
                return r ? r.getChecksum(t) : 0
            }
            ,
            e.prototype.calChecksum = function(e, t) {
                var r = this.getTSCache(e);
                return r ? r.calChecksum(t) : 0
            }
            ,
            e.prototype.setChecksum = function(e, t, r) {
                var i;
                null === (i = this.getTSCache(e)) || void 0 === i || i.setChecksum(t, r)
            }
            ,
            e.prototype.resetBlockData = function(e, t) {
                var r;
                null === (r = this.getTSCache(e)) || void 0 === r || r.resetBlockData(t)
            }
            ,
            e.prototype.getFileSize = function(e) {
                var t = this.getTSCache(e);
                return t ? t.getFileSize() : 0
            }
            ,
            e.prototype.getPlayableTime = function(e, t) {
                var r, i, n = de.getInstance().getIndexAdapter(this.keyID), a = 0, o = t;
                try {
                    for (var s = C(n.getIterator(e)), l = s.next(); !l.done; l = s.next()) {
                        var c = l.value;
                        if (o)
                            o = !1;
                        else {
                            if (!this.isTsFinished(c.cache))
                                break;
                            a += this.getTsDuration(c.cache)
                        }
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        l && !l.done && (i = s.return) && i.call(s)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                return a
            }
            ,
            e.prototype.getPlayableTimeByPlayPoint = function(e) {
                var t, r, i = de.getInstance().getIndexAdapter(this.keyID), n = 0, a = n === e;
                try {
                    for (var o = C(i.getIterator()), s = o.next(); !s.done; s = o.next()) {
                        var l = s.value
                          , c = this.getTsDuration(l.cache);
                        if (a || (n + c >= e ? a = !0 : n += c),
                        a) {
                            if (!this.isTsFinished(l.cache))
                                break;
                            n += c
                        }
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (r = o.return) && r.call(o)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return Math.max(n - e, 0)
            }
            ,
            e.prototype.checkFileSize = function(e, t) {
                var r;
                null === (r = this.getTSCache(t)) || void 0 === r || r.checkFileSize(e)
            }
            ,
            e.prototype.getFirstRange = function(e, t) {
                var r = this.getTSCache(e);
                return r ? r.getFirstRange(t) : null
            }
            ,
            e.prototype.setTsInfo = function(e) {
                var t, r;
                this.adTsArray = [];
                var i = de.getInstance().getIndexAdapter(this.keyID);
                this.taskType === B.Live && (this.startIndex = i.snToIndex(e[0].sn));
                try {
                    for (var n = C(e), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value
                          , s = i.snToIndex(o.sn);
                        if (void 0 !== s.p2p && null !== s.p2p && this.getTSCache(s.cache))
                            this.getTSCache(s.cache).setFragInfo(o);
                        else {
                            var l = new Fe(this,o);
                            this.setTSCache(s.cache, l)
                        }
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (r = n.return) && r.call(n)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
            }
            ,
            e.prototype.updateTsInfo = function(e) {
                var t, r, i = de.getInstance().getIndexAdapter(this.keyID);
                this.taskType === B.Live && (this.startIndex = i.snToIndex(e[0].sn));
                try {
                    for (var n = C(e), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value
                          , s = i.snToIndex(o.sn);
                        if (this.getTSCache(s.cache))
                            this.getTSCache(s.cache).setFragInfo(o);
                        else {
                            var l = new Fe(this,o);
                            this.setTSCache(s.cache, l)
                        }
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (r = n.return) && r.call(n)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
            }
            ,
            e.prototype.getLiveExpiredTs = function(e) {
                var t, r, i = de.getInstance().getIndexAdapter(this.keyID);
                if (!this.tsArray[e.cache] || this.tsArray[this.startIndex.cache])
                    return null;
                try {
                    for (var n = C(i.getIterator(e)), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        if (this.tsArray[o.cache] && !this.tsArray[o.cache].isFinish() && o.cache <= this.startIndex.cache + Er.liveDownloadExpiredTSNum)
                            return o
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (r = n.return) && r.call(n)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return null
            }
            ,
            e.prototype.isDownloadFinishAfterIndex = function(e) {
                var t, r, i, n = de.getInstance().getIndexAdapter(this.keyID);
                try {
                    for (var a = C(n.getIterator(e)), o = a.next(); !o.done; o = a.next()) {
                        var s = o.value;
                        if (!(null === (i = this.getTSCache(s.cache)) || void 0 === i ? void 0 : i.isFinish()))
                            return !1
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        o && !o.done && (r = a.return) && r.call(a)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return !0
            }
            ,
            e.prototype.getLastAccessTime = function(e) {
                return this.getTSCache(e) ? this.getTSCache(e).lastAccessTime : 0
            }
            ,
            e.prototype.getTSCache = function(e) {
                return e >= 0 ? this.tsArray[e] : this.adTsArray[-1 - e]
            }
            ,
            e.prototype.setTSCache = function(e, t) {
                e >= 0 ? this.tsArray[e] = t : this.adTsArray[-1 - e] = t
            }
            ,
            e.prototype.hasInDB = function() {
                var e, t;
                if (this.taskType === B.Live)
                    return !1;
                try {
                    for (var r = C(this.tsArray), i = r.next(); !i.done; i = r.next()) {
                        if (i.value.isInDB)
                            return !0
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        i && !i.done && (t = r.return) && t.call(r)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return !1
            }
            ,
            e.prototype.isInDB = function(e) {
                var t;
                return null === (t = this.getTSCache(e)) || void 0 === t ? void 0 : t.isInDB
            }
            ,
            e.prototype.disableDBCache = function() {
                var e, t;
                if (this.taskType !== B.Live)
                    try {
                        for (var r = C(this.tsArray), i = r.next(); !i.done; i = r.next()) {
                            i.value.isInDB = !1
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            i && !i.done && (t = r.return) && t.call(r)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
            }
            ,
            e.prototype.getUnfinishedTsForP2P = function(e, t) {
                var r, i, n = de.getInstance().getIndexAdapter(this.keyID), a = [];
                try {
                    for (var o = C(n.getIterator(e)), s = o.next(); !s.done; s = o.next()) {
                        var l = s.value;
                        if (a.length >= t)
                            break;
                        this.getTSCache(l.cache).getAllowP2P() && void 0 !== l.p2p && null !== l.p2p && (this.getTSCache(l.cache).isFinish() || a.push(this.getTSCache(l.cache)))
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (i = o.return) && i.call(o)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                return a
            }
            ,
            e.prototype.canReportFileID = function(e, t) {
                var r;
                if (e >= this.tsNumArray.length)
                    return !1;
                for (var i = this.tsNumArray[e], n = t; n < i; n++) {
                    var a = !1
                      , o = null === (r = de.getInstance().getIndexAdapter(this.keyID)) || void 0 === r ? void 0 : r.p2pToIndex(n);
                    if (void 0 !== o) {
                        var s = this.tsArray[o.cache];
                        if (void 0 !== s) {
                            if (s.isInDB)
                                return !0;
                            for (var l = s.getBlockCount(), c = 0; c < l; c++)
                                if (s.isBlockFull(c) && s.getAllowP2P()) {
                                    a = !0;
                                    break
                                }
                        }
                    }
                    if (a)
                        return !0
                }
                return !1
            }
            ,
            e.prototype.getTsDuration = function(e) {
                var t = this.getTSCache(e);
                return t ? t.getDuration() : 0
            }
            ,
            e.prototype.getP2PTSCount = function() {
                var e, t, r = de.getInstance().getIndexAdapter(this.keyID), i = 0;
                try {
                    for (var n = C(this.tsArray), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        void 0 !== r.snToIndex(o.sn).p2p && (i += 1)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return i
            }
            ,
            e.publicSeq = -1,
            e
        }()
          , Me = function() {
            function e() {
                this.lastReported = []
            }
            return e.getInstance = function() {
                return void 0 === this.instance && (this.instance = new e),
                this.instance
            }
            ,
            e.prototype.destroy = function() {
                this.lastReported = [],
                e.instance = void 0
            }
            ,
            e.prototype.reportResource2Server = function(e, t) {
                var r, i;
                t && (this.lastReported = []);
                try {
                    for (var n = C(e.keys()), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        if (le.getItem(o).taskInfo.useP2P) {
                            var s = e.get(o).getReportFileIDs()
                              , l = this.getReportObj(o, this.lastReported);
                            s = this.getIncreasementReportObj(s, l),
                            this.report(s, o)
                        }
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (i = n.return) && i.call(n)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
            }
            ,
            e.prototype.add2LastReported = function(e, t) {
                for (var r, i, n = -1, a = null, o = 0; o < this.lastReported.length; o++)
                    if (t === this.lastReported[o].keyID) {
                        a = this.lastReported[o],
                        n = o;
                        break
                    }
                if (a || 0 !== e.add.length)
                    if (a) {
                        e.add.length > 0 && (a.obj.add = a.obj.add.concat(e.add));
                        var s = e.del
                          , l = a.obj.add;
                        if (s.length > 0)
                            try {
                                for (var c = C(s), h = c.next(); !h.done; h = c.next()) {
                                    o = h.value;
                                    for (var u = 0; u < l.length; u++)
                                        if (l[u] === o) {
                                            l.splice(u, 1);
                                            break
                                        }
                                }
                            } catch (e) {
                                r = {
                                    error: e
                                }
                            } finally {
                                try {
                                    h && !h.done && (i = c.return) && i.call(c)
                                } finally {
                                    if (r)
                                        throw r.error
                                }
                            }
                        0 === a.obj.add.length && this.lastReported.splice(n, 1)
                    } else {
                        var d = this.getReportObjContainer(t, e);
                        this.lastReported.push(d)
                    }
            }
            ,
            e.prototype.report = function(e, t) {
                0 === e.add.length && 0 === e.del.length || !0 === (ut.getInstance().getTaskType(t) === B.Vod ? hr : ur).getInstance().report(e.add, e.del) && (this.add2LastReported(e, t),
                Ar.info("ReportResource", "Seq:" + ut.getInstance().getFileSeq(t), "Report FileID add:[" + e.add + "],del:[" + e.del + "]."))
            }
            ,
            e.prototype.getReportObj = function(e, t) {
                var r, i;
                try {
                    for (var n = C(t), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        if (o.keyID === e)
                            return o.obj
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (i = n.return) && i.call(n)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                return null
            }
            ,
            e.prototype.getReportObjContainer = function(e, t) {
                return {
                    keyID: e,
                    obj: t
                }
            }
            ,
            e.prototype.getIncreasementReportObj = function(e, t) {
                var r, i, n, a, o, s, l, c;
                if (null == t)
                    return e;
                var h = {
                    add: [],
                    del: []
                }
                  , u = e.add
                  , d = t.add;
                try {
                    for (var f = C(u), p = f.next(); !p.done; p = f.next()) {
                        var g = p.value
                          , v = !1;
                        try {
                            for (var y = (n = void 0,
                            C(d)), m = y.next(); !m.done; m = y.next()) {
                                if (m.value === g) {
                                    v = !0;
                                    break
                                }
                            }
                        } catch (e) {
                            n = {
                                error: e
                            }
                        } finally {
                            try {
                                m && !m.done && (a = y.return) && a.call(y)
                            } finally {
                                if (n)
                                    throw n.error
                            }
                        }
                        v || h.add.push(g)
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        p && !p.done && (i = f.return) && i.call(f)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                try {
                    for (var T = C(d), S = T.next(); !S.done; S = T.next()) {
                        g = S.value,
                        v = !1;
                        try {
                            for (var I = (l = void 0,
                            C(u)), P = I.next(); !P.done; P = I.next()) {
                                if (P.value === g) {
                                    v = !0;
                                    break
                                }
                            }
                        } catch (e) {
                            l = {
                                error: e
                            }
                        } finally {
                            try {
                                P && !P.done && (c = I.return) && c.call(I)
                            } finally {
                                if (l)
                                    throw l.error
                            }
                        }
                        v || h.del.push(g)
                    }
                } catch (e) {
                    o = {
                        error: e
                    }
                } finally {
                    try {
                        S && !S.done && (s = T.return) && s.call(T)
                    } finally {
                        if (o)
                            throw o.error
                    }
                }
                return h
            }
            ,
            e
        }();
        function Ue(e, t, r, i) {
            return new (r || (r = Promise))((function(n, a) {
                function o(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function s(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? n(e.value) : (t = e.value,
                    t instanceof r ? t : new r((function(e) {
                        e(t)
                    }
                    ))).then(o, s)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        }
        function Ne(e, t) {
            var r, i, n, a, o = {
                label: 0,
                sent: function() {
                    if (1 & n[0])
                        throw n[1];
                    return n[1]
                },
                trys: [],
                ops: []
            };
            return a = {
                next: s(0),
                throw: s(1),
                return: s(2)
            },
            "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                return this
            }
            ),
            a;
            function s(s) {
                return function(l) {
                    return function(s) {
                        if (r)
                            throw new TypeError("Generator is already executing.");
                        for (; a && (a = 0,
                        s[0] && (o = 0)),
                        o; )
                            try {
                                if (r = 1,
                                i && (n = 2 & s[0] ? i.return : s[0] ? i.throw || ((n = i.return) && n.call(i),
                                0) : i.next) && !(n = n.call(i, s[1])).done)
                                    return n;
                                switch (i = 0,
                                n && (s = [2 & s[0], n.value]),
                                s[0]) {
                                case 0:
                                case 1:
                                    n = s;
                                    break;
                                case 4:
                                    return o.label++,
                                    {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    o.label++,
                                    i = s[1],
                                    s = [0];
                                    continue;
                                case 7:
                                    s = o.ops.pop(),
                                    o.trys.pop();
                                    continue;
                                default:
                                    if (!(n = o.trys,
                                    (n = n.length > 0 && n[n.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                        o = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
                                        o.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && o.label < n[1]) {
                                        o.label = n[1],
                                        n = s;
                                        break
                                    }
                                    if (n && o.label < n[2]) {
                                        o.label = n[2],
                                        o.ops.push(s);
                                        break
                                    }
                                    n[2] && o.ops.pop(),
                                    o.trys.pop();
                                    continue
                                }
                                s = t.call(e, o)
                            } catch (e) {
                                s = [6, e],
                                i = 0
                            } finally {
                                r = n = 0
                            }
                        if (5 & s[0])
                            throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }([s, l])
                }
            }
        }
        var Ge, He = "TP_RESOURCE_CACHE", qe = "RESOURCE", ze = "DEFAULT", Ke = ["keyID", "index"], Ve = "TP_RESOURCE_CACHE_TRACKING_INFO", je = "TP_RESOURCE_CACHE_DB_SIZE";
        !function(e) {
            e.ADD_KEYID = "add",
            e.UPDATE = "update",
            e.REMOVE = "remove",
            e.READ = "read",
            e.LOCK = "lock",
            e.UNLOCK = "unlock",
            e.SET_METADATA = "setMetadata",
            e.INIT = "init",
            e.SYNC = "sync"
        }(Ge || (Ge = {}));
        var We = function() {}
          , Ye = {
            log: We,
            warn: We,
            error: We
        };
        var Qe = Ye
          , Xe = function(e) {
            return {
                status: "ok",
                data: e
            }
        }
          , Ze = function(e, t) {
            return {
                status: "err",
                reason: e,
                data: t
            }
        }
          , Je = {
            isResourceEqual: function(e, t) {
                return e.keyID === t.keyID && (!Je.notNullable(t.index) || e.index === t.index)
            },
            hash: function(e) {
                var t;
                return self.btoa(JSON.stringify(((t = {}).keyID = e.keyID,
                t.index = e.index,
                t)))
            },
            decode: function(e) {
                var t, r = JSON.parse(self.atob(e)), i = r.keyID, n = r.index;
                return (t = {}).keyID = i,
                t.index = n,
                t
            },
            notNullable: function(e) {
                return null != e
            },
            validate: function(e) {
                return Je.notNullable(e.keyID) && Je.notNullable(e.index)
            },
            normalizeRangeIdentifier: function(e) {
                var t = [];
                if (Je.checkRange(e.index)) {
                    var r = e.index
                      , i = r[0]
                      , n = r[1];
                    return Je.range(+i, +n).forEach((function(r) {
                        var i;
                        t.push(((i = {}).keyID = e.keyID,
                        i.index = r,
                        i))
                    }
                    )),
                    t
                }
                return [e]
            },
            checkRange: function(e) {
                return !(!Array.isArray(e) || 2 !== e.length) && e[0] <= e[1]
            },
            range: function(e, t) {
                return function(e, t, r) {
                    if (r || 2 === arguments.length)
                        for (var i, n = 0, a = t.length; n < a; n++)
                            !i && n in t || (i || (i = Array.prototype.slice.call(t, 0, n)),
                            i[n] = t[n]);
                    return e.concat(i || Array.prototype.slice.call(t))
                }([], Array(t - e + 1), !0).map((function(t, r) {
                    return e + r
                }
                ))
            }
        }
          , $e = {
            computeKeyConstrain: function(e) {
                var t = e.keyID
                  , r = e.index;
                if (Je.notNullable(r)) {
                    if (Je.checkRange(r)) {
                        var i = r
                          , n = i[0]
                          , a = i[1];
                        return IDBKeyRange.bound([t, +n], [t, +a], !1, !1)
                    }
                    return IDBKeyRange.only([t, r])
                }
                return IDBKeyRange.bound([t, -1 / 0], [t, 1 / 0], !1, !1)
            },
            initDB: function(e) {
                var t, r = e.target.result, i = e.target.transaction;
                r.objectStoreNames.contains(qe) ? (t = i.objectStore(qe)).clear() : t = r.createObjectStore(qe, {
                    keyPath: Ke
                }),
                t.indexNames.contains("keyID") || t.createIndex("keyID", "keyID"),
                t.indexNames.contains("index") || t.createIndex("index", "index")
            },
            removeOldDB: function() {
                try {
                    self.indexedDB.deleteDatabase(He),
                    $e.delLocalItem(je),
                    $e.delLocalItem(Ve)
                } catch (e) {
                    Qe.error("remove older db failed", e)
                }
            },
            getLocalItem: function(e) {
                try {
                    return "function" == typeof self.localStorage.getItem ? self.localStorage.getItem(e) : self.localStorage[e]
                } catch (e) {
                    return null
                }
            },
            setLocalItem: function(e, t) {
                try {
                    "function" == typeof self.localStorage.setItem ? self.localStorage.setItem(e, t) : self.localStorage[e] = t
                } catch (e) {}
            },
            delLocalItem: function(e) {
                try {
                    "function" == typeof self.localStorage.removeItem ? self.localStorage.removeItem(e) : delete self.localStorage[e]
                } catch (e) {}
            }
        }
          , et = function() {
            function e() {
                this.pendingReadRequests = {}
            }
            return e.clear = function(e) {
                return void 0 === e && (e = ze),
                new Promise((function(t) {
                    indexedDB.deleteDatabase("".concat(He, "_").concat(e)).onsuccess = function() {
                        t()
                    }
                }
                ))
            }
            ,
            e.prototype.open = function(e) {
                return void 0 === e && (e = ze),
                Ue(this, void 0, void 0, (function() {
                    var t = this;
                    return Ne(this, (function(r) {
                        return this.db ? [2, Promise.resolve()] : ($e.removeOldDB(),
                        [2, new Promise((function(r, i) {
                            Qe.log("open db");
                            var n = indexedDB.open("".concat(He, "_").concat(e), 4);
                            n.onsuccess = function() {
                                t.db = n.result,
                                Qe.log("db open complete"),
                                r()
                            }
                            ,
                            n.onerror = function(e) {
                                Qe.error("db init error", e, n.error),
                                i(n.error)
                            }
                            ,
                            n.onupgradeneeded = $e.initDB
                        }
                        ))])
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.destroy = function() {
                this.db.close(),
                this.db = null
            }
            ,
            e.prototype.write = function(e) {
                return Ue(this, void 0, void 0, (function() {
                    var t = this;
                    return Ne(this, (function(r) {
                        return Qe.log("db write", e.length),
                        [2, new Promise((function(r, i) {
                            0 === e.length && r(Xe({
                                succeed: [],
                                failed: []
                            }));
                            var n = []
                              , a = []
                              , o = t.transaction("readwrite");
                            e.forEach((function(e) {
                                var t = o.objectStore(qe).put(e);
                                t.onsuccess = function() {
                                    Qe.log("item write succeed", e.keyID, e.index),
                                    n.push(e)
                                }
                                ,
                                t.onerror = function() {
                                    Qe.error("item write failed", t.error, e.keyID, e.index),
                                    a.push(e)
                                }
                            }
                            )),
                            o.oncomplete = function() {
                                Qe.log("db write complete", n.length, a.length),
                                r(Xe({
                                    succeed: n,
                                    failed: a
                                }))
                            }
                            ,
                            o.onerror = function() {
                                Qe.error("db write error", o.error),
                                r(Ze(o.error, {
                                    succeed: n,
                                    failed: a
                                }))
                            }
                        }
                        ))]
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.read = function(e) {
                var t, r, i;
                return Ue(this, void 0, void 0, (function() {
                    var n = this;
                    return Ne(this, (function(a) {
                        return Qe.log("db read", e),
                        null !== (t = (r = this.pendingReadRequests)[i = tt(e)]) && void 0 !== t || (r[i] = new Promise((function(t, r) {
                            var i = !1
                              , a = setTimeout((function() {
                                Qe.error("db read timeout", e),
                                t(Ze("DB_READ_TIMEOUT", void 0)),
                                delete n.pendingReadRequests[tt(e)],
                                i = !0
                            }
                            ), 1500)
                              , o = n.transaction("readonly")
                              , s = []
                              , l = o.objectStore(qe).getAll(e);
                            l.onsuccess = function() {
                                s.push.apply(s, l.result),
                                Qe.log("item read succuss", s.length)
                            }
                            ,
                            o.oncomplete = function() {
                                i || (clearTimeout(a),
                                Qe.log("db read complete", s.length),
                                t(Xe(s)),
                                delete n.pendingReadRequests[tt(e)])
                            }
                            ,
                            o.onerror = function() {
                                i || (clearTimeout(a),
                                Qe.error("db read error", o.error),
                                t(Ze(o.error, void 0)),
                                delete n.pendingReadRequests[tt(e)])
                            }
                        }
                        ))),
                        [2, this.pendingReadRequests[tt(e)]]
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.delete = function(e) {
                return Ue(this, void 0, void 0, (function() {
                    var t = this;
                    return Ne(this, (function(r) {
                        return Qe.log("db delete", e),
                        [2, new Promise((function(r) {
                            var i = t.transaction("readwrite");
                            e.forEach((function(e) {
                                i.objectStore(qe).delete(e)
                            }
                            )),
                            i.oncomplete = function() {
                                Qe.log("db delete complete"),
                                r(Xe(void 0))
                            }
                            ,
                            i.onerror = function() {
                                Qe.error("db delete error", i.error),
                                r(Ze(i.error, void 0))
                            }
                        }
                        ))]
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.getDBSummary = function() {
                return Ue(this, void 0, void 0, (function() {
                    var e = this;
                    return Ne(this, (function(t) {
                        return [2, new Promise((function(t) {
                            var r = []
                              , i = e.readStore().openCursor();
                            i.onsuccess = function(e) {
                                var i = e.target.result;
                                if (i) {
                                    var n = i.value
                                      , a = n.index
                                      , o = n.keyID
                                      , s = n.data;
                                    r.push({
                                        index: a,
                                        keyID: o,
                                        size: s.byteLength
                                    }),
                                    i.continue()
                                } else
                                    t(Xe(r))
                            }
                            ,
                            i.onerror = function() {
                                t(Ze(i.error, void 0))
                            }
                        }
                        ))]
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.transaction = function(e) {
                return this.db.transaction([qe], e)
            }
            ,
            e.prototype.readStore = function() {
                return this.transaction("readonly").objectStore(qe)
            }
            ,
            e
        }();
        function tt(e) {
            return "".concat(e.lower, "-").concat(e.upper)
        }
        for (var rt = function() {
            var e = this;
            this.state = "pending",
            this.promise = new Promise((function(t, r) {
                e.resolve = function(r) {
                    e.state = "fulfilled",
                    t(r)
                }
                ,
                e.reject = function(t) {
                    e.state = "rejected",
                    r(t)
                }
            }
            ))
        }, it = function() {
            function e(e) {
                this.queue = {},
                this.flushCallback = e,
                this.startFlushTimer()
            }
            return Object.defineProperty(e.prototype, "size", {
                get: function() {
                    return Object.keys(this.queue).length
                },
                enumerable: !1,
                configurable: !0
            }),
            Object.defineProperty(e.prototype, "keys", {
                get: function() {
                    return Object.keys(this.queue)
                },
                enumerable: !1,
                configurable: !0
            }),
            e.prototype.destroy = function() {
                this.queue = {},
                this.stopFlushTimer()
            }
            ,
            e.prototype.flush = function() {
                var e = this.queue;
                return this.queue = {},
                this.flushCallback(e),
                e
            }
            ,
            e.prototype.push = function(e) {
                var t = new rt
                  , r = Je.hash(e);
                return this.queue[r] = {
                    data: e,
                    defer: t
                },
                this.checkNeedToFlush(),
                t
            }
            ,
            e.prototype.get = function(e) {
                var t = this;
                return this.keys.filter((function(t) {
                    return Je.isResourceEqual(Je.decode(t), e)
                }
                )).map((function(e) {
                    return t.queue[e].data
                }
                ))
            }
            ,
            e.prototype.delete = function(e) {
                var t = this
                  , r = this.keys.filter((function(t) {
                    return Je.isResourceEqual(Je.decode(t), e)
                }
                ));
                return r.forEach((function(e) {
                    return delete t.queue[e]
                }
                )),
                !!r.length
            }
            ,
            e.prototype.checkNeedToFlush = function() {
                this.size > 10 && this.resetFlushTimer()
            }
            ,
            e.prototype.startFlushTimer = function() {
                var e = this;
                this.flushTimer || (this.flushTimer = setInterval((function() {
                    e.flush(),
                    e.flushTimer = null
                }
                ), 5e3))
            }
            ,
            e.prototype.stopFlushTimer = function(e) {
                var t = this;
                void 0 === e && (e = !1),
                this.flushTimer && (clearInterval(this.flushTimer),
                this.flushTimer = null,
                e && setTimeout((function() {
                    t.flush()
                }
                ), 0))
            }
            ,
            e.prototype.resetFlushTimer = function() {
                this.stopFlushTimer(!0),
                this.startFlushTimer()
            }
            ,
            e
        }(), nt = function() {
            function e(e) {
                var t = this;
                this.onChannelMessage = function(e) {
                    var r;
                    Qe.log("receive message via broadcast channel: ", e.data),
                    null === (r = t.onmessage) || void 0 === r || r.call(t, e.data)
                }
                ,
                this.channel = new BroadcastChannel(e),
                this.channel.onmessage = this.onChannelMessage
            }
            return e.supported = function() {
                return "BroadcastChannel"in self
            }
            ,
            e.prototype.close = function() {
                this.channel.close()
            }
            ,
            e.prototype.send = function(e) {
                return Qe.log("sending message via broadcast channel: ", e),
                this.channel.postMessage(e),
                !0
            }
            ,
            e
        }(), at = function() {
            function e(e) {
                var t = this;
                this.storageEventHandler = function(e) {
                    var r, i, n = e.key, a = e.newValue;
                    if (n === t.channelID && a) {
                        Qe.log("receive message via storage event: ", a);
                        var o = void 0;
                        try {
                            o = JSON.parse(a)
                        } catch (e) {
                            return Qe.error("failed to parse payload: ", e),
                            null === (r = t.onmessage) || void 0 === r ? void 0 : r.call(t, null)
                        }
                        null === (i = t.onmessage) || void 0 === i || i.call(t, o)
                    }
                }
                ,
                this.channelID = e,
                self.addEventListener("storage", this.storageEventHandler)
            }
            return e.supported = function() {
                return !0
            }
            ,
            e.prototype.close = function() {
                self.removeEventListener("storage", this.storageEventHandler)
            }
            ,
            e.prototype.send = function(e) {
                var t;
                Qe.log("sending message via storage event: ", e);
                try {
                    t = JSON.stringify(e)
                } catch (e) {
                    return Qe.error("failed to stringify payload: ", e),
                    !1
                }
                return $e.setLocalItem(this.channelID, t),
                $e.delLocalItem(this.channelID),
                !0
            }
            ,
            e
        }(), ot = [nt, at], st = function() {
            function e(e, t) {
                var r = this;
                this.onChannelMessage = function(e) {
                    var t;
                    null === (t = r.onmessage) || void 0 === t || t.call(r, e)
                }
                ;
                var i = ot.find((function(e) {
                    return e.supported()
                }
                ));
                if (!i)
                    throw new Error("No supported message channel found");
                this.onmessage = t,
                this.channel = new i("".concat("TP_RESOURCE_MESSAGE", "_").concat(e)),
                this.channel.onmessage = this.onChannelMessage
            }
            return e.prototype.send = function(e) {
                this.channel.send(e)
            }
            ,
            e
        }(), lt = function() {
            function e(e, t) {
                var r = this;
                this.lockedKeyID = {},
                this.synced = !1,
                this.handleMessageFromOtherTabs = function(e) {
                    var t, i;
                    if (e) {
                        var n = e
                          , a = n.opCode
                          , o = n.payload
                          , s = n.ts;
                        switch (a) {
                        case Ge.ADD_KEYID:
                            var l = o.keyID
                              , c = o.data;
                            r.table[l] = c;
                            break;
                        case Ge.UPDATE:
                            o.forEach((function(e) {
                                var t, i, n = e.keyID, a = e.index, o = e.size;
                                r.table[n] ? (null !== (t = (i = r.table[n].segments)[a]) && void 0 !== t || (i[a] = r.createSegment(o)),
                                r.table[n].segments[a].lastAccessed = s,
                                r.table[n].segments[a].lastModified = s) : Qe.warn("update segment from other tab but keyID not found", n)
                            }
                            ));
                            break;
                        case Ge.REMOVE:
                            o.forEach((function(e) {
                                var t = e.keyID
                                  , i = e.index;
                                Je.notNullable(i) ? r.deleteSegmentRecord(t, i) : delete r.table[t]
                            }
                            ));
                            break;
                        case Ge.SET_METADATA:
                            l = o.keyID;
                            var h = o.metadata;
                            r.table[l] ? r.table[l].metadata = h : Qe.warn("set metadata from other tab but keyID not found", l);
                            break;
                        case Ge.LOCK:
                            l = o.keyID;
                            null !== (t = (i = r.lockedKeyID)[l]) && void 0 !== t || (i[l] = 0),
                            r.lockedKeyID[l] += 1;
                            break;
                        case Ge.UNLOCK:
                            l = o.keyID;
                            r.lockedKeyID[l] -= 1,
                            0 === r.lockedKeyID[l] && delete r.lockedKeyID[l];
                            break;
                        case Ge.INIT:
                            r.synced && r.sendMessage(Ge.SYNC, {
                                locked: r.lockedKeyID,
                                table: r.table
                            });
                            break;
                        case Ge.SYNC:
                            var u = o.locked
                              , d = o.table;
                            r.lockedKeyID = u,
                            !r.synced && d && (Qe.log("tracker synced from message", d),
                            r.table = d,
                            r.synced = !0)
                        }
                    }
                }
                ,
                this.onPageVisibilityChange = function() {
                    "hidden" === document.visibilityState && r.commit()
                }
                ,
                this.tableKey = "".concat(Ve, "_").concat(t),
                this.dbSizeKey = "".concat(je, "_").concat(t),
                this.db = e,
                this.messenger = new st(t,this.handleMessageFromOtherTabs),
                this.sendMessage(Ge.INIT, void 0),
                this.table = this.getAvailableResources(),
                document.addEventListener("visibilitychange", this.onPageVisibilityChange)
            }
            return e.clear = function(e) {
                void 0 === e && (e = ze);
                try {
                    localStorage.removeItem("".concat(Ve, "_").concat(e))
                } catch (e) {}
            }
            ,
            e.prototype.destroy = function() {
                document.removeEventListener("visibilitychange", this.onPageVisibilityChange),
                this.commit(),
                this.table = {}
            }
            ,
            e.prototype.getAvailableResources = function() {
                if (this.table)
                    return this.table;
                try {
                    var e = JSON.parse($e.getLocalItem(this.tableKey));
                    return e || (this.initTable(),
                    {})
                } catch (e) {
                    return {}
                }
            }
            ,
            e.prototype.getSize = function() {
                var e = $e.getLocalItem(this.dbSizeKey);
                try {
                    return JSON.parse(e) || 0
                } catch (e) {
                    return 0
                }
            }
            ,
            e.prototype.lock = function(e) {
                var t, r;
                null !== (t = (r = this.lockedKeyID)[e]) && void 0 !== t || (r[e] = 0),
                this.lockedKeyID[e] += 1,
                this.sendMessage(Ge.LOCK, {
                    keyID: e
                })
            }
            ,
            e.prototype.unlock = function(e) {
                this.lockedKeyID[e] -= 1,
                (0 === this.lockedKeyID[e] || isNaN(this.lockedKeyID[e])) && delete this.lockedKeyID[e],
                this.sendMessage(Ge.UNLOCK, {
                    keyID: e
                })
            }
            ,
            e.prototype.getLockedKeyIDs = function() {
                return Object.keys(this.lockedKeyID)
            }
            ,
            e.prototype.updateSize = function(e, t) {
                void 0 === t && (t = "add");
                var r, i = this.getSize();
                switch (t) {
                case "add":
                    r = i + e;
                    break;
                case "subtract":
                    r = i - e;
                    break;
                case "reset":
                    r = e;
                    break;
                default:
                    r = i
                }
                Qe.log("tracker update size ".concat(i, "->").concat(r)),
                this.saveToLocalStorage(this.dbSizeKey, r)
            }
            ,
            e.prototype.get = function(e) {
                return this.table[e]
            }
            ,
            e.prototype.has = function(e) {
                var t = e
                  , r = t.keyID
                  , i = t.index;
                return Je.notNullable(r) && Je.notNullable(i) ? this.table[r] && !!this.table[r].segments[i] : !!Je.notNullable(r) && !!this.table[r]
            }
            ,
            e.prototype.add = function(e) {
                var t = this
                  , r = 0
                  , i = [];
                e.forEach((function(e) {
                    var n = e
                      , a = n.keyID
                      , o = n.index;
                    Je.validate(e) || Qe.warn("tracker adding invalid resources", e, e);
                    var s = Date.now();
                    if (t.table[a])
                        t.table[a].lastModified = s,
                        t.table[a].lastAccessed = s;
                    else {
                        var l = t.createRecord();
                        t.table[a] = l,
                        t.sendMessage(Ge.ADD_KEYID, {
                            keyID: a,
                            data: l
                        })
                    }
                    t.table[a].segments[o] = t.createSegment(e.data.byteLength),
                    i.push({
                        keyID: a,
                        index: o,
                        size: e.data.byteLength
                    }),
                    r += e.data.byteLength
                }
                )),
                this.sendMessage(Ge.UPDATE, i),
                this.updateSize(r, "add")
            }
            ,
            e.prototype.remove = function(e) {
                var t = this;
                if (0 !== e.length) {
                    var r = 0
                      , i = [];
                    e.forEach((function(e) {
                        var n = e
                          , a = n.keyID
                          , o = n.index
                          , s = t.table;
                        if (a && s[a])
                            if (Je.notNullable(o)) {
                                var l = s[a].segments[o].size;
                                r += l,
                                t.deleteSegmentRecord(a, o),
                                i.push({
                                    keyID: a,
                                    index: o
                                })
                            } else
                                Object.keys(s[a].segments).forEach((function(e) {
                                    var t = s[a].segments[+e].size;
                                    r += t
                                }
                                )),
                                delete s[a],
                                i.push({
                                    keyID: a
                                })
                    }
                    )),
                    this.sendMessage(Ge.REMOVE, i),
                    this.updateSize(r, "subtract")
                }
            }
            ,
            e.prototype.recordAccess = function(e) {
                var t = e
                  , r = t.keyID
                  , i = t.index
                  , n = this.table;
                r && n[r] && (n[r].lastAccessed = Date.now(),
                n[r].segments[i] && (n[r].segments[i].lastAccessed = Date.now()),
                this.sendMessage(Ge.READ, {
                    keyID: r,
                    index: i
                }))
            }
            ,
            e.prototype.setMetadata = function(e, t) {
                if (!this.table[e]) {
                    var r = this.createRecord();
                    this.table[e] = r,
                    this.sendMessage(Ge.ADD_KEYID, {
                        keyID: e,
                        data: r
                    })
                }
                return this.table[e].metadata = t,
                this.sendMessage(Ge.SET_METADATA, {
                    keyID: e,
                    metadata: t
                }),
                !0
            }
            ,
            e.prototype.initTableFromDB = function() {
                return Ue(this, void 0, void 0, (function() {
                    var e, t, r, i, n, a, o = this;
                    return Ne(this, (function(s) {
                        switch (s.label) {
                        case 0:
                            return [4, this.db.getDBSummary()];
                        case 1:
                            if (e = s.sent(),
                            t = e.status,
                            r = e.data,
                            this.synced)
                                return [2, []];
                            if ("ok" === t)
                                return i = new Set,
                                n = 0,
                                a = [],
                                r.forEach((function(e) {
                                    var t, r = e.size, s = e.index, l = e.keyID;
                                    i.add("".concat(l, "-").concat(s)),
                                    (null === (t = o.table[l]) || void 0 === t ? void 0 : t.segments[s]) ? n += r : a.push({
                                        keyID: l,
                                        index: s
                                    })
                                }
                                )),
                                Object.keys(this.table).forEach((function(e) {
                                    Object.keys(o.table[e].segments).forEach((function(t) {
                                        i.has("".concat(e, "-").concat(t)) || delete o.table[e].segments[+t]
                                    }
                                    )),
                                    0 === Object.keys(o.table[e].segments).length && delete o.table[e]
                                }
                                )),
                                Qe.log("tracker synced from db"),
                                this.synced = !0,
                                this.updateSize(n, "reset"),
                                [2, a];
                            throw new Error("Failed to init table from DB")
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.initTable = function() {
                try {
                    $e.setLocalItem(this.tableKey, JSON.stringify({}))
                } catch (e) {}
            }
            ,
            e.prototype.commit = function() {
                this.saveToLocalStorage(this.tableKey, this.table)
            }
            ,
            e.prototype.saveToLocalStorage = function(e, t) {
                try {
                    $e.setLocalItem(e, JSON.stringify(t))
                } catch (e) {}
            }
            ,
            e.prototype.deleteSegmentRecord = function(e, t) {
                this.table[e] ? (delete this.table[e].segments[t],
                0 === Object.keys(this.table[e].segments).length && delete this.table[e]) : Qe.warn("delete segment ".concat(t, " of ").concat(e, " but keyID record not found"))
            }
            ,
            e.prototype.createRecord = function() {
                var e = Date.now();
                return {
                    lastAccessed: e,
                    lastModified: e,
                    segments: {},
                    metadata: ""
                }
            }
            ,
            e.prototype.createSegment = function(e) {
                var t = Date.now();
                return {
                    size: e,
                    lastAccessed: t,
                    lastModified: t
                }
            }
            ,
            e.prototype.sendMessage = function(e, t) {
                this.messenger.send({
                    opCode: e,
                    payload: t,
                    ts: Date.now()
                })
            }
            ,
            e
        }(), ct = function() {
            function e(e) {
                1 == +$e.getLocalItem("TP_RESOURCE_CACHE_LOG_ENABLED") && Object.keys(Ye).forEach((function(e) {
                    Ye[e] = console[e].bind(console, "[ResourceCache]")
                }
                )),
                this.domain = e,
                this.writeTaskQueue = new it(this.onWriteQueueFlush.bind(this)),
                this.db = new et,
                this.tracker = new lt(this.db,e),
                Qe.log("create instance")
            }
            return e.getInstance = function(t) {
                return void 0 === t && (t = ze),
                e.instances[t] || (e.instances[t] = new e(t)),
                e.instances[t]
            }
            ,
            e.isSupported = function() {
                try {
                    return void 0 !== typeof indexedDB && void 0 !== typeof localStorage
                } catch (e) {
                    return !1
                }
            }
            ,
            e.clear = function() {
                return Ue(this, void 0, void 0, (function() {
                    return Ne(this, (function(e) {
                        switch (e.label) {
                        case 0:
                            return e.trys.push([0, 2, , 3]),
                            [4, et.clear()];
                        case 1:
                            return e.sent(),
                            lt.clear(),
                            [2, !0];
                        case 2:
                            return e.sent(),
                            [2, !1];
                        case 3:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.getQuota = function(e) {
                void 0 === e && (e = ze);
                var t = this.getInstance(e).tracker.getSize();
                return {
                    usage: t,
                    quota: 5e8 - t
                }
            }
            ,
            e.init = function(t) {
                return void 0 === t && (t = ze),
                Ue(this, void 0, void 0, (function() {
                    var r, i;
                    return Ne(this, (function(n) {
                        switch (n.label) {
                        case 0:
                            return [4, (r = e.getInstance(t)).db.open(t)];
                        case 1:
                            return n.sent(),
                            [4, r.tracker.initTableFromDB()];
                        case 2:
                            return i = n.sent(),
                            i.length > 0 ? [4, r.delete(i)] : [3, 4];
                        case 3:
                            n.sent(),
                            n.label = 4;
                        case 4:
                            return Qe.log("db initialization completed"),
                            [2, r]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.destroy = function() {
                this.db.destroy(),
                this.writeTaskQueue.destroy(),
                this.tracker.destroy(),
                this.db = null,
                this.writeTaskQueue = null,
                this.tracker = null,
                delete e.instances[this.domain],
                Qe.log("destroyed")
            }
            ,
            e.prototype.getAvailable = function() {
                return this.tracker.getAvailableResources()
            }
            ,
            e.prototype.has = function(e) {
                return this.tracker.has(e)
            }
            ,
            e.prototype.setCurrentPlayingKeyID = function(e) {
                Qe.log("updating current playing key id", e),
                this.tracker.lock(e)
            }
            ,
            e.prototype.removeCurrentPlayingKeyID = function(e) {
                Qe.log("removing current playing key id", e),
                this.tracker.unlock(e)
            }
            ,
            e.prototype.getCurrentPlayingKeyIDs = function() {
                return this.tracker.getLockedKeyIDs()
            }
            ,
            e.prototype.write = function(t) {
                var r = this
                  , i = Array.isArray(t) ? t : [t]
                  , n = e.getQuota().quota;
                if (!(i.reduce((function(e, t) {
                    return e + t.data.byteLength
                }
                ), 0) < n))
                    return Ze("QUOTA_EXCEEDED");
                var a = i.map((function(e) {
                    return Je.validate(e) ? r.writeTaskQueue.push(e).promise : Promise.resolve(Ze("INVALID_RESOURCE"))
                }
                ));
                return this.tracker.add(i),
                Xe(a)
            }
            ,
            e.prototype.setMetadata = function(e, t) {
                return Qe.log("setMetadata() keyID: ", e),
                this.tracker.setMetadata(e, t)
            }
            ,
            e.prototype.getMetadata = function(e) {
                return this.tracker.get(e)
            }
            ,
            e.prototype.read = function(e) {
                var t;
                return Ue(this, void 0, void 0, (function() {
                    var r, i, n, a, o, s, l = this;
                    return Ne(this, (function(c) {
                        switch (c.label) {
                        case 0:
                            if (r = $e.computeKeyConstrain(e),
                            i = Ze("INVALID_RESOURCE_IDENTIFIER"),
                            !r)
                                return [2, Promise.resolve(i)];
                            n = [],
                            Je.normalizeRangeIdentifier(e).forEach((function(e) {
                                l.tracker.recordAccess(e);
                                var t = l.writeTaskQueue.get(e);
                                t && n.push.apply(n, t)
                            }
                            )),
                            c.label = 1;
                        case 1:
                            return c.trys.push([1, 3, , 4]),
                            [4, this.db.read(r)];
                        case 2:
                            return "ok" === (a = c.sent()).status ? n.push.apply(n, a.data) : Qe.warn("read() failed: ", a.reason),
                            [3, 4];
                        case 3:
                            return o = c.sent(),
                            Qe.warn("read() error caught: ", o),
                            s = Ze(null !== (t = o.message) && void 0 !== t ? t : "UNKNOWN"),
                            [2, Promise.resolve(s)];
                        case 4:
                            return Qe.log("read() results: ", n.length),
                            [2, Promise.resolve(Xe(n))]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.delete = function(e) {
                var t;
                return Ue(this, void 0, void 0, (function() {
                    var r, i, n, a, o = this;
                    return Ne(this, (function(s) {
                        switch (s.label) {
                        case 0:
                            r = [],
                            i = (Array.isArray(e) ? e : [e]).map((function(e) {
                                var t = $e.computeKeyConstrain(e);
                                return Je.normalizeRangeIdentifier(e).forEach((function(e) {
                                    r.push(e),
                                    o.writeTaskQueue.delete(e)
                                }
                                )),
                                t
                            }
                            )),
                            s.label = 1;
                        case 1:
                            return s.trys.push([1, 3, , 4]),
                            [4, this.db.delete(i)];
                        case 2:
                            return "ok" === (n = s.sent()).status ? (this.tracker.remove(r),
                            [2, Promise.resolve(Xe())]) : (Qe.warn("delete() failed: ", n.reason),
                            [2, Promise.resolve(Ze(n.reason))]);
                        case 3:
                            return a = s.sent(),
                            Qe.warn("delete() error caught: ", a),
                            [2, Promise.resolve(Ze(null !== (t = a.message) && void 0 !== t ? t : "UNKNOWN"))];
                        case 4:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.onWriteQueueFlush = function(e) {
                var t = Object.keys(e).map((function(t) {
                    return e[t].data
                }
                ));
                t.length && this.db.write(t).then(this.onDBWriteComplete.bind(this)).then((function(t) {
                    var r = t.succeed
                      , i = t.failed;
                    r.forEach((function(t) {
                        e[Je.hash(t)].defer.resolve(Xe())
                    }
                    )),
                    i.forEach((function(t) {
                        e[Je.hash(t)].defer.resolve(Ze(void 0))
                    }
                    )),
                    Qe.log("queue flushed: ", r.length, i.length)
                }
                )).catch((function(t) {
                    Qe.warn("queue flushing error caught: ", t),
                    t.failed && t.failed.forEach((function(r) {
                        e[Je.hash(r)].defer.resolve(Ze(t.reason))
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.onDBWriteComplete = function(e) {
                var t = this
                  , r = e.status
                  , i = e.data;
                if ("err" === r) {
                    Qe.warn("write() failed: ", e.reason);
                    var n = i.succeed
                      , a = i.failed;
                    return this.tracker.remove(n),
                    n.forEach((function(e) {
                        t.write(e)
                    }
                    )),
                    this.tracker.remove(a),
                    Promise.reject({
                        reason: e.reason,
                        failed: a
                    })
                }
                return this.tracker.remove(i.failed),
                Promise.resolve({
                    succeed: i.succeed,
                    failed: i.failed
                })
            }
            ,
            e.instances = {},
            e
        }(), ht = function() {
            function e() {
                this.totalCacheSize = 0,
                this.totalLocalSize = 0,
                this.maxLocalSize = 0,
                this.tenSecondTick = 0,
                this.isDeletingDB = !1,
                this.isInitingDB = !1,
                this.mediaFileMap = new Map,
                this.releaseMemoryTimer = self.setInterval(this.onCacheManage.bind(this), 1e3)
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.getDBCache = function() {
                return this.dbCache
            }
            ,
            e.prototype.destroy = function() {
                this.releaseMemoryTimer && (clearInterval(this.releaseMemoryTimer),
                this.releaseMemoryTimer = void 0),
                this.mediaFileMap && (this.mediaFileMap.clear(),
                this.mediaFileMap = null)
            }
            ,
            e.prototype.stopP2P = function() {
                this.lastReportTick = 0,
                Me.getInstance().destroy()
            }
            ,
            e.prototype.initDBCache = function() {
                return D(this, void 0, void 0, (function() {
                    var t, r, i, n, a = this;
                    return k(this, (function(o) {
                        switch (o.label) {
                        case 0:
                            if (!ct.isSupported() || !("race"in Promise) || J.playerInfo.device !== G.PC)
                                return re.getInstance().initDB = j.NotSupported,
                                [2];
                            if (void 0 !== e.dbCache || this.isInitingDB)
                                return [2];
                            this.isInitingDB = !0,
                            o.label = 1;
                        case 1:
                            return o.trys.push([1, 3, , 4]),
                            t = e,
                            [4, ct.init()];
                        case 2:
                            return t.dbCache = o.sent(),
                            [3, 4];
                        case 3:
                            return r = o.sent(),
                            re.getInstance().initDB = j.OpenFailed,
                            re.getInstance().initDBFailReason = null == r ? void 0 : r.message,
                            Ar.info("CacheManager", "", "init dbCache failed " + (null == r ? void 0 : r.message) + "."),
                            this.isInitingDB = !1,
                            [2];
                        case 4:
                            return i = e.dbCache.getAvailable(),
                            n = [],
                            Object.keys(i).forEach((function(t) {
                                var r, o, s = i[t].segments;
                                if (n.push(t),
                                a.mediaFileMap.has(t))
                                    a.updateIsInDB(t, Object.keys(s).map(Number)),
                                    a.getMediaFile(t).hasTorrent() && e.dbCache.setMetadata(t, a.getMediaFile(t).getMetadata());
                                else if (i[t].metadata[2]) {
                                    var l = i[t].metadata[0]
                                      , c = i[t].metadata[1]
                                      , h = [];
                                    try {
                                        for (var u = C(i[t].metadata[2]), d = u.next(); !d.done; d = u.next()) {
                                            var f = d.value
                                              , p = {
                                                sn: f[0],
                                                fileSize: f[1],
                                                tsType: f[2]
                                            };
                                            h.push(p)
                                        }
                                    } catch (e) {
                                        r = {
                                            error: e
                                        }
                                    } finally {
                                        try {
                                            d && !d.done && (o = u.return) && o.call(u)
                                        } finally {
                                            if (r)
                                                throw r.error
                                        }
                                    }
                                    de.getInstance().setIndexAdapter(t, h, B.Vod);
                                    var g = {
                                        taskType: B.Vod,
                                        useP2P: !0,
                                        isPlayTask: !1
                                    };
                                    a.setMediaFile(t, h, g),
                                    a.updateIsInDB(t, Object.keys(s).map(Number)),
                                    $t.getInstance().createPeerContainer(t),
                                    le.getItem(t).start(H.BackEnd);
                                    var v = {
                                        keyID: t,
                                        taskType: B.Vod,
                                        useP2P: !0
                                    };
                                    le.getItem(t).setTaskInfo(v),
                                    a.getMediaFile(t).setFileIDByMetadata(l, c)
                                }
                            }
                            )),
                            re.getInstance().initDB = j.Succeed,
                            this.isInitingDB = !1,
                            Ar.info("CacheManager", "", "init dbCache success."),
                            Ar.info("CacheManager", "", "DB has keyIDs: ", n.length ? n : "none"),
                            [2]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.canWriteDB = function() {
                return !!e.dbCache && (!(J.accessDBErrorTimes >= Lr.maxAccessDBCacheErrorTimes) && !(!Lr.canWriteWhileDeletingDB && this.isDeletingDB))
            }
            ,
            e.prototype.getTaskType = function(e) {
                return this.mediaFileMap.get(e).getTaskType()
            }
            ,
            e.prototype.setMediaFile = function(e, t, r) {
                Ar.info("CacheManager", "", "setMediaFile " + e + " [" + t[0].sn + "-" + t[t.length - 1].sn + "]");
                var i = this.mediaFileMap.has(e) ? this.getMediaFile(e) : null;
                (null == i ? void 0 : i.allowP2P) && r.useP2P ? (i.setTsInfo(t),
                i.isPlayTask = r.isPlayTask) : (i = new Be(t,e,r),
                this.mediaFileMap.set(e, i))
            }
            ,
            e.prototype.updateMediaFile = function(e, t) {
                Ar.info("CacheManager", "", "UpdateMediaFile " + e + " [" + t[0].sn + "-" + t[t.length - 1].sn + "]");
                var r = this.getMediaFile(e);
                r && r.updateTsInfo(t)
            }
            ,
            e.prototype.isP2POverMemory = function() {
                return this.totalCacheSize > Lr.maxCacheSize * (1 + Lr.p2pDownloadMemoryRatio / 100)
            }
            ,
            e.prototype.isHTTPOverMemory = function() {
                return this.totalCacheSize > Lr.maxCacheSize * (1 + Lr.httpDownloadMemoryRatio / 100)
            }
            ,
            e.prototype.hasMediaFile = function(e) {
                return this.mediaFileMap.has(e)
            }
            ,
            e.prototype.getTsBitmap = function(e, t, r) {
                var i, n, a = this.getMediaFile(e);
                if (null === a)
                    return [];
                var o = [];
                try {
                    for (var s = C(de.getInstance().getIndexAdapter(e).getIterator(t)), l = s.next(); !l.done; l = s.next()) {
                        var c = l.value;
                        if (o.length >= r)
                            break;
                        if (null !== c.p2p && void 0 !== c.p2p) {
                            var h = a.getTsBitmap(c.cache);
                            o.push(h)
                        } else
                            null === c.p2p && o.push(null)
                    }
                } catch (e) {
                    i = {
                        error: e
                    }
                } finally {
                    try {
                        l && !l.done && (n = s.return) && n.call(s)
                    } finally {
                        if (i)
                            throw i.error
                    }
                }
                return o
            }
            ,
            e.prototype.getFileSize = function(e, t, r) {
                var i, n, a = this.getMediaFile(e);
                if (null === a)
                    return [];
                var o = [];
                try {
                    for (var s = C(de.getInstance().getIndexAdapter(e).getIterator(t)), l = s.next(); !l.done; l = s.next()) {
                        var c = l.value;
                        if (o.length >= r)
                            break;
                        if (null !== c.p2p && void 0 !== c.p2p) {
                            var h = a.getFileSize(c.cache);
                            o.push(h)
                        } else
                            null === c.p2p && o.push(0)
                    }
                } catch (e) {
                    i = {
                        error: e
                    }
                } finally {
                    try {
                        l && !l.done && (n = s.return) && n.call(s)
                    } finally {
                        if (i)
                            throw i.error
                    }
                }
                return o
            }
            ,
            e.prototype.checkFileSize = function(e, t, r, i) {
                var n, a, o = this.getMediaFile(e);
                if (null !== o) {
                    var s = de.getInstance().getIndexAdapter(e)
                      , l = 0;
                    try {
                        for (var c = C(s.getIterator(t)), h = c.next(); !h.done; h = c.next()) {
                            var u = h.value;
                            if (l >= r || l >= i.length)
                                break;
                            void 0 !== u.p2p && (o.checkFileSize(i[l], u.cache),
                            l += 1)
                        }
                    } catch (e) {
                        n = {
                            error: e
                        }
                    } finally {
                        try {
                            h && !h.done && (a = c.return) && a.call(c)
                        } finally {
                            if (n)
                                throw n.error
                        }
                    }
                }
            }
            ,
            e.prototype.readBlocksData = function(e, t, r, i) {
                var n = this.getMediaFile(e);
                return null === n ? null : n.readBlocksData(t.cache, r, i)
            }
            ,
            e.prototype.readTsData = function(e, t) {
                var r = this.getMediaFile(e);
                return null === r ? null : r.readTsData(t.cache)
            }
            ,
            e.prototype.readPieceData = function(e, t, r, i) {
                var n = this.getMediaFile(e);
                return null === n ? null : n.readPiecesData(t.cache, r, i, 1)
            }
            ,
            e.prototype.readPiecesData = function(e, t, r, i, n) {
                var a = this.getMediaFile(e);
                return null === a ? null : a.readPiecesData(t.cache, r, i, n)
            }
            ,
            e.prototype.writeTsData = function(e, t, r, i, n) {
                void 0 === i && (i = 0),
                void 0 === n && (n = U.HTTP);
                var a = this.getMediaFile(e);
                a && a.writeData(t.cache, i, r, n)
            }
            ,
            e.prototype.writePieceData = function(e, t, r, i, n, a) {
                var o = this.getMediaFile(e);
                if (null !== o) {
                    var s = r * J.BLOCK_SIZE + i * J.PIECE_SIZE;
                    o.writeData(t.cache, s, n, a)
                }
            }
            ,
            e.prototype.isTsFinished = function(e, t, r) {
                var i = this.getMediaFile(e);
                return !!i && i.isTsFinished(t.cache, r)
            }
            ,
            e.prototype.constructDownloadPieceInfoForP2P = function(e, t, r) {
                var i = this.getMediaFile(e);
                return i ? i.constructDownloadPieceInfoForP2P(t, r) : null
            }
            ,
            e.prototype.hasTorrent = function(e) {
                var t = this.getMediaFile(e);
                return !!t && t.hasTorrent()
            }
            ,
            e.prototype.setFileID = function(t, r, i) {
                var n, a = this.getMediaFile(t);
                a && (a.setFileID(r, i),
                null === (n = e.dbCache) || void 0 === n || n.setMetadata(t, a.getMetadata()))
            }
            ,
            e.prototype.getFileID = function(e, t) {
                var r = this.getMediaFile(e);
                return r ? r.getFileID(t.p2p) : null
            }
            ,
            e.prototype.getUnloadIndex = function(e, t, r, i) {
                var n = this.getMediaFile(e);
                return n ? n.getUnloadIndex(t, r, i) : null
            }
            ,
            e.prototype.getFirstRange = function(e, t, r) {
                var i = this.getMediaFile(e);
                return i ? i.getFirstRange(t.cache, r) : null
            }
            ,
            e.prototype.getUrl = function(e, t) {
                var r = this.getMediaFile(e);
                return r ? r.getUrl(t.cache) : null
            }
            ,
            e.prototype.setTsFileSize = function(e, t, r) {
                var i = this.getMediaFile(e);
                i && i.setTsFileSize(t.cache, r)
            }
            ,
            e.prototype.setTsChoosed = function(e, t, r, i) {
                var n = this.getMediaFile(e);
                null !== n && null !== t && n.setTsChoosed(t.cache, r, i)
            }
            ,
            e.prototype.setPieceChoosed = function(e, t, r, i, n, a, o) {
                var s = this.getMediaFile(e);
                null !== s && s.setPieceChoosed(t.cache, r, i, n, a, o)
            }
            ,
            e.prototype.getChecksum = function(e, t, r) {
                var i = this.getMediaFile(e);
                return null === i ? 0 : i.getChecksum(t.cache, r)
            }
            ,
            e.prototype.calChecksum = function(e, t, r) {
                var i = this.getMediaFile(e);
                return null === i ? 0 : i.calChecksum(t.cache, r)
            }
            ,
            e.prototype.setChecksum = function(e, t, r, i) {
                var n = this.getMediaFile(e);
                null !== n && n.setChecksum(t.cache, r, i)
            }
            ,
            e.prototype.getAllowP2P = function(e, t) {
                var r = this.getMediaFile(e);
                return null !== r && r.getAllowP2P(t.cache)
            }
            ,
            e.prototype.resetBlockData = function(e, t, r) {
                var i = this.getMediaFile(e);
                null !== i && i.resetBlockData(t.cache, r)
            }
            ,
            e.prototype.getPlayableTime = function(e, t, r) {
                var i = this.getMediaFile(e);
                return i ? i.getPlayableTime(t, r) : 0
            }
            ,
            e.prototype.getPlayableTimeByPlayPoint = function(e, t) {
                var r = this.getMediaFile(e);
                return r ? r.getPlayableTimeByPlayPoint(t) : 0
            }
            ,
            e.prototype.getBitrateByIndex = function(e, t) {
                var r = this.getMediaFile(e);
                return r ? r.getBitrate(t.cache) : 0
            }
            ,
            e.prototype.getLiveExpiredTs = function(e, t) {
                var r = this.getMediaFile(e);
                return r ? r.getLiveExpiredTs(t) : null
            }
            ,
            e.prototype.isDownloadFinishAfterIndex = function(e, t) {
                var r = this.getMediaFile(e);
                return !!r && r.isDownloadFinishAfterIndex(t)
            }
            ,
            e.prototype.generateFileID = function(t) {
                var r, i = this.getMediaFile(t);
                i && (i.generateFileID(),
                null === (r = e.dbCache) || void 0 === r || r.setMetadata(t, i.getMetadata()))
            }
            ,
            e.prototype.isPlayTask = function(e) {
                var t = this.getMediaFile(e);
                return !!t && t.isPlayTask
            }
            ,
            e.prototype.getFileSeq = function(e) {
                var t = this.getMediaFile(e);
                return t ? t.seq : null
            }
            ,
            e.prototype.onCacheManage = function() {
                var t;
                this.onCacheCaculate(),
                t = e.dbCache ? "TotalCacheSize: " + (this.totalCacheSize / 1024 / 1024).toFixed(2) + " MB, MaxCacheSize: " + (Lr.maxCacheSize / 1024 / 1024).toFixed(2) + " MB, TotalLocalSize: " + (this.totalLocalSize / 1024 / 1024).toFixed(2) + " MB, MaxLocalSize: " + (this.maxLocalSize / 1024 / 1024).toFixed(2) + " MB." : "TotalCacheSize: " + (this.totalCacheSize / 1024 / 1024).toFixed(2) + " MB, MaxCacheSize: " + (Lr.maxCacheSize / 1024 / 1024).toFixed(2) + " MB.",
                this.tenSecondTick % 10 == 0 ? Ar.info("CacheManager", "", t) : Ar.debug("CacheManager", "", t),
                e.dbCache && this.tenSecondTick % 10 == 0 && this.onUpdateIsInDB(),
                this.tenSecondTick += 1,
                this.onReleaseMemory(),
                this.reportResource2Server()
            }
            ,
            e.prototype.reportResource2Server = function(e, t) {
                if (void 0 === e && (e = !1),
                void 0 === t && (t = !1),
                Lr.useP2P) {
                    var r = Tr.getTick();
                    (0 === this.lastReportTick || r - this.lastReportTick >= 1e3 * Lr.reportInterval || !0 === e) && (Me.getInstance().reportResource2Server(this.mediaFileMap, t),
                    this.lastReportTick = r)
                }
            }
            ,
            e.prototype.releaseDBCache = function(t, r) {
                var i;
                return D(this, void 0, void 0, (function() {
                    var n, a, o, s, l, c, h, u, d, f, p, g, v, y, m, T, S, I, P, b, E, D, L;
                    return k(this, (function(k) {
                        switch (k.label) {
                        case 0:
                            if (this.isDeletingDB)
                                return [2, !1];
                            for (this.isDeletingDB = !0,
                            n = e.dbCache.getAvailable(),
                            a = Oe.getInstance().getTask(t).getReadSn(),
                            o = de.getInstance().getIndexAdapter(t),
                            s = [],
                            l = [],
                            c = [],
                            h = 0,
                            Object.keys(n).forEach((function(e) {
                                s.push([e, n[e].lastAccessed])
                            }
                            )),
                            s.sort((function(e, t) {
                                return e[1] - t[1]
                            }
                            )),
                            u = function(e) {
                                var r, i;
                                l.push(s[e][0]);
                                var u = []
                                  , d = n[s[e][0]].segments;
                                Object.keys(d).forEach((function(r) {
                                    var i = parseInt(r, 10);
                                    (s[e][0] !== t || o.p2pToIndex(i).sn < a) && u.push([s[e][0], i, d[r].lastAccessed, d[r].size])
                                }
                                )),
                                u.sort((function(e, t) {
                                    return e[2] - t[2]
                                }
                                ));
                                try {
                                    for (var f = (r = void 0,
                                    C(u)), p = f.next(); !p.done; p = f.next()) {
                                        var g = p.value;
                                        if (h >= Lr.releaseDBSize)
                                            break;
                                        c.push({
                                            keyID: g[0],
                                            index: g[1]
                                        }),
                                        h += g[3]
                                    }
                                } catch (e) {
                                    r = {
                                        error: e
                                    }
                                } finally {
                                    try {
                                        p && !p.done && (i = f.return) && i.call(f)
                                    } finally {
                                        if (r)
                                            throw r.error
                                    }
                                }
                            }
                            ,
                            d = 0; d < s.length && h < Lr.releaseDBSize; ++d)
                                u(d);
                            return 0 === c.length ? [3, 2] : [4, e.dbCache.delete(c)];
                        case 1:
                            if (f = k.sent().status,
                            this.isDeletingDB = !1,
                            "ok" !== f)
                                return J.accessDBErrorTimes += 1,
                                Ar.warn("CacheManager", "", "Delete DB failed: " + c + "."),
                                [2, !1];
                            p = ct.getQuota().quota,
                            Ar.info("CacheManager", "", "Delete DB data to quota: " + p + ".");
                            try {
                                for (g = C(c),
                                v = g.next(); !v.done; v = g.next())
                                    y = v.value,
                                    m = this.getMediaFile(y.keyID),
                                    T = de.getInstance().getIndexAdapter(y.keyID).p2pToIndex(y.index).cache,
                                    m.getTSCache(T) && (m.getTSCache(T).isInDB = !1)
                            } catch (e) {
                                b = {
                                    error: e
                                }
                            } finally {
                                try {
                                    v && !v.done && (E = g.return) && E.call(g)
                                } finally {
                                    if (b)
                                        throw b.error
                                }
                            }
                            try {
                                for (S = C(l),
                                I = S.next(); !I.done; I = S.next())
                                    P = I.value,
                                    !e.dbCache.getAvailable()[P] && (null === (i = this.getMediaFile(P)) || void 0 === i ? void 0 : i.getTotalCacheSize()) <= 0 && this.deleteMediaFile(P)
                            } catch (e) {
                                D = {
                                    error: e
                                }
                            } finally {
                                try {
                                    I && !I.done && (L = S.return) && L.call(S)
                                } finally {
                                    if (D)
                                        throw D.error
                                }
                            }
                            return this.reportResource2Server(!0),
                            p < r ? [2, !1] : [2, !0];
                        case 2:
                            return this.isDeletingDB = !1,
                            [2, !1]
                        }
                    }
                    ))
                }
                ))
            }
            ,
            e.prototype.releaseCacheFromEnd = function(e) {
                for (var t = !1, r = this.mediaFileMap.get(e), i = r.getTsSum(), n = Oe.getInstance().getTask(e).getReadSn(), a = de.getInstance().getIndexAdapter(e), o = i - 1; o > n && this.totalCacheSize >= Lr.maxCacheSize; o--) {
                    if (a.snToIndex(o)) {
                        var s = r.getCacheSize(a.snToIndex(o).cache);
                        0 !== s && (this.totalCacheSize -= s,
                        re.getInstance().totalCacheSize = this.totalCacheSize,
                        r.deleteTsCache(o),
                        t = !0)
                    }
                }
                return t
            }
            ,
            e.prototype.stopPlay = function(e, t) {
                this.getMediaFile(e).isPlayTask = !1,
                !t && this.getMediaFile(e).getTaskType() !== B.Live && this.getMediaFile(e).allowP2P || (this.deleteDBCache(e),
                this.deleteMemoryCache(e),
                this.reportResource2Server(!0, !1))
            }
            ,
            e.prototype.handleP2PWrongData = function(e, t) {
                this.getMediaFile(e).wrongDataTimes += 1,
                this.getMediaFile(e).allowP2P && this.getMediaFile(e).wrongDataTimes >= Lr.maxWrongDataTimes && (this.deleteDBCache(e),
                this.setAllowP2P(e, !1),
                this.mediaFileMap.get(e).deleteTsCache(t.cache, !1))
            }
            ,
            e.prototype.setAllowP2P = function(e, t, r) {
                var i = this.getMediaFile(e);
                null !== i && i.setAllowP2P(t, null == r ? void 0 : r.cache)
            }
            ,
            e.prototype.addCheckFail = function(e, t) {
                this.mediaFileMap.get(e).addCheckFail(t)
            }
            ,
            e.prototype.onReleaseMemory = function() {
                var e = !1;
                e || (e = this.releaseLiveCache()),
                e || (e = this.releaseVodCache()),
                e && (this.reportResource2Server(!0),
                this.deleteReleasedMediaFile())
            }
            ,
            e.prototype.deleteReleasedMediaFile = function() {
                var e, t;
                try {
                    for (var r = C(this.mediaFileMap.keys()), i = r.next(); !i.done; i = r.next()) {
                        var n = i.value
                          , a = this.mediaFileMap.get(n);
                        !a.isPlayTask && a.getTotalCacheSize() <= 0 && !a.hasInDB() && this.deleteMediaFile(n)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        i && !i.done && (t = r.return) && t.call(r)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
            }
            ,
            e.prototype.deleteDBCache = function(t) {
                e.dbCache && this.getMediaFile(t).getTaskType() !== B.Live && (e.dbCache.delete({
                    keyID: t
                }),
                this.getMediaFile(t).disableDBCache())
            }
            ,
            e.prototype.deleteMemoryCache = function(e) {
                var t, r, i = this.getMediaFile(e);
                try {
                    for (var n = C(de.getInstance().getIndexAdapter(e).getIterator()), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value
                          , s = i.getCacheSize(o.cache);
                        0 === s && i.getTaskType() !== B.Live || (this.totalCacheSize -= s,
                        re.getInstance().totalCacheSize = this.totalCacheSize,
                        i.deleteTsCache(o.cache, !1))
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (r = n.return) && r.call(n)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
            }
            ,
            e.prototype.releaseVodCache = function() {
                var e, t, r, i, n, a = !1;
                if (this.totalCacheSize <= Lr.maxCacheSize)
                    return a;
                var o = [];
                try {
                    for (var s = C(this.mediaFileMap), l = s.next(); !l.done; l = s.next()) {
                        var c = L(l.value, 2)
                          , h = c[0]
                          , u = c[1];
                        if (u.getTaskType() === B.Vod) {
                            var d = null === (n = Oe.getInstance().getTask(h)) || void 0 === n ? void 0 : n.getReadSn();
                            try {
                                for (var f = (r = void 0,
                                C(de.getInstance().getIndexAdapter(h).getIterator())), p = f.next(); !p.done; p = f.next()) {
                                    var g = p.value;
                                    u.getCacheSize(g.cache) <= 0 || (void 0 !== d && g.sn >= d && g.sn <= d + Lr.vodFragKeepAfterReadIndex || void 0 !== d && g.sn >= d && !u.isInDB(g.cache) || o.push([h, g.cache, u.getLastAccessTime(g.cache)]))
                                }
                            } catch (e) {
                                r = {
                                    error: e
                                }
                            } finally {
                                try {
                                    p && !p.done && (i = f.return) && i.call(f)
                                } finally {
                                    if (r)
                                        throw r.error
                                }
                            }
                        }
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        l && !l.done && (t = s.return) && t.call(s)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                o.sort((function(e, t) {
                    return e[2] - t[2]
                }
                ));
                for (var v = 0; v < o.length && this.totalCacheSize > Lr.maxCacheSize; ++v)
                    a = !0,
                    this.totalCacheSize -= this.mediaFileMap.get(o[v][0]).getCacheSize(o[v][1]),
                    re.getInstance().totalCacheSize = this.totalCacheSize,
                    this.mediaFileMap.get(o[v][0]).deleteTsCache(o[v][1]);
                return a
            }
            ,
            e.prototype.releaseLiveCache = function() {
                var e, t, r, i, n, a = !1;
                try {
                    for (var o = C(this.mediaFileMap), s = o.next(); !s.done; s = o.next()) {
                        var l = L(s.value, 2)
                          , c = l[0]
                          , h = l[1];
                        if (h.getTaskType() === B.Live) {
                            var u = null === (n = Oe.getInstance().getTask(c)) || void 0 === n ? void 0 : n.getReadSn();
                            try {
                                for (var d = (r = void 0,
                                C(de.getInstance().getIndexAdapter(c).getIterator())), f = d.next(); !f.done; f = d.next()) {
                                    var p = f.value;
                                    if (void 0 !== u && p.sn >= u - Lr.liveFragKeepBeforeReadIndex)
                                        break;
                                    var g = h.getCacheSize(p.cache);
                                    0 !== g && (void 0 === u && (a = !0),
                                    this.totalCacheSize -= g,
                                    re.getInstance().totalCacheSize = this.totalCacheSize,
                                    h.deleteTsCache(p.cache))
                                }
                            } catch (e) {
                                r = {
                                    error: e
                                }
                            } finally {
                                try {
                                    f && !f.done && (i = d.return) && i.call(d)
                                } finally {
                                    if (r)
                                        throw r.error
                                }
                            }
                        }
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        s && !s.done && (t = o.return) && t.call(o)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return a
            }
            ,
            e.prototype.deleteMediaFile = function(e) {
                this.mediaFileMap.delete(e),
                Ar.info("CacheManager", "", "Delete MediaFile keyID = " + e + "."),
                le.getItem(e).stop(),
                de.getInstance().deleteAdapter(e),
                $t.getInstance().releaseContainer(e)
            }
            ,
            e.prototype.onCacheCaculate = function() {
                var t, r;
                if (this.totalCacheSize = 0,
                e.dbCache) {
                    var i = ct.getQuota()
                      , n = i.quota
                      , a = i.usage;
                    this.totalLocalSize = a,
                    this.maxLocalSize = n + a,
                    re.getInstance().totalLocalSize = this.totalLocalSize,
                    re.getInstance().maxAppLocalSize = this.maxLocalSize
                }
                try {
                    for (var o = C(this.mediaFileMap.values()), s = o.next(); !s.done; s = o.next()) {
                        var l = s.value;
                        this.totalCacheSize += l.getTotalCacheSize()
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (r = o.return) && r.call(o)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                re.getInstance().totalCacheSize = this.totalCacheSize
            }
            ,
            e.prototype.onUpdateIsInDB = function() {
                var t, r, i = this, n = e.dbCache.getAvailable();
                try {
                    for (var a = C(this.mediaFileMap.values()), o = a.next(); !o.done; o = a.next()) {
                        o.value.disableDBCache()
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        o && !o.done && (r = a.return) && r.call(a)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                Object.keys(n).forEach((function(e) {
                    var t = n[e].segments;
                    i.mediaFileMap.has(e) && i.updateIsInDB(e, Object.keys(t).map(Number))
                }
                ))
            }
            ,
            e.prototype.getMediaFile = function(e) {
                return this.mediaFileMap.has(e) ? this.mediaFileMap.get(e) : (Ar.error("CacheManager", "", "MediaFile not exist keyID = " + e + "."),
                null)
            }
            ,
            e.prototype.updateIsInDB = function(e, t) {
                var r, i, n, a = this.getMediaFile(e), o = de.getInstance().getIndexAdapter(e);
                if (a && a.getTaskType() === B.Vod)
                    try {
                        for (var s = C(t), l = s.next(); !l.done; l = s.next()) {
                            var c = l.value
                              , h = null === (n = o.p2pToIndex(c)) || void 0 === n ? void 0 : n.cache;
                            void 0 !== h && a.getTSCache(h) && (a.getTSCache(h).isInDB = !0)
                        }
                    } catch (e) {
                        r = {
                            error: e
                        }
                    } finally {
                        try {
                            l && !l.done && (i = s.return) && i.call(s)
                        } finally {
                            if (r)
                                throw r.error
                        }
                    }
            }
            ,
            e
        }(), ut = ht, dt = function() {
            function e() {
                this.startIndex = -1,
                this.length = 0,
                this.arrayBitmap = []
            }
            return e.prototype.setBitmapInfo = function(e, t, r) {
                var i, n;
                if (r.length === t) {
                    this.startIndex = e,
                    this.length = t,
                    this.arrayBitmap = [];
                    try {
                        for (var a = C(r), o = a.next(); !o.done; o = a.next()) {
                            var s = o.value;
                            this.arrayBitmap.push(s)
                        }
                    } catch (e) {
                        i = {
                            error: e
                        }
                    } finally {
                        try {
                            o && !o.done && (n = a.return) && n.call(a)
                        } finally {
                            if (i)
                                throw i.error
                        }
                    }
                }
            }
            ,
            e.prototype.hasBlockData = function(e, t) {
                if (e < this.startIndex || e >= this.startIndex + this.length || null === this.arrayBitmap || this.arrayBitmap.length <= 0)
                    return !1;
                var r = e - this.startIndex;
                return this.isBitSet(this.arrayBitmap[r], t)
            }
            ,
            e.prototype.isBitSet = function(e, t) {
                return !!(new Uint8Array(e)[t >> 3] << t % 8 & 128)
            }
            ,
            e
        }(), ft = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== r.g ? r.g : "undefined" != typeof self ? self : {}, pt = {}, gt = {
            byteLength: function(e) {
                var t = It(e)
                  , r = t[0]
                  , i = t[1];
                return 3 * (r + i) / 4 - i
            },
            toByteArray: function(e) {
                var t, r, i = It(e), n = i[0], a = i[1], o = new mt(function(e, t, r) {
                    return 3 * (t + r) / 4 - r
                }(0, n, a)), s = 0, l = a > 0 ? n - 4 : n;
                for (r = 0; r < l; r += 4)
                    t = yt[e.charCodeAt(r)] << 18 | yt[e.charCodeAt(r + 1)] << 12 | yt[e.charCodeAt(r + 2)] << 6 | yt[e.charCodeAt(r + 3)],
                    o[s++] = t >> 16 & 255,
                    o[s++] = t >> 8 & 255,
                    o[s++] = 255 & t;
                2 === a && (t = yt[e.charCodeAt(r)] << 2 | yt[e.charCodeAt(r + 1)] >> 4,
                o[s++] = 255 & t);
                1 === a && (t = yt[e.charCodeAt(r)] << 10 | yt[e.charCodeAt(r + 1)] << 4 | yt[e.charCodeAt(r + 2)] >> 2,
                o[s++] = t >> 8 & 255,
                o[s++] = 255 & t);
                return o
            },
            fromByteArray: function(e) {
                for (var t, r = e.length, i = r % 3, n = [], a = 16383, o = 0, s = r - i; o < s; o += a)
                    n.push(Pt(e, o, o + a > s ? s : o + a));
                1 === i ? (t = e[r - 1],
                n.push(vt[t >> 2] + vt[t << 4 & 63] + "==")) : 2 === i && (t = (e[r - 2] << 8) + e[r - 1],
                n.push(vt[t >> 10] + vt[t >> 4 & 63] + vt[t << 2 & 63] + "="));
                return n.join("")
            }
        }, vt = [], yt = [], mt = "undefined" != typeof Uint8Array ? Uint8Array : Array, Tt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", St = 0; St < 64; ++St)
            vt[St] = Tt[St],
            yt[Tt.charCodeAt(St)] = St;
        function It(e) {
            var t = e.length;
            if (t % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
            var r = e.indexOf("=");
            return -1 === r && (r = t),
            [r, r === t ? 0 : 4 - r % 4]
        }
        function Pt(e, t, r) {
            for (var i, n, a = [], o = t; o < r; o += 3)
                i = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (255 & e[o + 2]),
                a.push(vt[(n = i) >> 18 & 63] + vt[n >> 12 & 63] + vt[n >> 6 & 63] + vt[63 & n]);
            return a.join("")
        }
        yt["-".charCodeAt(0)] = 62,
        yt["_".charCodeAt(0)] = 63;
        var bt = {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
            read: function(e, t, r, i, n) {
                var a, o, s = 8 * n - i - 1, l = (1 << s) - 1, c = l >> 1, h = -7, u = r ? n - 1 : 0, d = r ? -1 : 1, f = e[t + u];
                for (u += d,
                a = f & (1 << -h) - 1,
                f >>= -h,
                h += s; h > 0; a = 256 * a + e[t + u],
                u += d,
                h -= 8)
                    ;
                for (o = a & (1 << -h) - 1,
                a >>= -h,
                h += i; h > 0; o = 256 * o + e[t + u],
                u += d,
                h -= 8)
                    ;
                if (0 === a)
                    a = 1 - c;
                else {
                    if (a === l)
                        return o ? NaN : 1 / 0 * (f ? -1 : 1);
                    o += Math.pow(2, i),
                    a -= c
                }
                return (f ? -1 : 1) * o * Math.pow(2, a - i)
            },
            write: function(e, t, r, i, n, a) {
                var o, s, l, c = 8 * a - n - 1, h = (1 << c) - 1, u = h >> 1, d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = i ? 0 : a - 1, p = i ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = Math.abs(t),
                isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0,
                o = h) : (o = Math.floor(Math.log(t) / Math.LN2),
                t * (l = Math.pow(2, -o)) < 1 && (o--,
                l *= 2),
                (t += o + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (o++,
                l /= 2),
                o + u >= h ? (s = 0,
                o = h) : o + u >= 1 ? (s = (t * l - 1) * Math.pow(2, n),
                o += u) : (s = t * Math.pow(2, u - 1) * Math.pow(2, n),
                o = 0)); n >= 8; e[r + f] = 255 & s,
                f += p,
                s /= 256,
                n -= 8)
                    ;
                for (o = o << n | s,
                c += n; c > 0; e[r + f] = 255 & o,
                f += p,
                o /= 256,
                c -= 8)
                    ;
                e[r + f - p] |= 128 * g
            }
        }
          , Et = {}.toString
          , Dt = Array.isArray || function(e) {
            return "[object Array]" == Et.call(e)
        }
        ;
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
        !function(e) {
            var t = gt
              , r = bt
              , i = Dt;
            function n() {
                return o.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
            }
            function a(e, t) {
                if (n() < t)
                    throw new RangeError("Invalid typed array length");
                return o.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = o.prototype : (null === e && (e = new o(t)),
                e.length = t),
                e
            }
            function o(e, t, r) {
                if (!(o.TYPED_ARRAY_SUPPORT || this instanceof o))
                    return new o(e,t,r);
                if ("number" == typeof e) {
                    if ("string" == typeof t)
                        throw new Error("If encoding is specified then the first argument must be a string");
                    return c(this, e)
                }
                return s(this, e, t, r)
            }
            function s(e, t, r, n) {
                if ("number" == typeof t)
                    throw new TypeError('"value" argument must not be a number');
                return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, r, i) {
                    if (t.byteLength,
                    r < 0 || t.byteLength < r)
                        throw new RangeError("'offset' is out of bounds");
                    if (t.byteLength < r + (i || 0))
                        throw new RangeError("'length' is out of bounds");
                    t = void 0 === r && void 0 === i ? new Uint8Array(t) : void 0 === i ? new Uint8Array(t,r) : new Uint8Array(t,r,i);
                    o.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = o.prototype : e = h(e, t);
                    return e
                }(e, t, r, n) : "string" == typeof t ? function(e, t, r) {
                    "string" == typeof r && "" !== r || (r = "utf8");
                    if (!o.isEncoding(r))
                        throw new TypeError('"encoding" must be a valid string encoding');
                    var i = 0 | d(t, r);
                    e = a(e, i);
                    var n = e.write(t, r);
                    n !== i && (e = e.slice(0, n));
                    return e
                }(e, t, r) : function(e, t) {
                    if (o.isBuffer(t)) {
                        var r = 0 | u(t.length);
                        return 0 === (e = a(e, r)).length || t.copy(e, 0, 0, r),
                        e
                    }
                    if (t) {
                        if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length"in t)
                            return "number" != typeof t.length || (n = t.length) != n ? a(e, 0) : h(e, t);
                        if ("Buffer" === t.type && i(t.data))
                            return h(e, t.data)
                    }
                    var n;
                    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
                }(e, t)
            }
            function l(e) {
                if ("number" != typeof e)
                    throw new TypeError('"size" argument must be a number');
                if (e < 0)
                    throw new RangeError('"size" argument must not be negative')
            }
            function c(e, t) {
                if (l(t),
                e = a(e, t < 0 ? 0 : 0 | u(t)),
                !o.TYPED_ARRAY_SUPPORT)
                    for (var r = 0; r < t; ++r)
                        e[r] = 0;
                return e
            }
            function h(e, t) {
                var r = t.length < 0 ? 0 : 0 | u(t.length);
                e = a(e, r);
                for (var i = 0; i < r; i += 1)
                    e[i] = 255 & t[i];
                return e
            }
            function u(e) {
                if (e >= n())
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n().toString(16) + " bytes");
                return 0 | e
            }
            function d(e, t) {
                if (o.isBuffer(e))
                    return e.length;
                if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
                    return e.byteLength;
                "string" != typeof e && (e = "" + e);
                var r = e.length;
                if (0 === r)
                    return 0;
                for (var i = !1; ; )
                    switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return r;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                        return N(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * r;
                    case "hex":
                        return r >>> 1;
                    case "base64":
                        return G(e).length;
                    default:
                        if (i)
                            return N(e).length;
                        t = ("" + t).toLowerCase(),
                        i = !0
                    }
            }
            function f(e, t, r) {
                var i = !1;
                if ((void 0 === t || t < 0) && (t = 0),
                t > this.length)
                    return "";
                if ((void 0 === r || r > this.length) && (r = this.length),
                r <= 0)
                    return "";
                if ((r >>>= 0) <= (t >>>= 0))
                    return "";
                for (e || (e = "utf8"); ; )
                    switch (e) {
                    case "hex":
                        return L(this, t, r);
                    case "utf8":
                    case "utf-8":
                        return E(this, t, r);
                    case "ascii":
                        return k(this, t, r);
                    case "latin1":
                    case "binary":
                        return C(this, t, r);
                    case "base64":
                        return b(this, t, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return w(this, t, r);
                    default:
                        if (i)
                            throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(),
                        i = !0
                    }
            }
            function p(e, t, r) {
                var i = e[t];
                e[t] = e[r],
                e[r] = i
            }
            function g(e, t, r, i, n) {
                if (0 === e.length)
                    return -1;
                if ("string" == typeof r ? (i = r,
                r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648),
                r = +r,
                isNaN(r) && (r = n ? 0 : e.length - 1),
                r < 0 && (r = e.length + r),
                r >= e.length) {
                    if (n)
                        return -1;
                    r = e.length - 1
                } else if (r < 0) {
                    if (!n)
                        return -1;
                    r = 0
                }
                if ("string" == typeof t && (t = o.from(t, i)),
                o.isBuffer(t))
                    return 0 === t.length ? -1 : v(e, t, r, i, n);
                if ("number" == typeof t)
                    return t &= 255,
                    o.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : v(e, [t], r, i, n);
                throw new TypeError("val must be string, number or Buffer")
            }
            function v(e, t, r, i, n) {
                var a, o = 1, s = e.length, l = t.length;
                if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                    if (e.length < 2 || t.length < 2)
                        return -1;
                    o = 2,
                    s /= 2,
                    l /= 2,
                    r /= 2
                }
                function c(e, t) {
                    return 1 === o ? e[t] : e.readUInt16BE(t * o)
                }
                if (n) {
                    var h = -1;
                    for (a = r; a < s; a++)
                        if (c(e, a) === c(t, -1 === h ? 0 : a - h)) {
                            if (-1 === h && (h = a),
                            a - h + 1 === l)
                                return h * o
                        } else
                            -1 !== h && (a -= a - h),
                            h = -1
                } else
                    for (r + l > s && (r = s - l),
                    a = r; a >= 0; a--) {
                        for (var u = !0, d = 0; d < l; d++)
                            if (c(e, a + d) !== c(t, d)) {
                                u = !1;
                                break
                            }
                        if (u)
                            return a
                    }
                return -1
            }
            function y(e, t, r, i) {
                r = Number(r) || 0;
                var n = e.length - r;
                i ? (i = Number(i)) > n && (i = n) : i = n;
                var a = t.length;
                if (a % 2 != 0)
                    throw new TypeError("Invalid hex string");
                i > a / 2 && (i = a / 2);
                for (var o = 0; o < i; ++o) {
                    var s = parseInt(t.substr(2 * o, 2), 16);
                    if (isNaN(s))
                        return o;
                    e[r + o] = s
                }
                return o
            }
            function m(e, t, r, i) {
                return H(N(t, e.length - r), e, r, i)
            }
            function T(e, t, r, i) {
                return H(function(e) {
                    for (var t = [], r = 0; r < e.length; ++r)
                        t.push(255 & e.charCodeAt(r));
                    return t
                }(t), e, r, i)
            }
            function S(e, t, r, i) {
                return T(e, t, r, i)
            }
            function I(e, t, r, i) {
                return H(G(t), e, r, i)
            }
            function P(e, t, r, i) {
                return H(function(e, t) {
                    for (var r, i, n, a = [], o = 0; o < e.length && !((t -= 2) < 0); ++o)
                        i = (r = e.charCodeAt(o)) >> 8,
                        n = r % 256,
                        a.push(n),
                        a.push(i);
                    return a
                }(t, e.length - r), e, r, i)
            }
            function b(e, r, i) {
                return 0 === r && i === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(r, i))
            }
            function E(e, t, r) {
                r = Math.min(e.length, r);
                for (var i = [], n = t; n < r; ) {
                    var a, o, s, l, c = e[n], h = null, u = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                    if (n + u <= r)
                        switch (u) {
                        case 1:
                            c < 128 && (h = c);
                            break;
                        case 2:
                            128 == (192 & (a = e[n + 1])) && (l = (31 & c) << 6 | 63 & a) > 127 && (h = l);
                            break;
                        case 3:
                            a = e[n + 1],
                            o = e[n + 2],
                            128 == (192 & a) && 128 == (192 & o) && (l = (15 & c) << 12 | (63 & a) << 6 | 63 & o) > 2047 && (l < 55296 || l > 57343) && (h = l);
                            break;
                        case 4:
                            a = e[n + 1],
                            o = e[n + 2],
                            s = e[n + 3],
                            128 == (192 & a) && 128 == (192 & o) && 128 == (192 & s) && (l = (15 & c) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) > 65535 && l < 1114112 && (h = l)
                        }
                    null === h ? (h = 65533,
                    u = 1) : h > 65535 && (h -= 65536,
                    i.push(h >>> 10 & 1023 | 55296),
                    h = 56320 | 1023 & h),
                    i.push(h),
                    n += u
                }
                return function(e) {
                    var t = e.length;
                    if (t <= D)
                        return String.fromCharCode.apply(String, e);
                    var r = ""
                      , i = 0;
                    for (; i < t; )
                        r += String.fromCharCode.apply(String, e.slice(i, i += D));
                    return r
                }(i)
            }
            e.Buffer = o,
            e.SlowBuffer = function(e) {
                +e != e && (e = 0);
                return o.alloc(+e)
            }
            ,
            e.INSPECT_MAX_BYTES = 50,
            o.TYPED_ARRAY_SUPPORT = void 0 !== ft.TYPED_ARRAY_SUPPORT ? ft.TYPED_ARRAY_SUPPORT : function() {
                try {
                    var e = new Uint8Array(1);
                    return e.__proto__ = {
                        __proto__: Uint8Array.prototype,
                        foo: function() {
                            return 42
                        }
                    },
                    42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
                } catch (e) {
                    return !1
                }
            }(),
            e.kMaxLength = n(),
            o.poolSize = 8192,
            o._augment = function(e) {
                return e.__proto__ = o.prototype,
                e
            }
            ,
            o.from = function(e, t, r) {
                return s(null, e, t, r)
            }
            ,
            o.TYPED_ARRAY_SUPPORT && (o.prototype.__proto__ = Uint8Array.prototype,
            o.__proto__ = Uint8Array,
            "undefined" != typeof Symbol && Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, {
                value: null,
                configurable: !0
            })),
            o.alloc = function(e, t, r) {
                return function(e, t, r, i) {
                    return l(t),
                    t <= 0 ? a(e, t) : void 0 !== r ? "string" == typeof i ? a(e, t).fill(r, i) : a(e, t).fill(r) : a(e, t)
                }(null, e, t, r)
            }
            ,
            o.allocUnsafe = function(e) {
                return c(null, e)
            }
            ,
            o.allocUnsafeSlow = function(e) {
                return c(null, e)
            }
            ,
            o.isBuffer = function(e) {
                return !(null == e || !e._isBuffer)
            }
            ,
            o.compare = function(e, t) {
                if (!o.isBuffer(e) || !o.isBuffer(t))
                    throw new TypeError("Arguments must be Buffers");
                if (e === t)
                    return 0;
                for (var r = e.length, i = t.length, n = 0, a = Math.min(r, i); n < a; ++n)
                    if (e[n] !== t[n]) {
                        r = e[n],
                        i = t[n];
                        break
                    }
                return r < i ? -1 : i < r ? 1 : 0
            }
            ,
            o.isEncoding = function(e) {
                switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return !0;
                default:
                    return !1
                }
            }
            ,
            o.concat = function(e, t) {
                if (!i(e))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === e.length)
                    return o.alloc(0);
                var r;
                if (void 0 === t)
                    for (t = 0,
                    r = 0; r < e.length; ++r)
                        t += e[r].length;
                var n = o.allocUnsafe(t)
                  , a = 0;
                for (r = 0; r < e.length; ++r) {
                    var s = e[r];
                    if (!o.isBuffer(s))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    s.copy(n, a),
                    a += s.length
                }
                return n
            }
            ,
            o.byteLength = d,
            o.prototype._isBuffer = !0,
            o.prototype.swap16 = function() {
                var e = this.length;
                if (e % 2 != 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (var t = 0; t < e; t += 2)
                    p(this, t, t + 1);
                return this
            }
            ,
            o.prototype.swap32 = function() {
                var e = this.length;
                if (e % 4 != 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (var t = 0; t < e; t += 4)
                    p(this, t, t + 3),
                    p(this, t + 1, t + 2);
                return this
            }
            ,
            o.prototype.swap64 = function() {
                var e = this.length;
                if (e % 8 != 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (var t = 0; t < e; t += 8)
                    p(this, t, t + 7),
                    p(this, t + 1, t + 6),
                    p(this, t + 2, t + 5),
                    p(this, t + 3, t + 4);
                return this
            }
            ,
            o.prototype.toString = function() {
                var e = 0 | this.length;
                return 0 === e ? "" : 0 === arguments.length ? E(this, 0, e) : f.apply(this, arguments)
            }
            ,
            o.prototype.equals = function(e) {
                if (!o.isBuffer(e))
                    throw new TypeError("Argument must be a Buffer");
                return this === e || 0 === o.compare(this, e)
            }
            ,
            o.prototype.inspect = function() {
                var t = ""
                  , r = e.INSPECT_MAX_BYTES;
                return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "),
                this.length > r && (t += " ... ")),
                "<Buffer " + t + ">"
            }
            ,
            o.prototype.compare = function(e, t, r, i, n) {
                if (!o.isBuffer(e))
                    throw new TypeError("Argument must be a Buffer");
                if (void 0 === t && (t = 0),
                void 0 === r && (r = e ? e.length : 0),
                void 0 === i && (i = 0),
                void 0 === n && (n = this.length),
                t < 0 || r > e.length || i < 0 || n > this.length)
                    throw new RangeError("out of range index");
                if (i >= n && t >= r)
                    return 0;
                if (i >= n)
                    return -1;
                if (t >= r)
                    return 1;
                if (this === e)
                    return 0;
                for (var a = (n >>>= 0) - (i >>>= 0), s = (r >>>= 0) - (t >>>= 0), l = Math.min(a, s), c = this.slice(i, n), h = e.slice(t, r), u = 0; u < l; ++u)
                    if (c[u] !== h[u]) {
                        a = c[u],
                        s = h[u];
                        break
                    }
                return a < s ? -1 : s < a ? 1 : 0
            }
            ,
            o.prototype.includes = function(e, t, r) {
                return -1 !== this.indexOf(e, t, r)
            }
            ,
            o.prototype.indexOf = function(e, t, r) {
                return g(this, e, t, r, !0)
            }
            ,
            o.prototype.lastIndexOf = function(e, t, r) {
                return g(this, e, t, r, !1)
            }
            ,
            o.prototype.write = function(e, t, r, i) {
                if (void 0 === t)
                    i = "utf8",
                    r = this.length,
                    t = 0;
                else if (void 0 === r && "string" == typeof t)
                    i = t,
                    r = this.length,
                    t = 0;
                else {
                    if (!isFinite(t))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    t |= 0,
                    isFinite(r) ? (r |= 0,
                    void 0 === i && (i = "utf8")) : (i = r,
                    r = void 0)
                }
                var n = this.length - t;
                if ((void 0 === r || r > n) && (r = n),
                e.length > 0 && (r < 0 || t < 0) || t > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                i || (i = "utf8");
                for (var a = !1; ; )
                    switch (i) {
                    case "hex":
                        return y(this, e, t, r);
                    case "utf8":
                    case "utf-8":
                        return m(this, e, t, r);
                    case "ascii":
                        return T(this, e, t, r);
                    case "latin1":
                    case "binary":
                        return S(this, e, t, r);
                    case "base64":
                        return I(this, e, t, r);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return P(this, e, t, r);
                    default:
                        if (a)
                            throw new TypeError("Unknown encoding: " + i);
                        i = ("" + i).toLowerCase(),
                        a = !0
                    }
            }
            ,
            o.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            ;
            var D = 4096;
            function k(e, t, r) {
                var i = "";
                r = Math.min(e.length, r);
                for (var n = t; n < r; ++n)
                    i += String.fromCharCode(127 & e[n]);
                return i
            }
            function C(e, t, r) {
                var i = "";
                r = Math.min(e.length, r);
                for (var n = t; n < r; ++n)
                    i += String.fromCharCode(e[n]);
                return i
            }
            function L(e, t, r) {
                var i = e.length;
                (!t || t < 0) && (t = 0),
                (!r || r < 0 || r > i) && (r = i);
                for (var n = "", a = t; a < r; ++a)
                    n += U(e[a]);
                return n
            }
            function w(e, t, r) {
                for (var i = e.slice(t, r), n = "", a = 0; a < i.length; a += 2)
                    n += String.fromCharCode(i[a] + 256 * i[a + 1]);
                return n
            }
            function R(e, t, r) {
                if (e % 1 != 0 || e < 0)
                    throw new RangeError("offset is not uint");
                if (e + t > r)
                    throw new RangeError("Trying to access beyond buffer length")
            }
            function A(e, t, r, i, n, a) {
                if (!o.isBuffer(e))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                if (t > n || t < a)
                    throw new RangeError('"value" argument is out of bounds');
                if (r + i > e.length)
                    throw new RangeError("Index out of range")
            }
            function _(e, t, r, i) {
                t < 0 && (t = 65535 + t + 1);
                for (var n = 0, a = Math.min(e.length - r, 2); n < a; ++n)
                    e[r + n] = (t & 255 << 8 * (i ? n : 1 - n)) >>> 8 * (i ? n : 1 - n)
            }
            function x(e, t, r, i) {
                t < 0 && (t = 4294967295 + t + 1);
                for (var n = 0, a = Math.min(e.length - r, 4); n < a; ++n)
                    e[r + n] = t >>> 8 * (i ? n : 3 - n) & 255
            }
            function O(e, t, r, i, n, a) {
                if (r + i > e.length)
                    throw new RangeError("Index out of range");
                if (r < 0)
                    throw new RangeError("Index out of range")
            }
            function F(e, t, i, n, a) {
                return a || O(e, 0, i, 4),
                r.write(e, t, i, n, 23, 4),
                i + 4
            }
            function B(e, t, i, n, a) {
                return a || O(e, 0, i, 8),
                r.write(e, t, i, n, 52, 8),
                i + 8
            }
            o.prototype.slice = function(e, t) {
                var r, i = this.length;
                if ((e = ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i),
                (t = void 0 === t ? i : ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i),
                t < e && (t = e),
                o.TYPED_ARRAY_SUPPORT)
                    (r = this.subarray(e, t)).__proto__ = o.prototype;
                else {
                    var n = t - e;
                    r = new o(n,void 0);
                    for (var a = 0; a < n; ++a)
                        r[a] = this[a + e]
                }
                return r
            }
            ,
            o.prototype.readUIntLE = function(e, t, r) {
                e |= 0,
                t |= 0,
                r || R(e, t, this.length);
                for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256); )
                    i += this[e + a] * n;
                return i
            }
            ,
            o.prototype.readUIntBE = function(e, t, r) {
                e |= 0,
                t |= 0,
                r || R(e, t, this.length);
                for (var i = this[e + --t], n = 1; t > 0 && (n *= 256); )
                    i += this[e + --t] * n;
                return i
            }
            ,
            o.prototype.readUInt8 = function(e, t) {
                return t || R(e, 1, this.length),
                this[e]
            }
            ,
            o.prototype.readUInt16LE = function(e, t) {
                return t || R(e, 2, this.length),
                this[e] | this[e + 1] << 8
            }
            ,
            o.prototype.readUInt16BE = function(e, t) {
                return t || R(e, 2, this.length),
                this[e] << 8 | this[e + 1]
            }
            ,
            o.prototype.readUInt32LE = function(e, t) {
                return t || R(e, 4, this.length),
                (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
            }
            ,
            o.prototype.readUInt32BE = function(e, t) {
                return t || R(e, 4, this.length),
                16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
            }
            ,
            o.prototype.readIntLE = function(e, t, r) {
                e |= 0,
                t |= 0,
                r || R(e, t, this.length);
                for (var i = this[e], n = 1, a = 0; ++a < t && (n *= 256); )
                    i += this[e + a] * n;
                return i >= (n *= 128) && (i -= Math.pow(2, 8 * t)),
                i
            }
            ,
            o.prototype.readIntBE = function(e, t, r) {
                e |= 0,
                t |= 0,
                r || R(e, t, this.length);
                for (var i = t, n = 1, a = this[e + --i]; i > 0 && (n *= 256); )
                    a += this[e + --i] * n;
                return a >= (n *= 128) && (a -= Math.pow(2, 8 * t)),
                a
            }
            ,
            o.prototype.readInt8 = function(e, t) {
                return t || R(e, 1, this.length),
                128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
            }
            ,
            o.prototype.readInt16LE = function(e, t) {
                t || R(e, 2, this.length);
                var r = this[e] | this[e + 1] << 8;
                return 32768 & r ? 4294901760 | r : r
            }
            ,
            o.prototype.readInt16BE = function(e, t) {
                t || R(e, 2, this.length);
                var r = this[e + 1] | this[e] << 8;
                return 32768 & r ? 4294901760 | r : r
            }
            ,
            o.prototype.readInt32LE = function(e, t) {
                return t || R(e, 4, this.length),
                this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
            }
            ,
            o.prototype.readInt32BE = function(e, t) {
                return t || R(e, 4, this.length),
                this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
            }
            ,
            o.prototype.readFloatLE = function(e, t) {
                return t || R(e, 4, this.length),
                r.read(this, e, !0, 23, 4)
            }
            ,
            o.prototype.readFloatBE = function(e, t) {
                return t || R(e, 4, this.length),
                r.read(this, e, !1, 23, 4)
            }
            ,
            o.prototype.readDoubleLE = function(e, t) {
                return t || R(e, 8, this.length),
                r.read(this, e, !0, 52, 8)
            }
            ,
            o.prototype.readDoubleBE = function(e, t) {
                return t || R(e, 8, this.length),
                r.read(this, e, !1, 52, 8)
            }
            ,
            o.prototype.writeUIntLE = function(e, t, r, i) {
                (e = +e,
                t |= 0,
                r |= 0,
                i) || A(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
                var n = 1
                  , a = 0;
                for (this[t] = 255 & e; ++a < r && (n *= 256); )
                    this[t + a] = e / n & 255;
                return t + r
            }
            ,
            o.prototype.writeUIntBE = function(e, t, r, i) {
                (e = +e,
                t |= 0,
                r |= 0,
                i) || A(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
                var n = r - 1
                  , a = 1;
                for (this[t + n] = 255 & e; --n >= 0 && (a *= 256); )
                    this[t + n] = e / a & 255;
                return t + r
            }
            ,
            o.prototype.writeUInt8 = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 1, 255, 0),
                o.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
                this[t] = 255 & e,
                t + 1
            }
            ,
            o.prototype.writeUInt16LE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 2, 65535, 0),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
                this[t + 1] = e >>> 8) : _(this, e, t, !0),
                t + 2
            }
            ,
            o.prototype.writeUInt16BE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 2, 65535, 0),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
                this[t + 1] = 255 & e) : _(this, e, t, !1),
                t + 2
            }
            ,
            o.prototype.writeUInt32LE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 4, 4294967295, 0),
                o.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24,
                this[t + 2] = e >>> 16,
                this[t + 1] = e >>> 8,
                this[t] = 255 & e) : x(this, e, t, !0),
                t + 4
            }
            ,
            o.prototype.writeUInt32BE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 4, 4294967295, 0),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
                this[t + 1] = e >>> 16,
                this[t + 2] = e >>> 8,
                this[t + 3] = 255 & e) : x(this, e, t, !1),
                t + 4
            }
            ,
            o.prototype.writeIntLE = function(e, t, r, i) {
                if (e = +e,
                t |= 0,
                !i) {
                    var n = Math.pow(2, 8 * r - 1);
                    A(this, e, t, r, n - 1, -n)
                }
                var a = 0
                  , o = 1
                  , s = 0;
                for (this[t] = 255 & e; ++a < r && (o *= 256); )
                    e < 0 && 0 === s && 0 !== this[t + a - 1] && (s = 1),
                    this[t + a] = (e / o | 0) - s & 255;
                return t + r
            }
            ,
            o.prototype.writeIntBE = function(e, t, r, i) {
                if (e = +e,
                t |= 0,
                !i) {
                    var n = Math.pow(2, 8 * r - 1);
                    A(this, e, t, r, n - 1, -n)
                }
                var a = r - 1
                  , o = 1
                  , s = 0;
                for (this[t + a] = 255 & e; --a >= 0 && (o *= 256); )
                    e < 0 && 0 === s && 0 !== this[t + a + 1] && (s = 1),
                    this[t + a] = (e / o | 0) - s & 255;
                return t + r
            }
            ,
            o.prototype.writeInt8 = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 1, 127, -128),
                o.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
                e < 0 && (e = 255 + e + 1),
                this[t] = 255 & e,
                t + 1
            }
            ,
            o.prototype.writeInt16LE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 2, 32767, -32768),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
                this[t + 1] = e >>> 8) : _(this, e, t, !0),
                t + 2
            }
            ,
            o.prototype.writeInt16BE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 2, 32767, -32768),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8,
                this[t + 1] = 255 & e) : _(this, e, t, !1),
                t + 2
            }
            ,
            o.prototype.writeInt32LE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 4, 2147483647, -2147483648),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e,
                this[t + 1] = e >>> 8,
                this[t + 2] = e >>> 16,
                this[t + 3] = e >>> 24) : x(this, e, t, !0),
                t + 4
            }
            ,
            o.prototype.writeInt32BE = function(e, t, r) {
                return e = +e,
                t |= 0,
                r || A(this, e, t, 4, 2147483647, -2147483648),
                e < 0 && (e = 4294967295 + e + 1),
                o.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24,
                this[t + 1] = e >>> 16,
                this[t + 2] = e >>> 8,
                this[t + 3] = 255 & e) : x(this, e, t, !1),
                t + 4
            }
            ,
            o.prototype.writeFloatLE = function(e, t, r) {
                return F(this, e, t, !0, r)
            }
            ,
            o.prototype.writeFloatBE = function(e, t, r) {
                return F(this, e, t, !1, r)
            }
            ,
            o.prototype.writeDoubleLE = function(e, t, r) {
                return B(this, e, t, !0, r)
            }
            ,
            o.prototype.writeDoubleBE = function(e, t, r) {
                return B(this, e, t, !1, r)
            }
            ,
            o.prototype.copy = function(e, t, r, i) {
                if (r || (r = 0),
                i || 0 === i || (i = this.length),
                t >= e.length && (t = e.length),
                t || (t = 0),
                i > 0 && i < r && (i = r),
                i === r)
                    return 0;
                if (0 === e.length || 0 === this.length)
                    return 0;
                if (t < 0)
                    throw new RangeError("targetStart out of bounds");
                if (r < 0 || r >= this.length)
                    throw new RangeError("sourceStart out of bounds");
                if (i < 0)
                    throw new RangeError("sourceEnd out of bounds");
                i > this.length && (i = this.length),
                e.length - t < i - r && (i = e.length - t + r);
                var n, a = i - r;
                if (this === e && r < t && t < i)
                    for (n = a - 1; n >= 0; --n)
                        e[n + t] = this[n + r];
                else if (a < 1e3 || !o.TYPED_ARRAY_SUPPORT)
                    for (n = 0; n < a; ++n)
                        e[n + t] = this[n + r];
                else
                    Uint8Array.prototype.set.call(e, this.subarray(r, r + a), t);
                return a
            }
            ,
            o.prototype.fill = function(e, t, r, i) {
                if ("string" == typeof e) {
                    if ("string" == typeof t ? (i = t,
                    t = 0,
                    r = this.length) : "string" == typeof r && (i = r,
                    r = this.length),
                    1 === e.length) {
                        var n = e.charCodeAt(0);
                        n < 256 && (e = n)
                    }
                    if (void 0 !== i && "string" != typeof i)
                        throw new TypeError("encoding must be a string");
                    if ("string" == typeof i && !o.isEncoding(i))
                        throw new TypeError("Unknown encoding: " + i)
                } else
                    "number" == typeof e && (e &= 255);
                if (t < 0 || this.length < t || this.length < r)
                    throw new RangeError("Out of range index");
                if (r <= t)
                    return this;
                var a;
                if (t >>>= 0,
                r = void 0 === r ? this.length : r >>> 0,
                e || (e = 0),
                "number" == typeof e)
                    for (a = t; a < r; ++a)
                        this[a] = e;
                else {
                    var s = o.isBuffer(e) ? e : N(new o(e,i).toString())
                      , l = s.length;
                    for (a = 0; a < r - t; ++a)
                        this[a + t] = s[a % l]
                }
                return this
            }
            ;
            var M = /[^+\/0-9A-Za-z-_]/g;
            function U(e) {
                return e < 16 ? "0" + e.toString(16) : e.toString(16)
            }
            function N(e, t) {
                var r;
                t = t || 1 / 0;
                for (var i = e.length, n = null, a = [], o = 0; o < i; ++o) {
                    if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
                        if (!n) {
                            if (r > 56319) {
                                (t -= 3) > -1 && a.push(239, 191, 189);
                                continue
                            }
                            if (o + 1 === i) {
                                (t -= 3) > -1 && a.push(239, 191, 189);
                                continue
                            }
                            n = r;
                            continue
                        }
                        if (r < 56320) {
                            (t -= 3) > -1 && a.push(239, 191, 189),
                            n = r;
                            continue
                        }
                        r = 65536 + (n - 55296 << 10 | r - 56320)
                    } else
                        n && (t -= 3) > -1 && a.push(239, 191, 189);
                    if (n = null,
                    r < 128) {
                        if ((t -= 1) < 0)
                            break;
                        a.push(r)
                    } else if (r < 2048) {
                        if ((t -= 2) < 0)
                            break;
                        a.push(r >> 6 | 192, 63 & r | 128)
                    } else if (r < 65536) {
                        if ((t -= 3) < 0)
                            break;
                        a.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
                    } else {
                        if (!(r < 1114112))
                            throw new Error("Invalid code point");
                        if ((t -= 4) < 0)
                            break;
                        a.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
                    }
                }
                return a
            }
            function G(e) {
                return t.toByteArray(function(e) {
                    if ((e = function(e) {
                        return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                    }(e).replace(M, "")).length < 2)
                        return "";
                    for (; e.length % 4 != 0; )
                        e += "=";
                    return e
                }(e))
            }
            function H(e, t, r, i) {
                for (var n = 0; n < i && !(n + r >= t.length || n >= e.length); ++n)
                    t[n + r] = e[n];
                return n
            }
        }(pt);
        var kt, Ct = function() {
            function e(e) {
                this.cur = 0,
                this.buf = new pt.Buffer(e)
            }
            return e.prototype.readUint8 = function() {
                if (this.cur + 1 <= this.buf.length) {
                    var e = this.buf.readUInt8(this.cur);
                    return this.cur += 1,
                    e
                }
                return -1
            }
            ,
            e.prototype.readUint16 = function() {
                if (this.cur + 2 <= this.buf.length) {
                    var e = this.buf.readUInt16BE(this.cur);
                    return this.cur += 2,
                    e
                }
                return -1
            }
            ,
            e.prototype.readUint32 = function() {
                if (this.cur + 4 <= this.buf.length) {
                    var e = this.buf.readUInt32BE(this.cur);
                    return this.cur += 4,
                    e
                }
                return -1
            }
            ,
            e.prototype.readString = function() {
                var e = this.readUint16();
                if (-1 === e || this.cur + e > this.buf.length)
                    return "";
                var t = this.buf.toString("utf8", this.cur, this.cur + e);
                return this.cur += e,
                t
            }
            ,
            e.prototype.readBytesData = function() {
                var e = this.readUint16();
                if (-1 === e || this.cur + e > this.buf.length)
                    return new ArrayBuffer(0);
                var t = this.buf.slice(this.cur, this.cur + e);
                this.cur += e;
                var r = new ArrayBuffer(e);
                return new Uint8Array(r).set(t),
                r
            }
            ,
            e
        }(), Lt = 65536, wt = function() {
            function e() {
                this.cur = 0,
                this.buf = new pt.Buffer(Lt)
            }
            return e.prototype.writeUint8 = function(e) {
                return e < 256 && this.cur + 1 < Lt && (this.buf.writeUInt8(e, this.cur),
                this.cur += 1,
                !0)
            }
            ,
            e.prototype.writeUint16 = function(e) {
                return e < 65536 && this.cur + 2 < Lt && (this.buf.writeUInt16BE(e, this.cur),
                this.cur += 2,
                !0)
            }
            ,
            e.prototype.writeUint32 = function(e) {
                return e < 4294967296 && this.cur + 4 < Lt && (this.buf.writeUInt32BE(e, this.cur),
                this.cur += 4,
                !0)
            }
            ,
            e.prototype.writeString = function(e) {
                var t = e.length;
                return this.cur + t < Lt && (this.writeUint16(t),
                this.cur += this.buf.write(e, this.cur),
                !0)
            }
            ,
            e.prototype.writeBytesData = function(e) {
                var t = e.byteLength;
                if (this.cur + t < Lt) {
                    var r = new Uint8Array(e);
                    return this.writeUint16(t),
                    this.buf.set(r, this.cur),
                    this.cur += t,
                    !0
                }
                return !1
            }
            ,
            e.prototype.buffer = function() {
                var e = new ArrayBuffer(this.cur)
                  , t = new Uint8Array(e)
                  , r = this.buf.slice(0, this.cur);
                return t.set(r),
                e
            }
            ,
            e
        }(), Rt = 3, At = 4, _t = 5, xt = 6, Ot = 7, Ft = 11, Bt = 12, Mt = 13, Ut = 14, Nt = 15, Gt = 16, Ht = 17, qt = 1, zt = 2, Kt = function() {
            function e() {}
            return e.getP2PProtocolStr = function(e) {
                var t = "";
                switch (e) {
                case Rt:
                    t = "P2P_RequestBitmap";
                    break;
                case At:
                    t = "P2P_ResponseBitmap";
                    break;
                case _t:
                    t = "P2P_RequestPieceData";
                    break;
                case xt:
                    t = "P2P_ResponsePieceData";
                    break;
                case Ot:
                    t = "P2P_WrongData";
                    break;
                case Ft:
                    t = "P2P_ResponseBusy";
                    break;
                case Bt:
                    t = "P2P_ByebyeMsg";
                    break;
                case Mt:
                    t = "P2P_UploadReq";
                    break;
                case Ut:
                    t = "P2P_UploadRes";
                    break;
                case Nt:
                    t = "P2P_DownloadReq";
                    break;
                case Gt:
                    t = "P2P_DownloadRes"
                }
                return t
            }
            ,
            e.recvDataUnserialize = function(e) {
                var t = new Ct(e)
                  , r = t.readUint16();
                switch (r) {
                case Rt:
                    return this.bitmapReqUnserialize(t, r);
                case At:
                    return this.bitmapRespUnserialize(t, r);
                case _t:
                    return this.dataReqUnserialize(t, r);
                case xt:
                    return this.dataRespUnserialize(t, r);
                case Ot:
                    return this.wrongDataUnserialize(t, r);
                case Bt:
                    return this.byebyeReqUnserialize(t, r);
                case Mt:
                    return this.uploadReqUnserialize(t, r);
                case Ut:
                    return this.uploadResUnserialize(t, r);
                case Nt:
                    return this.downloadReqUnserialize(t, r);
                case Gt:
                    return this.downloadResUnserialize(t, r);
                case Ht:
                    return this.nullPackUnserialize(t, r)
                }
            }
            ,
            e.bitmapReq = function(e, t, r, i) {
                var n = new wt;
                return n.writeUint16(Rt),
                n.writeUint16(2),
                n.writeUint16(e),
                n.writeString(t),
                n.writeUint32(r),
                n.writeUint16(i),
                n.buffer()
            }
            ,
            e.bitmapResp = function(e, t, r, i, n, a, o) {
                var s = new wt;
                if (s.writeUint16(At),
                s.writeUint16(4),
                s.writeUint16(e),
                s.writeString(t),
                s.writeUint32(r),
                i !== n.length || i !== o.length)
                    return new ArrayBuffer(0);
                s.writeUint16(i);
                for (var l = 0; l < i; l++)
                    null === n[l] || void 0 === n[l] ? s.writeUint16(zt) : (s.writeUint16(qt),
                    s.writeBytesData(n[l]));
                s.writeUint8(a);
                for (l = 0; l < i; l++)
                    s.writeUint32(o[l]);
                return s.buffer()
            }
            ,
            e.dataReq = function(e, t, r, i, n, a, o) {
                var s = new wt;
                return s.writeUint16(_t),
                s.writeUint16(2),
                s.writeUint16(e),
                s.writeString(t),
                s.writeUint32(r),
                s.writeUint32(i),
                s.writeUint16(n),
                s.writeUint16(a),
                s.writeUint16(o),
                s.buffer()
            }
            ,
            e.dataResp = function(e, t, r, i, n, a, o, s) {
                var l = new wt;
                return l.writeUint16(xt),
                l.writeUint16(2),
                l.writeUint16(e),
                l.writeString(t),
                l.writeUint32(r),
                l.writeUint32(i),
                l.writeUint16(n),
                l.writeUint16(a),
                l.writeUint32(o),
                l.writeBytesData(s),
                l.buffer()
            }
            ,
            e.wrongData = function(e, t, r, i, n) {
                var a = new wt;
                return a.writeUint16(Ot),
                a.writeUint16(1),
                a.writeUint16(e),
                a.writeString(t),
                a.writeUint32(r),
                a.writeUint16(i),
                a.writeUint16(n),
                a.buffer()
            }
            ,
            e.byebyeReq = function(e) {
                var t = new wt;
                return t.writeUint16(2),
                t.writeUint16(e),
                t.buffer()
            }
            ,
            e.uploadReq = function(e, t, r) {
                var i = new wt;
                return i.writeUint16(Mt),
                i.writeUint16(2),
                i.writeUint16(e),
                i.writeUint32(t),
                i.writeString(r),
                i.buffer()
            }
            ,
            e.uploadRes = function(e, t, r, i, n) {
                var a = new wt;
                return a.writeUint16(Ut),
                a.writeUint16(2),
                a.writeUint16(e),
                a.writeUint32(t),
                a.writeString(r),
                a.writeUint8(i),
                a.writeString(n),
                a.buffer()
            }
            ,
            e.downloadReq = function(e, t, r) {
                var i = new wt;
                return i.writeUint16(Nt),
                i.writeUint16(2),
                i.writeUint16(e),
                i.writeUint32(t),
                i.writeString(r),
                i.buffer()
            }
            ,
            e.nullPack = function(e, t, r) {
                var i = new wt;
                return i.writeUint16(Ht),
                i.writeUint16(2),
                i.writeUint16(e),
                i.writeString(t),
                i.writeUint16(r),
                i.buffer()
            }
            ,
            e.downloadRes = function(e, t, r, i, n) {
                var a = new wt;
                return a.writeUint16(Gt),
                a.writeUint16(2),
                a.writeUint16(e),
                a.writeUint32(t),
                a.writeString(r),
                a.writeUint8(i),
                a.writeString(n),
                a.buffer()
            }
            ,
            e.dataRespUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.keyID = e.readString(),
                r.p2pSeq = e.readUint32(),
                r.fileSize = e.readUint32(),
                r.blockID = e.readUint16(),
                r.pieceID = e.readUint16(),
                r.check = e.readUint32(),
                r.data = e.readBytesData()),
                r
            }
            ,
            e.wrongDataUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                1 & r.mask && (r.seq = e.readUint16(),
                r.keyID = e.readString(),
                r.p2pSeq = e.readUint32(),
                r.blockID = e.readUint16(),
                r.pieceID = e.readUint16()),
                r
            }
            ,
            e.byebyeReqUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16()),
                r
            }
            ,
            e.uploadReqUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.uin = e.readString(),
                r.keyID = e.readUint32()),
                r
            }
            ,
            e.uploadResUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.uin = e.readUint32(),
                r.keyID = e.readString(),
                r.ok = e.readUint8(),
                r.reason = e.readString()),
                r
            }
            ,
            e.downloadReqUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.uin = e.readUint32(),
                r.keyID = e.readString()),
                r
            }
            ,
            e.downloadResUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.uin = e.readUint32(),
                r.keyID = e.readString(),
                r.ok = e.readUint8(),
                r.reason = e.readString()),
                r
            }
            ,
            e.nullPackUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.keyID = e.readString(),
                r.reason = e.readUint16()),
                r
            }
            ,
            e.bitmapRespUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                if (r.mask = e.readUint16(),
                4 & r.mask) {
                    r.seq = e.readUint16(),
                    r.keyID = e.readString(),
                    r.p2pSeq = e.readUint32(),
                    r.length = e.readUint16(),
                    r.bmArray = [];
                    for (var i = r.length; i > 0; ) {
                        e.readUint16() === zt ? r.bmArray.push(null) : r.bmArray.push(e.readBytesData()),
                        i -= 1
                    }
                    for (r.busy = e.readUint8(),
                    r.fArray = [],
                    i = r.length; i > 0; )
                        r.fArray.push(e.readUint32()),
                        i -= 1
                }
                return r
            }
            ,
            e.dataReqUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.keyID = e.readString(),
                r.p2pSeq = e.readUint32(),
                r.fileSize = e.readUint32(),
                r.blockID = e.readUint16(),
                r.pieceID = e.readUint16(),
                r.reqNum = e.readUint16()),
                r
            }
            ,
            e.bitmapReqUnserialize = function(e, t) {
                var r = {
                    cmd: t
                };
                return r.mask = e.readUint16(),
                2 & r.mask && (r.seq = e.readUint16(),
                r.keyID = e.readString(),
                r.p2pSeq = e.readUint32(),
                r.length = e.readUint16()),
                r
            }
            ,
            e
        }();
        !function(e) {
            e[e.Init = 0] = "Init",
            e[e.CreateOffer = 1] = "CreateOffer",
            e[e.RecvAnswer = 2] = "RecvAnswer",
            e[e.AddIceCandidate = 3] = "AddIceCandidate",
            e[e.Ready = 4] = "Ready",
            e[e.Close = 5] = "Close"
        }(kt || (kt = {}));
        var Vt, jt, Wt = function() {
            function e(e, t, r, i, n) {
                this.keyID = t,
                this.peerID = e,
                this.state = kt.Init,
                this.dataChannelCallback = n,
                this.sessionType = i,
                this.punchDownState = x.UnKnown,
                this.punchUpState = x.UnKnown,
                this.msgSeq = 0,
                this.candidateCache = [],
                this.establishChannelFinish = !1,
                this.haveUploaded = !1,
                this.lastConnectTime = -1,
                this.firstICE = !0;
                var a = {
                    iceServers: this.getICEServersConfig(r)
                };
                if (this.peerConnection = this.createPeerConnect(a),
                this.bitmapInfo = new dt,
                this.slidingWindow = new Pr(this.keyID),
                null === this.peerConnection)
                    return Ar.warn("PeerConnection", this.getLogStatus(), "createPeerConnection error,not support p2p"),
                    re.getInstance().supportWebRTC = V.RTC_CALL_FAIL,
                    void this.dataChannelCallback.onPeerWebRTCError();
                var o = Tr.getTick();
                if (i === ie.Down) {
                    this.lastConnectTime = -1,
                    this.punchDownState = x.Start;
                    var s = {
                        maxPacketLifeTime: Lr.webrtcMaxPacketLifeTime || null,
                        ordered: Lr.webrtcOrdered
                    };
                    this.dataChannel = this.peerConnection.createDataChannel(String(this.peerID), s),
                    this.bindDataChannel(this.dataChannel)
                } else
                    i === ie.Up && (this.punchUpState = x.Start,
                    this.dataChannel = null,
                    this.lastConnectTime = o);
                this.connectSucTime = -1,
                this.recvBitmapTickDownload = o,
                this.sendBitmapTickDownload = o,
                this.recvBitmapTickUpload = o,
                this.dataRecvTickUpload = o,
                this.dataSendTickDownload = o,
                this.dataRecvTickDownload = o,
                this.released = !1,
                this.busy = !1,
                this.hasSetRemoteDes = !1,
                this.needDownload = !1,
                Ar.debug("PeerConnection", this.getLogStatus(), "createPeerConnection")
            }
            return e.isPublicAddress = function(e) {
                var t, r;
                if (!e)
                    return !1;
                try {
                    for (var i = C(e), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value;
                        if (a && 5 === a.length) {
                            var o = parseInt(a[1], 10)
                              , s = parseInt(a[2], 10);
                            if (10 !== o && !(172 === o && s >= 16 && s <= 31 || 192 === o && 168 === s))
                                return !0
                        }
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return !1
            }
            ,
            e.getAddressFromCandidate = function(e) {
                if (!e)
                    return null;
                if (0 === e.length)
                    return null;
                e = e.toString();
                var t = new RegExp(/(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])/)
                  , r = [];
                return r.push(e.match(t)),
                r.push(e.substring(e.search(t) + 7).match(t)),
                r
            }
            ,
            e.prototype.destroy = function() {}
            ,
            e.prototype.setConnectSucTime = function(e) {
                this.connectSucTime = e
            }
            ,
            e.prototype.isDownloadDead = function() {
                return this.sendBitmapTickDownload - this.recvBitmapTickDownload >= 1e3 * Lr.p2pPeerDownloadMsgDead
            }
            ,
            e.prototype.getPeerID = function() {
                return this.peerID
            }
            ,
            e.prototype.close = function() {}
            ,
            e.prototype.update = function() {
                this.sessionType && this.sessionType & ie.Up || this.sessionType && this.sessionType & ie.Down && this.state === kt.Init && this.createOffer()
            }
            ,
            e.prototype.onRecv = function(e) {
                switch (e.type) {
                case Z.offer:
                    le.getItem(this.keyID).recvOfferTimes += 1,
                    this.recvOffer(e.offer);
                    break;
                case Z.answer:
                    le.getItem(this.keyID).recvAnswerTimes += 1,
                    this.handleAnswer(e);
                    break;
                case Z.candidate:
                    le.getItem(this.keyID).recvCandidateTimes += 1,
                    this.recvCandidate(e.candidate)
                }
            }
            ,
            e.prototype.isReady = function() {
                if (kt.Ready === this.state)
                    return !0
            }
            ,
            e.prototype.hasBlockData = function(e, t) {
                return null !== this.bitmapInfo && this.bitmapInfo.hasBlockData(e, t)
            }
            ,
            e.prototype.getFreeWindowSize = function() {
                return Lr.useSlidingWindow ? this.slidingWindow.getFreeWindowSize() : Lr.maxPieceWindowSize
            }
            ,
            e.prototype.getQos = function() {
                return this.slidingWindow.getQos()
            }
            ,
            e.prototype.deleteTimeoutPieces = function() {
                for (var e = this.slidingWindow.deleteTimeoutPieces(), t = e.length, r = 0; r < t; r++) {
                    var i = e[r];
                    ut.getInstance().setPieceChoosed(this.keyID, de.getInstance().getIndexAdapter(this.keyID).p2pToIndex(i.tsNo), i.blockNo, i.pieceNo, 1, U.P2P, !1)
                }
            }
            ,
            e.prototype.canDownload = function() {
                return Lr.useSlidingWindow ? this.slidingWindow.canDownload() && !this.busy : this.getFreeWindowSize() >= Lr.minPieceWindowSize && !this.busy
            }
            ,
            e.prototype.isNoUpload = function() {
                return !1 === this.haveUploaded
            }
            ,
            e.prototype.isBusy = function() {
                return this.busy
            }
            ,
            e.prototype.isReleased = function() {
                return this.released
            }
            ,
            e.prototype.sendBitmapRequest = function(e, t) {
                le.getItem(this.keyID).bitmapReqCount += 1,
                Ar.debug("PeerConnection", this.getLogStatus(), "sendBitmapRequest(p2pSeq:" + e + ") Update. " + this.slidingWindow.getQosLog()),
                this.sendBitmapTickDownload = Tr.getTick();
                var r = Kt.bitmapReq(this.getMsgSeq(), this.keyID, e, t);
                this.sendByChannel(r)
            }
            ,
            e.prototype.sendDataRequest = function(e, t, r, i, n) {
                var a = Tr.getTick();
                this.dataSendTickDownload = a,
                le.getItem(this.keyID).dataReqCount += n;
                var o = Kt.dataReq(this.getMsgSeq(), this.keyID, e, t, r, i, n);
                this.slidingWindow.addPiece(e, r, i, n),
                this.sendByChannel(o);
                var s = de.getInstance().getIndexAdapter(this.keyID).p2pToIndex(e);
                ut.getInstance().setPieceChoosed(this.keyID, s, r, i, n, U.P2P, !0),
                Ar.debug("PeerConnection", "peerID:" + this.peerID, "sendDataRequest [" + e + "," + r + "," + i + "," + n + "]")
            }
            ,
            e.prototype.isConnectTimeout = function() {
                var e = Tr.getTick();
                return -1 !== this.lastConnectTime && e - this.lastConnectTime > 1e3 * Lr.maxP2PConnectTimeout
            }
            ,
            e.prototype.canBeEliminatedDownload = function(e) {
                return !this.isFresh() && (this.slidingWindow.getQos() < Lr.minPeerQos ? (e.reason = ae.QosLow,
                !0) : !!this.isDataNoExchangeTimeoutDownload() && (e.reason = ae.NoDataExchange,
                !0))
            }
            ,
            e.prototype.canBeEliminatedUpload = function(e) {
                return this.isUploadDead() ? (e.reason = ae.Timeout,
                !0) : !!this.isDataNoExchangeTimeoutUpload() && (e.reason = ae.NoDataExchange,
                !0)
            }
            ,
            e.prototype.isFresh = function() {
                var e = Tr.getTick();
                return -1 !== this.connectSucTime && e - this.connectSucTime < 1e3 * Lr.maxProtectPeerTime
            }
            ,
            e.prototype.sendByebyeMsg = function() {
                var e = Kt.byebyeReq(this.getMsgSeq());
                this.sendByChannel(e)
            }
            ,
            e.prototype.releaseUpload = function() {
                this.punchUpState = x.UnKnown,
                this.sessionType &= 253
            }
            ,
            e.prototype.releaseDownload = function() {
                this.deleteAllSelectedPieces(),
                this.punchDownState = x.UnKnown,
                this.sessionType &= 254,
                this.clearBitmap()
            }
            ,
            e.prototype.release = function(e) {
                if (Ar.debug("PeerConnection", this.getLogStatus(), "release (stype:" + e + ") "),
                e & ie.Up && this.releaseUpload(),
                e & ie.Down && this.releaseDownload(),
                void 0 === e && (this.releaseUpload(),
                this.releaseDownload()),
                0 === this.sessionType) {
                    if (this.released)
                        return;
                    this.establishChannelFinish = !1,
                    this.released = !0,
                    this.dataChannel && (this.dataChannel.close(),
                    Ar.debug("PeerConnection", this.getLogStatus(), "release DataChannel"),
                    this.dataChannel = null),
                    "closed" !== this.peerConnection.connectionState && (this.peerConnection.close(),
                    this.peerConnection = null,
                    Ar.debug("PeerConnection", this.getLogStatus(), "release peerConnection"))
                }
            }
            ,
            e.prototype.deleteAllSelectedPieces = function() {
                var e, t, r = this.slidingWindow.getAllDownloadingPiece();
                this.slidingWindow.deleteAllDownloadingPiece(),
                Ar.debug("PeerConnection", this.getLogStatus(), "deleteAllSelectedPieces : allPiece.length = " + r.length);
                var i = de.getInstance().getIndexAdapter(this.keyID);
                try {
                    for (var n = C(r), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value
                          , s = i.p2pToIndex(o.tsNo);
                        ut.getInstance().setPieceChoosed(this.keyID, s, o.blockNo, o.pieceNo, 1, U.P2P, !1)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
            }
            ,
            e.prototype.isDataNoExchangeTimeoutDownload = function() {
                var e = Tr.getTick();
                return e - this.dataRecvTickDownload > 1e3 * Lr.maxP2PRecvDataTimeOut && e - this.sendBitmapTickDownload > 1e3 * Lr.maxP2PRecvDataTimeOut
            }
            ,
            e.prototype.isDataNoExchangeTimeoutUpload = function() {
                return Tr.getTick() - this.dataRecvTickUpload >= 1e3 * Lr.maxP2POfflineSendDataTimeOut
            }
            ,
            e.prototype.uploadReq = function() {
                var e = Kt.uploadReq(this.getMsgSeq(), this.serverInterface.getUin(), this.keyID);
                this.sendByChannel(e)
            }
            ,
            e.prototype.downloadReq = function() {
                if (this.isEstablishChannel()) {
                    Ar.info("PeerConnection", this.getLogStatus(), this.serverInterface.getUin() + " found " + this.peerID + " ,send downloadReq"),
                    this.punchDownState = x.Ing;
                    var e = Kt.downloadReq(this.getMsgSeq(), this.serverInterface.getUin(), this.keyID);
                    this.sendByChannel(e)
                } else
                    Ar.info("PeerConnection", this.getLogStatus(), this.serverInterface.getUin() + " found " + this.peerID + " ,add need2download"),
                    this.needDownload = !0
            }
            ,
            e.prototype.isEstablishChannel = function() {
                return this.establishChannelFinish
            }
            ,
            e.prototype.recvOffer = function(e) {
                this.addSessionType(ie.Up),
                this.createAnswer(e)
            }
            ,
            e.prototype.createOffer = function() {
                var e = this;
                if (!this.peerConnection)
                    return !1;
                var t = Tr.getTick();
                this.lastConnectTime = t,
                this.peerConnection.createOffer().then((function(t) {
                    Ar.debug("PeerConnection", e.getLogStatus(), "CreateOffer " + e.serverInterface.getUin() + " to " + e.peerID),
                    e.peerConnection.setLocalDescription(new RTCSessionDescription(t)).catch((function() {
                        e.punchDownState = x.End
                    }
                    )),
                    e.punchDownState = x.Ing;
                    var r = ee.createOfferReq(e.serverInterface, t, e.peerID, e.keyID, ie.Down);
                    e.sendMsg(e.peerID, JSON.stringify(r)),
                    le.getItem(e.keyID).sendOfferTimes += 1
                }
                )).catch((function(t) {
                    e.onError(),
                    Ar.error("PeerConnection", e.getLogStatus(), "send offer Error: " + t)
                }
                ))
            }
            ,
            e.prototype.onError = function() {
                this.punchDownState === x.Ing ? (this.punchDownState = x.End,
                this.release(ie.Down)) : this.punchUpState === x.Ing && (this.punchUpState = x.End,
                this.release(ie.Up))
            }
            ,
            e.prototype.createAnswer = function(e) {
                var t, r, i, n = this;
                if (this.peerConnection) {
                    -1 !== (null === (i = null == e ? void 0 : e.sdp) || void 0 === i ? void 0 : i.indexOf("\na=extmap-allow-mixed")) && (e.sdp = e.sdp.split("\n").filter((function(e) {
                        return "a=extmap-allow-mixed" !== e.trim()
                    }
                    )).join("\n")),
                    this.peerConnection.setRemoteDescription(new RTCSessionDescription(e)),
                    this.hasSetRemoteDes = !0;
                    try {
                        for (var a = C(this.candidateCache), o = a.next(); !o.done; o = a.next()) {
                            var s = o.value;
                            this.recvCandidate(s)
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            o && !o.done && (r = a.return) && r.call(a)
                        } finally {
                            if (t)
                                throw t.error
                        }
                    }
                    this.candidateCache = [],
                    this.peerConnection.createAnswer().then((function(e) {
                        Ar.debug("PeerConnection", n.getLogStatus(), "createAnswer " + n.serverInterface.getUin() + " to " + n.peerID),
                        n.peerConnection.setLocalDescription(new RTCSessionDescription(e)),
                        n.punchUpState = x.Ing;
                        var t = ee.createAnswerReq(n.serverInterface, e, n.peerID, n.keyID, ie.Up, 0);
                        n.sendMsg(n.peerID, JSON.stringify(t)),
                        le.getItem(n.keyID).sendAnswerTimes += 1
                    }
                    )).catch((function(e) {
                        n.punchUpState = x.End,
                        n.onError(),
                        Ar.error("PeerConnection", n.getLogStatus(), "createAnswer error: " + e)
                    }
                    ))
                }
            }
            ,
            e.prototype.handleAnswer = function(e) {
                e.busy && 1 === e.busy ? (this.release(ie.Down),
                le.getItem(this.keyID).recvAnswerButRejectTimes += 1) : this.recvAnswer(e.answer)
            }
            ,
            e.prototype.recvAnswer = function(e) {
                var t, r, i;
                if (this.state = kt.RecvAnswer,
                this.peerConnection) {
                    this.hasSetRemoteDes = !0,
                    -1 !== (null === (i = null == e ? void 0 : e.sdp) || void 0 === i ? void 0 : i.indexOf("\na=extmap-allow-mixed")) && (e.sdp = e.sdp.split("\n").filter((function(e) {
                        return "a=extmap-allow-mixed" !== e.trim()
                    }
                    )).join("\n")),
                    this.peerConnection.setRemoteDescription(new RTCSessionDescription(e));
                    try {
                        for (var n = C(this.candidateCache), a = n.next(); !a.done; a = n.next()) {
                            var o = a.value;
                            this.recvCandidate(o)
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            a && !a.done && (r = n.return) && r.call(n)
                        } finally {
                            if (t)
                                throw t.error
                        }
                    }
                    this.candidateCache = []
                }
            }
            ,
            e.prototype.recvCandidate = function(e) {
                var t = new RTCIceCandidate(e);
                if (this.peerConnection)
                    if (this.hasSetRemoteDes)
                        try {
                            this.peerConnection.addIceCandidate(t)
                        } catch (e) {
                            var r = typeof t;
                            Ar.error("PeerConnection", this.getLogStatus(), "recvCandidate error1: [" + e.name + ":" + e.message + "] candidate:" + t + ",type:" + r),
                            re.getInstance().supportWebRTC = V.RTC_CALL_FAIL,
                            this.dataChannelCallback.onPeerWebRTCError(),
                            Ar.info("PeerConnection", this.getLogStatus(), "stop p2p")
                        }
                    else
                        this.candidateCache.push(e)
            }
            ,
            e.prototype.onDataChannelPeerConnection = function(e) {
                var t;
                Ar.info("PeerConnection", this.getLogStatus(), "Channel established.up"),
                this.punchUpState = x.End,
                this.establishChannelFinish = !0,
                this.dataChannel = e.channel,
                this.bindDataChannel(this.dataChannel),
                (null === (t = this.dataChannelCallback) || void 0 === t ? void 0 : t.onPeerConnectedUp) && this.dataChannelCallback.onPeerConnectedUp(this),
                this.connectSucTime = Tr.getTick(),
                this.needDownload && this.downloadReq()
            }
            ,
            e.prototype.onIceConnectionStateChangePeerConnection = function(e) {
                var t = e.currentTarget.iceConnectionState;
                if (Ar.debug("PeerConnection", this.getLogStatus(), "Changing connection state:" + t),
                "connected" === t)
                    ;
                else if ("disconnected" === t || "failed" === t)
                    try {
                        this.release(ie.Up | ie.Down),
                        Ar.debug("PeerConnection", this.getLogStatus(), "Connection closed by")
                    } catch (e) {
                        Ar.debug("PeerConnection", this.getLogStatus(), "Connection already closed")
                    }
                else
                    "closed" === t && Ar.info("PeerConnection", this.getLogStatus(), "Connection closed")
            }
            ,
            e.prototype.handleNullPack = function(e) {
                Ar.debug("PeerConnection", this.getLogStatus(), "recv null pack. " + oe.getReasonStr(e)),
                this.busy = !0
            }
            ,
            e.prototype.handleDownloadRes = function(e, t, r, i, n) {
                this.dataChannelCallback && (Ar.info("PeerConnection", this.getLogStatus(), "handleDownloadRes Channel established.down2. ok:" + i + " uin:" + t + " keyID:" + r + " reason:" + n),
                1 === i ? (this.punchDownState = x.End,
                this.connectSucTime = Tr.getTick(),
                this.addSessionType(ie.Down),
                this.dataChannelCallback.onPeerConnectedDown && this.dataChannelCallback.onPeerConnectedDown(this)) : 0 === i && (this.punchDownState = x.UnKnown,
                this.dataChannelCallback.onPeerDisconnectedDown && this.dataChannelCallback.onPeerDisconnectedDown(this, !0)))
            }
            ,
            e.prototype.handleDataResponse = function(e, t, r, i, n, a, o) {
                if (o)
                    if (le.getItem(this.keyID).p2pDownloadBytes += o.byteLength,
                    e !== this.keyID || t < 0 || i < 0 || n < 0)
                        le.getItem(this.keyID).p2pKeyIDWrongByte += o.byteLength;
                    else if (de.getInstance().getIndexAdapter(e)) {
                        var s = de.getInstance().getIndexAdapter(e).p2pToIndex(t)
                          , l = ut.getInstance();
                        if (r === l.getFileSize(e, s, 1)[0]) {
                            le.getItem(this.keyID).dataRspCount += Math.ceil(o.byteLength / J.PIECE_SIZE);
                            var c = Tr.getTick();
                            this.dataRecvTickDownload = c;
                            var h = l.getChecksum(e, s, i)
                              , u = !0;
                            l.getAllowP2P(e, s) ? 0 === h ? l.setChecksum(e, s, i, a) : h !== a && (le.getItem(this.keyID).p2pRspFailByte += o.byteLength,
                            le.getItem(this.keyID).dataRspFailedCount += 1,
                            l.resetBlockData(e, s, i),
                            l.addCheckFail(e, s),
                            this.sendWrongData(e, t, i, n),
                            u = !1,
                            Ar.warn("PeerConnection", this.getLogStatus(), "CheckFailed KeyID:" + e + ",blockID:" + i + ",localcheck:" + h + ",check:" + a),
                            Ar.uploadLog(ne.P2PDataRspFailed, Lr.uploadLogRate1)) : (le.getItem(this.keyID).p2pNotAllowByte += o.byteLength,
                            u = !1),
                            u && (l.writePieceData(e, s, i, n, o, U.P2P),
                            this.dataChannelCallback.onPeerDataRecv && this.dataChannelCallback.onPeerDataRecv(this.getPeerID(), t, i, n)),
                            Ar.debug("PeerConnection", this.getLogStatus(), "recv data piece " + t + "_" + i + "_" + n + "_" + o.byteLength);
                            for (var d = n; d < n + Math.ceil(o.byteLength / J.PIECE_SIZE); d++)
                                this.slidingWindow.delPiece(t, i, d, Sr.PIECE_COMPLETE),
                                l.setPieceChoosed(this.keyID, s, i, d, 1, U.P2P, !1)
                        } else
                            le.getItem(this.keyID).p2pFileSizeWrongBtye += o.byteLength
                    }
            }
            ,
            e.prototype.handleDataRequest = function(e, t, r, i, n, a, o) {
                var s = this;
                if (t && r > -1 && n > -1 && a > -1 && o > -1) {
                    if (!Oe.getInstance().canUploadData()) {
                        var l = Kt.nullPack(e, t, ae.BusyInEmergencyTime.code);
                        return void this.sendByChannel(l)
                    }
                    this.dataRecvTickUpload = Tr.getTick();
                    var c = ut.getInstance()
                      , h = de.getInstance().getIndexAdapter(t).p2pToIndex(r)
                      , u = c.getChecksum(t, h, n);
                    if (c.getFileSize(t, h, 1)[0] !== i || 0 === u)
                        return;
                    for (var d = function(l) {
                        c.readPiecesData(t, h, n, a + l, Math.min(o - l, Lr.sendPieceNum)).then((function(o) {
                            if (Ar.debug("PeerConnection", s.getLogStatus(), "send data piece " + h.p2p + "_" + n + "_" + l + "_" + o.byteLength),
                            null !== o) {
                                var c = Kt.dataResp(e, t, r, i, n, a + l, u, o);
                                s.haveUploaded = !0,
                                0 !== s.sendByChannel(c) && (le.getItem(s.keyID).p2pUploadByte += o.byteLength)
                            }
                        }
                        ))
                    }, f = 0; f < o; f += Lr.sendPieceNum)
                        d(f)
                }
            }
            ,
            e.prototype.handleWrongData = function(e, t, r, i) {
                Ar.info("PeerConnection", this.getLogStatus(), "handleWrongData p2pseq:" + t + " blockID:" + r + " piceceID:" + i + "."),
                le.getItem(e).p2pUploadWrongdataCount += 1;
                var n = de.getInstance().getIndexAdapter(e).p2pToIndex(t);
                ut.getInstance().handleP2PWrongData(e, n),
                Ar.uploadLog(ne.P2PUploadCheckFailed, Lr.uploadLogRate3)
            }
            ,
            e.prototype.sendWrongData = function(e, t, r, i) {
                var n = Kt.wrongData(this.getMsgSeq(), e, t, r, i);
                this.sendByChannel(n)
            }
            ,
            e.prototype.handleBitmapResponse = function(e, t, r, i, n, a, o) {
                if (t && r > -1 && i > -1 && n) {
                    Ar.debug("PeerConnection", this.getLogStatus(), "handleBitmapResponse Update seq:" + e + " busy:" + a);
                    var s = Tr.getTick();
                    this.recvBitmapTickDownload = s,
                    this.updateBitmapInfo(r, i, n),
                    void 0 !== o && this.checkFileSize(t, r, i, o),
                    this.busy = !!a,
                    le.getItem(this.keyID).bitmapRspCount += 1
                }
            }
            ,
            e.prototype.updateBitmapInfo = function(e, t, r) {
                this.bitmapInfo && this.bitmapInfo.setBitmapInfo(e, t, r)
            }
            ,
            e.prototype.checkFileSize = function(e, t, r, i) {
                var n = de.getInstance().getIndexAdapter(e).p2pToIndex(t);
                ut.getInstance().checkFileSize(e, n, r, i)
            }
            ,
            e.prototype.handleBitmapRequest = function(e, t, r, i) {
                var n;
                if (t && r > -1 && i > -1) {
                    Ar.debug("PeerConnection", this.getLogStatus(), "handleBitmapRequest seq:" + e),
                    this.recvBitmapTickUpload = Tr.getTick();
                    var a = null === (n = de.getInstance().getIndexAdapter(t)) || void 0 === n ? void 0 : n.p2pToIndex(r);
                    if (a) {
                        var o = ut.getInstance().getTsBitmap(t, a, i)
                          , s = ut.getInstance().getFileSize(t, a, i)
                          , l = 0;
                        Oe.getInstance().canUploadData() || (l = 1);
                        var c = Kt.bitmapResp(e, t, r, o.length, o, l, s);
                        this.sendByChannel(c)
                    }
                }
            }
            ,
            e.prototype.clearBitmap = function() {
                if (null !== this.bitmapInfo) {
                    for (; 0 !== this.bitmapInfo.arrayBitmap.length; )
                        this.bitmapInfo.arrayBitmap.pop();
                    this.bitmapInfo = null
                }
            }
            ,
            e.prototype.sendByChannel = function(e) {
                if (!this.dataChannel)
                    return 0;
                try {
                    this.dataChannel.send(e)
                } catch (e) {}
            }
            ,
            e.prototype.onErrorDataChannel = function(e) {
                Ar.warn("PeerConnection", this.getLogStatus(), "Error on data channel, error detail: " + e.error.errorDetail + ", error message: " + e.error.message)
            }
            ,
            e.prototype.dealMsgData = function(e) {
                this.sessionType === ie.Down && this.state !== kt.Ready && (this.state = kt.Ready);
                var t = Kt.recvDataUnserialize(e);
                if (null == t ? void 0 : t.cmd)
                    switch (t.cmd) {
                    case Rt:
                        this.handleBitmapRequest(t.seq, t.keyID, t.p2pSeq, t.length);
                        break;
                    case At:
                        this.handleBitmapResponse(t.seq, t.keyID, t.p2pSeq, t.length, t.bmArray, t.busy, t.fArray);
                        break;
                    case _t:
                        this.handleDataRequest(t.seq, t.keyID, t.p2pSeq, t.fileSize, t.blockID, t.pieceID, t.reqNum);
                        break;
                    case xt:
                        this.handleDataResponse(t.keyID, t.p2pSeq, t.fileSize, t.blockID, t.pieceID, t.check, t.data);
                        break;
                    case Ot:
                        this.handleWrongData(t.keyID, t.p2pSeq, t.blockID, t.pieceID);
                    case Nt:
                        this.handleDownloadReq(t.seq);
                        break;
                    case Gt:
                        this.handleDownloadRes(t.seq, t.uin, t.keyID, t.ok, t.reason);
                        break;
                    case Bt:
                        break;
                    case Ht:
                        this.handleNullPack(t.seq);
                        break;
                    default:
                        Ar.warn("PeerConnection", this.getLogStatus(), "recv unknow msg " + t.cmd)
                    }
            }
            ,
            e.prototype.onMessageDataChannel = function(e) {
                var t = this;
                if (e.data instanceof Blob) {
                    var r = new FileReader;
                    r.onload = function(e) {
                        return t.dealMsgData(e.target.result)
                    }
                    ,
                    r.readAsArrayBuffer(e.data)
                } else
                    e.data instanceof ArrayBuffer ? this.dealMsgData(e.data) : Ar.error("PeerConnection", this.getLogStatus(), "not support type of event.data")
            }
            ,
            e.prototype.handleUploadReq = function() {}
            ,
            e.prototype.handleUploadRes = function() {}
            ,
            e.prototype.handleDownloadReq = function(e) {
                Ar.info("PeerConnection", this.getLogStatus(), "handleDownloadReq channel established.up2");
                var t = !1;
                Oe.getInstance().canUploadData() && (t = !0);
                var r = 0;
                t ? (this.punchUpState = x.Ing,
                r = 1) : this.punchUpState = x.UnKnown;
                var i = Kt.downloadRes(e, this.serverInterface.getUin(), this.keyID, r, "");
                this.sendByChannel(i),
                t && (this.addSessionType(ie.Up),
                this.connectSucTime = Tr.getTick(),
                this.dataChannelCallback.onPeerConnectedUp && this.dataChannelCallback.onPeerConnectedUp(this))
            }
            ,
            e.prototype.onOpenDataChannel = function() {
                var e;
                this.punchDownState === x.Ing && (Ar.info("PeerConnection", this.getLogStatus(), "Channel established.down"),
                this.punchDownState = x.End,
                this.establishChannelFinish = !0,
                (null === (e = this.dataChannelCallback) || void 0 === e ? void 0 : e.onPeerConnectedDown) && this.dataChannelCallback.onPeerConnectedDown(this),
                this.connectSucTime = Tr.getTick())
            }
            ,
            e.prototype.onCloseDataChannel = function() {
                Ar.debug("PeerConnection", this.getLogStatus(), "Channel closed."),
                this.establishChannelFinish = !1
            }
            ,
            e.prototype.getMsgSeq = function() {
                return this.msgSeq += 1,
                this.msgSeq >= 65536 && (this.msgSeq = 0),
                this.msgSeq
            }
            ,
            e.prototype.getLogStatus = function() {
                return "stype:" + this.sessionType + ",peerID:" + this.peerID + ",up_state:" + this.punchUpState + ",down_state:" + this.punchDownState
            }
            ,
            e.prototype.addSessionType = function(e) {
                this.sessionType |= e
            }
            ,
            e.prototype.isUploadDead = function() {
                return Tr.getTick() - this.recvBitmapTickUpload >= 1e3 * Lr.p2pPeerUploadMsgDead
            }
            ,
            e.prototype.createPeerConnect = function(e) {
                var t = null;
                try {
                    t = new RTCPeerConnection(e)
                } catch (e) {
                    return null
                }
                return t.onicecandidate = this.onIceCandidatePeerConnection.bind(this),
                t.oniceconnectionstatechange = this.onIceConnectionStateChangePeerConnection.bind(this),
                t.ondatachannel = this.onDataChannelPeerConnection.bind(this),
                t
            }
            ,
            e.prototype.bindDataChannel = function(e) {
                e.onerror = this.onErrorDataChannel.bind(this),
                e.onmessage = this.onMessageDataChannel.bind(this),
                e.onopen = this.onOpenDataChannel.bind(this),
                e.onclose = this.onCloseDataChannel.bind(this)
            }
            ,
            e.prototype.getStype = function() {
                var e = 0;
                return this.punchDownState === x.Ing && (e |= ie.Down),
                this.punchUpState === x.Ing && (e & ie.Down ? (e |= ie.Up,
                Ar.warn("PeerConnection", this.getLogStatus(), "punch in up and down")) : e = ie.Up),
                e
            }
            ,
            e.prototype.onIceCandidatePeerConnection = function(t) {
                if (t.candidate) {
                    Ar.debug("PeerConnection", this.getLogStatus(), "onIceCandidatePeerConnection");
                    var r = this.getStype()
                      , i = ee.createCandidateReq(this.serverInterface, t.candidate, this.peerID, this.keyID, r)
                      , n = e.isPublicAddress(e.getAddressFromCandidate(t.candidate.candidate));
                    (Lr.relayLocalCandidate || n) && (this.sendMsg(this.peerID, JSON.stringify(i)),
                    le.getItem(this.keyID).sendCandidateTimes += 1),
                    n && this.sessionType === ie.Down && this.firstICE && (le.getItem(this.keyID).hasPublicAddrTimes += 1,
                    this.firstICE = !1)
                }
            }
            ,
            e.prototype.sendMsg = function(e, t) {
                this.serverInterface.forward(e, t)
            }
            ,
            e.prototype.getICEServersConfig = function(e) {
                var t, r, i = [];
                if ("[object Array]" === Object.prototype.toString.call(e))
                    try {
                        for (var n = C(e), a = n.next(); !a.done; a = n.next()) {
                            var o = a.value;
                            i.push({
                                urls: "stun:" + o.ip + ":" + o.port
                            })
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            a && !a.done && (r = n.return) && r.call(n)
                        } finally {
                            if (t)
                                throw t.error
                        }
                    }
                return i
            }
            ,
            Object.defineProperty(e.prototype, "serverInterface", {
                get: function() {
                    return ut.getInstance().getTaskType(this.keyID) === B.Live ? ur.getInstance() : hr.getInstance()
                },
                enumerable: !1,
                configurable: !0
            }),
            e
        }(), Yt = function() {
            function e(e, t, r, i) {
                this.keyID = e,
                this.peerContainerListener = t,
                this.idlePeerPool = [],
                this.connectingPeers = [],
                this.connectedPeers = [],
                this.sparePeerMap = new Map,
                this.blackPeerPool = new Map,
                this.peerPoolTime = new Map,
                this.stype = r,
                this.peerContainer = i
            }
            return e.prototype.setListener = function(e) {
                this.peerContainerListener = e
            }
            ,
            e.prototype.onRecv = function(e) {
                var t = !0;
                do {
                    if (e.type === Z.bye) {
                        this.onRecvBye(e);
                        break
                    }
                    if (e.dst_uin !== this.serverInterface.getUin()) {
                        this.onRecvUinWrong(e);
                        break
                    }
                    t = !1
                } while (0);
                return t
            }
            ,
            e.prototype.changeConnecting2Connected = function(e) {
                if (e) {
                    for (var t = 0; t < this.connectingPeers.length; t++)
                        if (this.connectingPeers[t].getPeerID() === e.getPeerID()) {
                            this.connectingPeers.splice(t, 1);
                            break
                        }
                    this.connectedPeers.push(e)
                }
            }
            ,
            e.prototype.insertPeer2Connected = function(e) {
                e && this.connectedPeers.push(e)
            }
            ,
            e.prototype.insertPeersIntoPeerPool = function(e) {
                for (var t = e.length, r = 0; r < t; r++)
                    this.insertPeerIntoPeerPool(e[r])
            }
            ,
            e.prototype.getPeerPoolLen = function() {
                return this.idlePeerPool.length
            }
            ,
            e.prototype.getConnectingPeerLen = function() {
                return this.connectingPeers.length
            }
            ,
            e.prototype.getConnectedPeerLen = function() {
                return this.connectedPeers.length
            }
            ,
            e.prototype.onPeerDataRecv = function(e, t, r, i) {
                var n;
                (null === (n = this.peerContainerListener) || void 0 === n ? void 0 : n.onPeerDataPingPang) && this.peerContainerListener.onPeerDataPingPang(e, t, r, i)
            }
            ,
            e.prototype.onPeerConnectedDown = function(e) {
                var t;
                this.stype === ie.Down ? (this.changeConnecting2Connected(e),
                (null === (t = this.peerContainerListener) || void 0 === t ? void 0 : t.onPeerConnectSuccess) && (this.peerContainerListener.onPeerConnectSuccess(e.getPeerID()),
                le.getItem(this.keyID).natPunchOKCount += 1,
                le.getItem(this.keyID).natPunchElapse += performance.now() - this.punchTime)) : this.peerContainer && this.peerContainer.insertPeer2ConnectedDown(e),
                Ar.info("PeerContainer", "", "peerID:" + e.getPeerID() + " connect down successfully")
            }
            ,
            e.prototype.onPeerConnectedUp = function(e) {
                var t;
                this.stype === ie.Up ? (this.changeConnecting2Connected(e),
                (null === (t = this.peerContainerListener) || void 0 === t ? void 0 : t.onPeerConnectSuccess) && this.peerContainerListener.onPeerConnectSuccess(e.getPeerID())) : this.peerContainer && this.peerContainer.insertPeer2ConnectedUp(e),
                Ar.info("PeerContainer", "", "PeerContainer peerID:" + e.getPeerID() + " connect up successfully")
            }
            ,
            e.prototype.onPeerDisconnectedDown = function(e, t) {
                var r = ae.Exit;
                t && (r = ae.Refuse),
                this.stype === ie.Down ? (this.removeFromConnecting(e),
                this.addPeer2Recycle(e, r)) : this.stype === ie.Up && this.peerContainer && (this.peerContainer.removePeerFromConnectingDown(e),
                this.peerContainer.addPeer2RecycleDown(e, r))
            }
            ,
            e.prototype.onPeerDisconnectedUp = function(e) {
                this.stype === ie.Up ? this.removeFromConnecting(e) : this.stype === ie.Down && this.peerContainer && this.peerContainer.removePeerFromConnectingUp(e)
            }
            ,
            e.prototype.onPeerWebRTCError = function() {
                var e;
                (null === (e = null == this ? void 0 : this.peerContainerListener) || void 0 === e ? void 0 : e.onPeerWebRTCError) && this.peerContainerListener.onPeerWebRTCError()
            }
            ,
            e.prototype.getPeer = function(e) {
                var t = null;
                do {
                    var r = this.findConnectingPeer(e);
                    if (-1 === r) {
                        if (-1 === (r = this.findConnectedPeer(e)))
                            break;
                        t = this.connectedPeers[r]
                    } else
                        t = this.connectingPeers[r]
                } while (0);
                return t
            }
            ,
            e.prototype.getEstablishPeer = function(e) {
                var t = null;
                do {
                    var r = this.findConnectingPeer(e);
                    if (-1 === r) {
                        if (-1 === (r = this.findConnectedPeer(e)))
                            break;
                        if (null == (t = this.connectedPeers[r]) ? void 0 : t.isEstablishChannel())
                            break;
                        t = null
                    } else {
                        if (null == (t = this.connectingPeers[r]) ? void 0 : t.isEstablishChannel())
                            break;
                        t = null
                    }
                } while (0);
                return t
            }
            ,
            e.prototype.getSpareCount = function() {
                return this.sparePeerMap.size
            }
            ,
            e.prototype.getBlackCount = function() {
                return this.blackPeerPool.size
            }
            ,
            e.prototype.release = function() {
                var e, t, r, i;
                this.idlePeerPool = [];
                try {
                    for (var n = C(this.connectingPeers), a = n.next(); !a.done; a = n.next()) {
                        a.value.release()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                this.connectingPeers = [];
                try {
                    for (var o = C(this.connectedPeers), s = o.next(); !s.done; s = o.next()) {
                        s.value.release()
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (i = o.return) && i.call(o)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                this.connectedPeers = [],
                this.peerPoolTime = new Map,
                this.sparePeerMap = new Map,
                this.blackPeerPool = new Map,
                this.peerContainerListener = void 0
            }
            ,
            e.prototype.onRecvNoFoundDstUin = function(e, t) {
                Ar.info("PeerConnection", this.getLogStatus(), "server no found dstUin.  srcUin:" + t.src_uin + " dstUin:" + t.dst_uin + " keyID:" + t.keyid);
                var r = this.removeFromConnectingById(e);
                r && this.addPeer2Recycle(r, ae.PeerNoInServer)
            }
            ,
            e.prototype.removeFromConnecting = function(e) {
                if (null !== e)
                    for (var t = 0; t < this.connectingPeers.length; t++)
                        if (this.connectingPeers[t].getPeerID() === e.getPeerID()) {
                            this.connectingPeers.splice(t, 1);
                            break
                        }
            }
            ,
            e.prototype.removeFromConnectingById = function(e) {
                for (var t = null, r = 0; r < this.connectingPeers.length; r++)
                    if (this.connectingPeers[r].getPeerID() === e) {
                        t = this.connectingPeers[r],
                        this.connectingPeers.splice(r, 1);
                        break
                    }
                return t
            }
            ,
            e.prototype.removeFromConnected = function(e) {
                if (null !== e)
                    for (var t = 0; t < this.connectedPeers.length; t++)
                        if (this.connectedPeers[t].getPeerID() === e.getPeerID()) {
                            this.connectedPeers.splice(t, 1);
                            break
                        }
            }
            ,
            e.prototype.getLogStatus = function() {
                return "stype:" + this.stype
            }
            ,
            e.prototype.findPeerPool = function(e) {
                for (var t = this.idlePeerPool.length, r = 0; r < t; r++)
                    if (this.idlePeerPool[r] === e)
                        return r;
                return -1
            }
            ,
            e.prototype.findConnectingPeer = function(e) {
                for (var t = this.connectingPeers.length, r = 0; r < t; r++)
                    if (this.connectingPeers[r].getPeerID() === e)
                        return r;
                return -1
            }
            ,
            e.prototype.findConnectedPeer = function(e) {
                for (var t = this.connectedPeers.length, r = 0; r < t; r++)
                    if (this.connectedPeers[r].getPeerID() === e)
                        return r;
                return -1
            }
            ,
            e.prototype.createPeerConnection = function(e, t) {
                var r = {
                    onPeerConnectedDown: this.onPeerConnectedDown.bind(this),
                    onPeerConnectedUp: this.onPeerConnectedUp.bind(this),
                    onPeerDisconnectedDown: this.onPeerDisconnectedDown.bind(this),
                    onPeerDisconnectedUp: this.onPeerDisconnectedUp.bind(this),
                    onPeerDataRecv: this.onPeerDataRecv.bind(this),
                    onPeerWebRTCError: this.onPeerWebRTCError.bind(this)
                }
                  , i = this.taskType === B.Vod ? J.vodIceServer : J.liveIceServer
                  , n = new Wt(e,this.keyID,i,t,r);
                return n.update(),
                this.punchTime = performance.now(),
                t === ie.Down && (le.getItem(this.keyID).natPunchCount += 1),
                n
            }
            ,
            e.prototype.getOppositeSType = function(e) {
                var t = ie.Up;
                return e === ie.Down ? t = ie.Up : e === ie.Up && (t = ie.Down),
                t
            }
            ,
            Object.defineProperty(e.prototype, "serverInterface", {
                get: function() {
                    return this.taskType === B.Live ? ur.getInstance() : hr.getInstance()
                },
                enumerable: !1,
                configurable: !0
            }),
            Object.defineProperty(e.prototype, "taskType", {
                get: function() {
                    return ut.getInstance().getTaskType(this.keyID)
                },
                enumerable: !1,
                configurable: !0
            }),
            e.prototype.isInSpare = function(e) {
                return !!this.sparePeerMap.get(e)
            }
            ,
            e.prototype.isInBlack = function(e) {
                return !!this.blackPeerPool.get(e)
            }
            ,
            e.prototype.insertPeerIntoPeerPool = function(e) {
                if (null != e && !this.isInBlack(e) && !this.isInSpare(e) && !(this.findConnectingPeer(e) >= 0 || this.findConnectedPeer(e) >= 0)) {
                    var t = this.findPeerPool(e);
                    t >= 0 && this.idlePeerPool.splice(t, 1),
                    this.peerPoolTime.set(e, performance.now()),
                    this.idlePeerPool.push(e)
                }
            }
            ,
            e.prototype.onRecvBye = function(e) {
                Ar.info("PeerConnection", this.getLogStatus(), "recv bye. src_uin:" + e.src_uin + " dst_uin:" + e.dst_uin + " reason:" + e.reason + " keyid:" + e.keyid);
                var t = this.getPeer(e.src_uin);
                t && this.addPeer2Recycle(t, e.reason)
            }
            ,
            e.prototype.onRecvUinWrong = function(e) {
                Ar.info("PeerConnection", this.getLogStatus(), "dstUin is not same as me.  srcUin:" + e.src_uin + " dstUin:" + e.dst_uin + " keyID:" + e.keyid);
                var t = this.getPeer(e.src_uin);
                t && this.addPeer2Recycle(t, ae.DstUinIsWrong);
                var r = this.getOppositeSType(e.stype)
                  , i = ae.DstUinIsWrong;
                Ar.info("PeerConnection", this.getLogStatus(), e.dst_uin + ",stype:" + e.stype + "):send bye " + i.reason),
                this.serverInterface.sendBye2Client(e.src_uin, r, i.code)
            }
            ,
            e
        }(), Qt = function(e) {
            function t(t, r, i) {
                return e.call(this, t, r, ie.Up, i) || this
            }
            return E(t, e),
            t.prototype.release = function() {
                Ar.info("PeerUpPool", "", "release."),
                e.prototype.release.call(this)
            }
            ,
            t.prototype.onRecv = function(t) {
                if (!t)
                    return !1;
                if (e.prototype.onRecv.call(this, t))
                    return !0;
                if (!this.isValidMsg(t))
                    return !1;
                var r = this.getPeer(t.src_uin);
                if (!r) {
                    if (this.peerContainer && (r = this.peerContainer.getEstablishPeerFromPeersDown(t.src_uin)),
                    Oe.getInstance().canConnectUpload() && !r)
                        r = this.createPeerConnection(t.src_uin, ie.Up);
                    else if (!r && (Ar.info("PeerUpPool", "", "too busy to connect upload peer."),
                    t.type === Z.offer)) {
                        le.getItem(this.keyID).recvOfferTimes += 1;
                        var i = ee.createAnswerReq(this.serverInterface, void 0, t.src_uin, this.keyID, ie.Up, 1);
                        this.serverInterface.forward(t.src_uin, JSON.stringify(i)),
                        le.getItem(this.keyID).sendAnswerTimes += 1
                    }
                    r && this.connectingPeers.push(r)
                }
                return r && r.onRecv(t),
                !0
            }
            ,
            t.prototype.eliminateConnectingPeer = function() {
                var e, t, r, i;
                if (0 !== this.connectingPeers.length) {
                    var n = [];
                    try {
                        for (var a = C(this.connectingPeers), o = a.next(); !o.done; o = a.next()) {
                            var s = o.value;
                            s.isReleased() ? n.push({
                                peer: s,
                                reason: ae.ConnectFailed
                            }) : s.isConnectTimeout() && n.push({
                                peer: s,
                                reason: ae.ConnectTimeout
                            })
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            o && !o.done && (t = a.return) && t.call(a)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
                    try {
                        for (var l = C(n), c = l.next(); !c.done; c = l.next()) {
                            var h = c.value;
                            this.addPeer2Recycle(h.peer, h.reason),
                            this.removeFromConnecting(h.peer)
                        }
                    } catch (e) {
                        r = {
                            error: e
                        }
                    } finally {
                        try {
                            c && !c.done && (i = l.return) && i.call(l)
                        } finally {
                            if (r)
                                throw r.error
                        }
                    }
                }
            }
            ,
            t.prototype.eliminateConnectedPeer = function() {
                var e, t, r, i, n = [];
                try {
                    for (var a = C(this.connectedPeers), o = a.next(); !o.done; o = a.next()) {
                        var s = o.value
                          , l = {
                            reason: ae.UnKnown
                        };
                        s && (s.isReleased() && n.push({
                            peer: s,
                            reason: ae.ConnectFailed
                        }),
                        s.canBeEliminatedUpload(l) && n.push({
                            peer: s,
                            reason: l.reason
                        }))
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        o && !o.done && (t = a.return) && t.call(a)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                try {
                    for (var c = C(n), h = c.next(); !h.done; h = c.next()) {
                        var u = h.value
                          , d = (s = u.peer,
                        u.reason);
                        this.addPeer2Recycle(s, d),
                        this.removeFromConnected(s)
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        h && !h.done && (i = c.return) && i.call(c)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
            }
            ,
            t.prototype.addPeer2Recycle = function(e, t) {
                e && (Ar.debug("PeerConnection", this.getLogStatus(), "addPeer2Recycle " + e.getPeerID() + " reason:" + t.reason + " stype:" + this.stype + " Connecting:" + this.connectingPeers.length + " Connected:" + this.connectedPeers.length + " Spare:" + this.sparePeerMap.size + " Black:" + this.blackPeerPool.size),
                e.release(this.stype),
                this.isReasonShouldAddBlack() ? this.blackPeerPool.set(e.getPeerID(), performance.now()) : this.isReasonShouldAddSpare() && this.sparePeerMap.set(e.getPeerID(), performance.now()))
            }
            ,
            t.prototype.cleanBlackPeerMap = function() {
                var e, t, r, i;
                try {
                    for (var n = C(this.sparePeerMap.entries()), a = n.next(); !a.done; a = n.next()) {
                        var o = L(a.value, 1)[0];
                        Ar.debug("PeerConnection", this.getLogStatus(), "delete peer(" + o + ") from spareMap")
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                try {
                    for (var s = C(this.blackPeerPool.entries()), l = s.next(); !l.done; l = s.next()) {
                        o = L(l.value, 1)[0];
                        Ar.debug("PeerConnection", this.getLogStatus(), "delete peer(" + o + ") from blackMap")
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        l && !l.done && (i = s.return) && i.call(s)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                this.sparePeerMap = new Map,
                this.blackPeerPool = new Map
            }
            ,
            t.prototype.eliminatePeerPool = function() {}
            ,
            t.prototype.isReasonShouldAddBlack = function() {
                return !0
            }
            ,
            t.prototype.isReasonShouldAddSpare = function() {
                return !1
            }
            ,
            t.prototype.isValidMsg = function(e) {
                return e.type === Z.offer || e.type === Z.candidate
            }
            ,
            t
        }(Yt), Xt = function(e) {
            function t(t, r, i) {
                return e.call(this, t, r, ie.Down, i) || this
            }
            return E(t, e),
            t.prototype.connectPeer = function() {
                for (var e = -1; this.idlePeerPool.length > 0 && !((e += 1) >= Lr.maxConnectPeerNumberOneTime); ) {
                    var t = this.getIdlePeerID()
                      , r = null;
                    this.peerContainer && (r = this.peerContainer.getPeerFromPeersUp(t)) && (Ar.info("PeerConnection", this.getLogStatus(), "found peer in upload queue." + t + "."),
                    r.downloadReq()),
                    r || (Ar.debug("PeerConnection", this.getLogStatus(), "not found peer in upload queue." + t),
                    r = this.createPeerConnection(t, ie.Down)),
                    r && this.connectingPeers.push(r)
                }
            }
            ,
            t.prototype.onPeerDataRecv = function(e, t, r, i) {
                var n;
                (null === (n = this.peerContainerListener) || void 0 === n ? void 0 : n.onPeerDataPingPang) && this.peerContainerListener.onPeerDataPingPang(e, t, r, i)
            }
            ,
            t.prototype.exchangeBitmap = function(e, t) {
                for (var r = this.connectedPeers.length, i = 0; i < r; i++)
                    this.connectedPeers[i].sendBitmapRequest(e, t)
            }
            ,
            t.prototype.exchangeBitmapForPeer = function(e, t, r) {
                for (var i = this.connectedPeers.length, n = 0; n < i; n++) {
                    var a = this.connectedPeers[n];
                    a.getPeerID() === e && a.sendBitmapRequest(t, r)
                }
            }
            ,
            t.prototype.checkP2PTimeoutRequest = function() {
                for (var e = this.connectedPeers.length, t = 0; t < e; t++) {
                    this.connectedPeers[t].deleteTimeoutPieces()
                }
            }
            ,
            t.prototype.chooseBlockByPeerID = function(e, t) {
                var r = this.findConnectedPeer(e);
                if (!(r < 0)) {
                    var i = this.connectedPeers[r];
                    this.chooseBlockWithPeer(i, t)
                }
            }
            ,
            t.prototype.choosePingPangBlockWithPeer = function(e, t, r, i) {
                var n = this.findConnectedPeer(e);
                if (!(n < 0))
                    for (var a = this.connectedPeers[n], o = t.length, s = 0; s < o && (t[s].p2pIndex === r && t[s].blockID === i && t[s].pieceArray.length > 0 && a.hasBlockData(t[s].p2pIndex, t[s].blockID) && this.choosePieceToDownload(a, t[s]),
                    a.canDownload()); s++)
                        ;
            }
            ,
            t.prototype.chooseBlockWithPeers = function(e) {
                var t, r;
                this.sortPeer();
                try {
                    for (var i = C(this.connectedPeers), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value;
                        this.chooseBlockWithPeer(a, e)
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
            }
            ,
            t.prototype.cleanBlackPeerMap = function() {
                var e, t, r, i;
                try {
                    for (var n = C(this.sparePeerMap.entries()), a = n.next(); !a.done; a = n.next()) {
                        var o = L(a.value, 2)
                          , s = o[0]
                          , l = o[1];
                        performance.now() - l > 1e3 * Lr.peerSpareTime && (this.sparePeerMap.delete(s),
                        Ar.debug("PeerConnection", this.getLogStatus(), "delete peer(" + s + ") from spareMap"))
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                try {
                    for (var c = C(this.blackPeerPool.entries()), h = c.next(); !h.done; h = c.next()) {
                        var u = L(h.value, 2);
                        s = u[0],
                        l = u[1];
                        performance.now() - l > 1e3 * Lr.peerBlackTime && (this.blackPeerPool.delete(s),
                        Ar.debug("PeerConnection", this.getLogStatus(), "delete peer(" + s + ") from blackMap"))
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        h && !h.done && (i = c.return) && i.call(c)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
            }
            ,
            t.prototype.eliminateConnectingPeer = function() {
                var e, t, r, i;
                if (0 !== this.connectingPeers.length) {
                    var n = [];
                    try {
                        for (var a = C(this.connectingPeers), o = a.next(); !o.done; o = a.next()) {
                            var s = o.value;
                            s.isReleased() && n.push({
                                peer: s,
                                reason: ae.ConnectFailed
                            }),
                            s.isConnectTimeout() && n.push({
                                peer: s,
                                reason: ae.ConnectTimeout
                            })
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            o && !o.done && (t = a.return) && t.call(a)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
                    try {
                        for (var l = C(n), c = l.next(); !c.done; c = l.next()) {
                            var h = c.value;
                            this.addPeer2Recycle(h.peer, h.reason),
                            this.removeFromConnecting(h.peer)
                        }
                    } catch (e) {
                        r = {
                            error: e
                        }
                    } finally {
                        try {
                            c && !c.done && (i = l.return) && i.call(l)
                        } finally {
                            if (r)
                                throw r.error
                        }
                    }
                }
            }
            ,
            t.prototype.eliminateConnectedPeer = function(e) {
                var t, r, i, n, a, o, s, l;
                if (e) {
                    var c = [];
                    try {
                        for (var h = C(this.connectedPeers), u = h.next(); !u.done; u = h.next()) {
                            (null == (p = u.value) ? void 0 : p.isDownloadDead()) ? c.push({
                                peer: p,
                                reason: ae.Timeout
                            }) : (null == p ? void 0 : p.isReleased()) && c.push({
                                peer: p,
                                reason: ae.ConnectFailed
                            })
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            u && !u.done && (r = h.return) && r.call(h)
                        } finally {
                            if (t)
                                throw t.error
                        }
                    }
                    if (this.connectedPeers.length - c.length > Lr.baseConnectPeerNumber) {
                        this.sortPeer();
                        try {
                            for (var d = C(this.connectedPeers), f = d.next(); !f.done; f = d.next()) {
                                var p = f.value
                                  , g = {
                                    reason: ae.UnKnown
                                };
                                if (null == p ? void 0 : p.canBeEliminatedDownload(g)) {
                                    c.push({
                                        peer: p,
                                        reason: g.reason
                                    });
                                    break
                                }
                            }
                        } catch (e) {
                            i = {
                                error: e
                            }
                        } finally {
                            try {
                                f && !f.done && (n = d.return) && n.call(d)
                            } finally {
                                if (i)
                                    throw i.error
                            }
                        }
                    }
                    try {
                        for (var v = C(c), y = v.next(); !y.done; y = v.next()) {
                            var m = y.value
                              , T = m.peer
                              , S = m.reason;
                            this.addPeer2Recycle(T, S),
                            this.removeFromConnected(T),
                            Ar.info("PeerContainer", "", "eliminateConnectedPeer : keyID: " + this.keyID + ", peerID: " + T.getPeerID())
                        }
                    } catch (e) {
                        a = {
                            error: e
                        }
                    } finally {
                        try {
                            y && !y.done && (o = v.return) && o.call(v)
                        } finally {
                            if (a)
                                throw a.error
                        }
                    }
                } else {
                    if (0 === this.connectedPeers.length)
                        return;
                    try {
                        for (var I = C(this.connectedPeers), P = I.next(); !P.done; P = I.next()) {
                            (p = P.value).release(this.stype)
                        }
                    } catch (e) {
                        s = {
                            error: e
                        }
                    } finally {
                        try {
                            P && !P.done && (l = I.return) && l.call(I)
                        } finally {
                            if (s)
                                throw s.error
                        }
                    }
                    this.connectedPeers = []
                }
            }
            ,
            t.prototype.eliminatePeerPool = function() {
                var e, t, r = [];
                try {
                    for (var i = C(this.peerPoolTime.keys()), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value
                          , o = this.peerPoolTime.get(a);
                        performance.now() - o > 1e3 * Lr.maxKeepPeerPoolTime && r.push(a)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                for (; r.length > 0; ) {
                    a = r.pop();
                    var s = this.findPeerPool(a);
                    s >= 0 && (this.idlePeerPool.splice(s, 1),
                    this.peerPoolTime.delete(a))
                }
            }
            ,
            t.prototype.releaseDownload = function() {
                var e, t, r, i;
                this.idlePeerPool = [];
                try {
                    for (var n = C(this.connectingPeers), a = n.next(); !a.done; a = n.next()) {
                        a.value.release(ie.Down)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                this.connectingPeers = [];
                try {
                    for (var o = C(this.connectedPeers), s = o.next(); !s.done; s = o.next()) {
                        s.value.release(ie.Down)
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (i = o.return) && i.call(o)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                this.connectedPeers = [],
                this.peerPoolTime = new Map,
                this.sparePeerMap = new Map,
                this.blackPeerPool = new Map
            }
            ,
            t.prototype.release = function() {
                Ar.info("PeerDownPool", this.getLogStatus(), "release."),
                e.prototype.release.call(this)
            }
            ,
            t.prototype.deleteNoUploadedPeers = function() {
                for (var e = this.connectedPeers.length, t = 0; t < e; t++) {
                    var r = this.connectedPeers[t];
                    r.isNoUpload() && r.release()
                }
            }
            ,
            t.prototype.addPeer2Recycle = function(e, t) {
                if (e)
                    if (Ar.debug("PeerConnection", this.getLogStatus(), "addPeer2Recycle " + e.getPeerID() + " reason:" + t.reason + " stype:" + this.stype + " Connecting:" + this.connectingPeers.length + " Connected:" + this.connectedPeers.length + " Spare:" + this.sparePeerMap.size + " Black:" + this.blackPeerPool.size),
                    e.release(this.stype),
                    this.isReasonShouldAddBlack(t)) {
                        if (this.isPeerInBackOrSparePool(e.getPeerID()))
                            return;
                        this.blackPeerPool.set(e.getPeerID(), performance.now())
                    } else if (this.isReasonShouldAddSpare(t)) {
                        if (this.isPeerInBackOrSparePool(e.getPeerID()))
                            return;
                        this.sparePeerMap.set(e.getPeerID(), performance.now())
                    }
            }
            ,
            t.prototype.onRecv = function(t) {
                if (!t)
                    return !1;
                if (e.prototype.onRecv.call(this, t))
                    return !0;
                var r = this.getPeer(t.src_uin);
                return r ? (r.onRecv(t),
                !0) : (this.onRecvNotInQueue(t),
                !1)
            }
            ,
            t.prototype.isReasonShouldAddBlack = function(e) {
                switch (e.code) {
                case ae.Timeout.code:
                case ae.PeerNoInServer.code:
                case ae.ConnectTimeout.code:
                case ae.QosLow.code:
                case ae.ConnectFailed.code:
                    return !0
                }
                return !1
            }
            ,
            t.prototype.isReasonShouldAddSpare = function(e) {
                return e.code === ae.Exit.code
            }
            ,
            t.prototype.onRecvNotInQueue = function(e) {
                Ar.info("PeerConnection", this.getLogStatus(), "srcUin not in queue.  srcUin:" + e.src_uin + " dstUin:" + e.dst_uin + " keyID:" + e.keyid);
                var t = this.getOppositeSType(e.stype)
                  , r = ae.RemoteNotInQueue;
                Ar.debug("PeerConnection", this.getLogStatus(), "dstUin:" + e.dst_uin + ",stype:" + e.stype + "):send bye " + r.reason),
                this.serverInterface.sendBye2Client(e.src_uin, t, r.code)
            }
            ,
            t.prototype.isPeerInBackOrSparePool = function(e) {
                return !!this.blackPeerPool.get(e) || (!!this.sparePeerMap.get(e) || void 0)
            }
            ,
            t.prototype.chooseBlockWithPeer = function(e, t) {
                for (var r = t.length, i = 0; i < r && (t[i].pieceArray.length > 0 && e.hasBlockData(t[i].p2pIndex, t[i].blockID) && this.choosePieceToDownload(e, t[i]),
                e.canDownload()); i++)
                    ;
            }
            ,
            t.prototype.choosePieceToDownload = function(e, t) {
                for (; ; ) {
                    if (!e.canDownload())
                        break;
                    if (0 === t.pieceArray.length)
                        break;
                    for (var r = t.pieceArray[0], i = e.getFreeWindowSize(), n = 0, a = t.pieceArray.length, o = 0; ; o++) {
                        if (o === a || r + n !== t.pieceArray[o] || i <= 0) {
                            e.sendDataRequest(t.p2pIndex, t.fileSize, t.blockID, r, n),
                            t.pieceArray.splice(0, n);
                            break
                        }
                        n += 1,
                        i -= 1
                    }
                }
            }
            ,
            t.prototype.sortPeer = function() {
                this.connectedPeers.sort(this.sortPeerByQos)
            }
            ,
            t.prototype.sortPeerByQos = function(e, t) {
                return e.getQos() < t.getQos() ? 1 : e.getQos() === t.getQos() ? 0 : -1
            }
            ,
            t.prototype.getIdlePeerID = function() {
                var e;
                if (this.taskType === B.Live)
                    for (var t = 0; t < this.idlePeerPool.length; t++) {
                        var r = this.idlePeerPool[t];
                        if (r % Lr.liveDownloadPartNum !== ur.getInstance().getUin()) {
                            e = r,
                            this.idlePeerPool.splice(t, 1);
                            break
                        }
                    }
                return e || (e = this.idlePeerPool.pop()),
                this.peerPoolTime.delete(e),
                e
            }
            ,
            t
        }(Yt), Zt = function() {
            function e(e, t) {
                this.keyID = e,
                this.peerUpPool = new Qt(e,t,this),
                this.peerDownPool = new Xt(e,t,this)
            }
            return e.prototype.getKeyID = function() {
                return this.keyID
            }
            ,
            e.prototype.setListener = function(e) {
                this.peerUpPool && this.peerUpPool.setListener(e),
                this.peerDownPool && this.peerDownPool.setListener(e)
            }
            ,
            e.prototype.getUpAndDownPeerNum = function() {
                var e, t, r = 0, i = this.getPeerDownPool().connectedPeers, n = this.getPeerUploadPool().connectedPeers;
                try {
                    for (var a = C(n), o = a.next(); !o.done; o = a.next()) {
                        var s = o.value;
                        -1 !== i.indexOf(s) && (r += 1)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        o && !o.done && (t = a.return) && t.call(a)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.cleanBlackPool = function() {
                this.peerDownPool && this.peerDownPool.cleanBlackPeerMap(),
                this.peerUpPool && this.peerUpPool.cleanBlackPeerMap()
            }
            ,
            e.prototype.getPeerDownPool = function() {
                return this.peerDownPool
            }
            ,
            e.prototype.getPeerUploadPool = function() {
                return this.peerUpPool
            }
            ,
            e.prototype.getSpareCountDownload = function() {
                return this.peerDownPool ? this.peerDownPool.getSpareCount() : 0
            }
            ,
            e.prototype.getBlackCountDownload = function() {
                return this.peerDownPool ? this.peerDownPool.getBlackCount() : 0
            }
            ,
            e.prototype.getSpareCountUpload = function() {
                return this.peerUpPool ? this.peerUpPool.getSpareCount() : 0
            }
            ,
            e.prototype.getBlackCountUpload = function() {
                return this.peerUpPool ? this.peerUpPool.getBlackCount() : 0
            }
            ,
            e.prototype.getConnectingCountUpload = function() {
                return this.peerUpPool ? this.peerUpPool.getConnectingPeerLen() : 0
            }
            ,
            e.prototype.getConnectedCountUpload = function() {
                return this.peerUpPool ? this.peerUpPool.getConnectedPeerLen() : 0
            }
            ,
            e.prototype.insertPeer2ConnectedUp = function(e) {
                this.peerUpPool && this.peerUpPool.changeConnecting2Connected(e)
            }
            ,
            e.prototype.insertPeer2ConnectedDown = function(e) {
                this.peerDownPool && this.peerDownPool.changeConnecting2Connected(e)
            }
            ,
            e.prototype.removePeerFromConnectingUp = function(e) {
                this.peerUpPool && this.peerUpPool.removeFromConnecting(e)
            }
            ,
            e.prototype.removePeerFromConnectingDown = function(e) {
                this.peerDownPool && this.peerDownPool.removeFromConnecting(e)
            }
            ,
            e.prototype.addPeer2RecycleDown = function(e, t) {
                this.peerDownPool && this.peerDownPool.addPeer2Recycle(e, t)
            }
            ,
            e.prototype.getEstablishPeerFromPeersDown = function(e) {
                var t = null;
                return this.peerDownPool && (t = this.peerDownPool.getEstablishPeer(e)),
                t
            }
            ,
            e.prototype.getEstablishPeerFromPeersUp = function(e) {
                var t = null;
                return this.peerUpPool && (t = this.peerUpPool.getEstablishPeer(e)),
                t
            }
            ,
            e.prototype.getPeerFromPeersUp = function(e) {
                var t = null;
                return this.peerUpPool && (t = this.peerUpPool.getPeer(e)),
                t
            }
            ,
            e.prototype.getPeerFromPeersDown = function(e) {
                var t = null;
                return this.peerDownPool && (t = this.peerDownPool.getPeer(e)),
                t
            }
            ,
            e.prototype.onRecv = function(e) {
                if (!e)
                    return null;
                e.stype === ie.Down ? this.peerUpPool && this.peerUpPool.onRecv(e) : e.stype === ie.Up && this.peerDownPool && this.peerDownPool.onRecv(e)
            }
            ,
            e.prototype.eliminateConnectingPeer = function() {
                this.peerDownPool && this.peerDownPool.eliminateConnectingPeer(),
                this.peerUpPool && this.peerUpPool.eliminateConnectingPeer()
            }
            ,
            e.prototype.eliminateConnectedPeer = function(e) {
                this.peerDownPool && this.peerDownPool.eliminateConnectedPeer(e),
                this.peerUpPool && this.peerUpPool.eliminateConnectedPeer()
            }
            ,
            e.prototype.release = function() {
                Ar.info("PeerContainer", "seq:" + ut.getInstance().getFileSeq(this.keyID), "release."),
                this.peerDownPool && this.peerDownPool.release(),
                this.peerUpPool && this.peerUpPool.release()
            }
            ,
            e.prototype.onRecvNoFoundDstUin = function(e) {
                var t = e.args[0]
                  , r = e.args[1]
                  , i = null;
                try {
                    i = JSON.parse(r)
                } catch (e) {
                    return
                }
                i.stype === ie.Down ? this.peerDownPool && this.peerDownPool.onRecvNoFoundDstUin(t, i) : (i.stype === ie.Up || this.peerDownPool && this.peerDownPool.onRecvNoFoundDstUin(t, i),
                this.peerUpPool && this.peerUpPool.onRecvNoFoundDstUin(t, i))
            }
            ,
            e
        }(), Jt = function() {
            function e() {
                this.printInfoLogTick = 0,
                this.peerContainerMap = new Map
            }
            return e.getInstance = function() {
                return this.instance || (this.instance = new e),
                this.instance
            }
            ,
            e.prototype.init = function() {
                this.eliminatePeerTimer = self.setInterval(this.onEliminatePeer.bind(this), J.secondTimer),
                Ar.info("PeerContainerManager", "", "init.")
            }
            ,
            e.prototype.destroy = function() {
                var t, r;
                Ar.info("PeerContainerManager", "", "destroy.");
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        n.value.release()
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                this.peerContainerMap = new Map,
                this.eliminatePeerTimer && (clearInterval(this.eliminatePeerTimer),
                this.eliminatePeerTimer = void 0),
                e.instance = void 0
            }
            ,
            e.prototype.onEliminatePeer = function() {
                this.printInfoLogTick % 10 == 0 ? Ar.info("PeerContainerManager", "", this.getPeerInfoStr()) : Ar.debug("PeerContainerManager", "", this.getPeerInfoStr()),
                this.printInfoLogTick += 1,
                this.onCleanBlackPeerMap(),
                this.onEliminateConnectingPeer(),
                this.onEliminateConnectedPeer(),
                this.onEliminatePeerPool()
            }
            ,
            e.prototype.onEliminatePeerPool = function() {
                var e, t;
                try {
                    for (var r = C(this.peerContainerMap.values()), i = r.next(); !i.done; i = r.next()) {
                        i.value.getPeerDownPool().eliminatePeerPool()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        i && !i.done && (t = r.return) && t.call(r)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
            }
            ,
            e.prototype.onCleanBlackPeerMap = function() {
                var e, t;
                try {
                    for (var r = C(this.peerContainerMap.values()), i = r.next(); !i.done; i = r.next()) {
                        i.value.cleanBlackPool()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        i && !i.done && (t = r.return) && t.call(r)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
            }
            ,
            e.prototype.onEliminateConnectingPeer = function() {
                var e, t;
                if (0 !== this.peerContainerMap.size)
                    try {
                        for (var r = C(this.peerContainerMap.entries()), i = r.next(); !i.done; i = r.next()) {
                            var n = L(i.value, 2)
                              , a = n[0]
                              , o = n[1];
                            ut.getInstance().isPlayTask(a),
                            o.eliminateConnectingPeer()
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            i && !i.done && (t = r.return) && t.call(r)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
            }
            ,
            e.prototype.onEliminateConnectedPeer = function() {
                var e, t;
                if (0 !== this.peerContainerMap.size)
                    try {
                        for (var r = C(this.peerContainerMap.entries()), i = r.next(); !i.done; i = r.next()) {
                            var n = L(i.value, 2)
                              , a = n[0]
                              , o = n[1];
                            ut.getInstance().isPlayTask(a) ? o.eliminateConnectedPeer(!0) : o.eliminateConnectedPeer(!1)
                        }
                    } catch (t) {
                        e = {
                            error: t
                        }
                    } finally {
                        try {
                            i && !i.done && (t = r.return) && t.call(r)
                        } finally {
                            if (e)
                                throw e.error
                        }
                    }
            }
            ,
            e.prototype.releaseContainer = function(e) {
                this.peerContainerMap && (this.peerContainerMap.has(e) && (this.peerContainerMap.get(e).release(),
                this.peerContainerMap.delete(e)))
            }
            ,
            e.prototype.createPeerContainer = function(e, t) {
                var r = null;
                return this.peerContainerMap.has(e) ? (r = this.peerContainerMap.get(e)).setListener(t) : (r = new Zt(e,t),
                this.peerContainerMap.set(e, r)),
                r
            }
            ,
            e.prototype.getAllConnectingPeerCount = function() {
                var e, t, r = this.peerContainerMap.keys(), i = 0;
                try {
                    for (var n = C(r), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        i += this.peerContainerMap.get(o).getPeerDownPool().getConnectingPeerLen()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return i
            }
            ,
            e.prototype.getAllConnectedPeerCount = function() {
                var e, t, r = this.peerContainerMap.keys(), i = 0;
                try {
                    for (var n = C(r), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        i += this.peerContainerMap.get(o).getPeerDownPool().getConnectedPeerLen()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return i
            }
            ,
            e.prototype.getAllConnectPeerCount = function() {
                return this.getAllConnectedPeerCount() + this.getAllConnectingPeerCount()
            }
            ,
            e.prototype.onRecvMessage = function(e, t) {
                var r = JSON.parse(t.body.msg);
                if (e.obj.getUin() === r.dst_uin) {
                    var i = this.peerContainerMap.get(r.keyid);
                    i ? i.onRecv(r) : this.onRecvNoContainer(e, r)
                } else
                    Ar.warn("PeerContainerManager", "", "not expect pack,uin:" + r.src_uin)
            }
            ,
            e.prototype.onRecvError = function(e, t) {
                if (t.body.ret_code === X.NOT_FIND_DSTUIN)
                    try {
                        var r = JSON.parse(e.args[1])
                          , i = this.peerContainerMap.get(r.keyid);
                        i && i.onRecvNoFoundDstUin(e)
                    } catch (e) {}
            }
            ,
            e.prototype.getSpareCountDownload = function() {
                var e, t, r = 0;
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        r += n.value.getSpareCountDownload()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getBlackCountDownload = function() {
                var e, t, r = 0;
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        r += n.value.getBlackCountDownload()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getSpareCountUpload = function() {
                var e, t, r = 0;
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        r += n.value.getSpareCountUpload()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getBlackCountUpload = function() {
                var e, t, r = 0;
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        r += n.value.getBlackCountUpload()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getConnectingCountUpload = function() {
                var e, t, r = 0;
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        r += n.value.getConnectingCountUpload()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getConnectedCountUpload = function() {
                var e, t, r = 0;
                try {
                    for (var i = C(this.peerContainerMap.values()), n = i.next(); !n.done; n = i.next()) {
                        r += n.value.getConnectedCountUpload()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.getConnectCountUpload = function() {
                return this.getConnectedCountUpload() + this.getConnectingCountUpload()
            }
            ,
            e.prototype.getPeerNumForReport = function(e) {
                var t = this.peerContainerMap.get(e);
                return {
                    upAndDown: t ? t.getUpAndDownPeerNum() : 0,
                    up: t ? t.getConnectedCountUpload() : 0,
                    downIdle: t ? t.getPeerDownPool().getPeerPoolLen() : 0,
                    downConnecting: t ? t.getPeerDownPool().getConnectingPeerLen() : 0,
                    downConnected: t ? t.getPeerDownPool().getConnectedPeerLen() : 0
                }
            }
            ,
            e.prototype.getPeerInfoStr = function() {
                return "Connecting:[" + this.getAllConnectingPeerCount() + ", " + this.getConnectingCountUpload() + "] Connected:[" + this.getAllConnectedPeerCount() + "," + this.getConnectedCountUpload() + "] Spare:[" + this.getSpareCountDownload() + "," + this.getSpareCountUpload() + "] Black:[" + this.getBlackCountDownload() + "," + this.getBlackCountUpload() + "]"
            }
            ,
            e.prototype.onRecvNoContainer = function(e, t) {
                if (t.type === Z.bye) {
                    var r = oe.getReasonStr(t.reason);
                    t.stype === ie.Down ? Ar.debug("PeerContainerManager", "", "onRecvNoContainer type:" + t.type + " stype:" + t.stype + "  reason:" + r + " oppsite_action:" + t.stype + " oppsiteUin:" + t.src_uin + " myUin:" + t.dst_uin + " myUin1:" + e.obj.getUin()) : t.stype === ie.Up && Ar.debug("PeerContainerManager", "", "onRecvNoContainer type:" + t.type + " stype:" + t.stype + " reason:" + r + " oppsite_action:" + t.stype + " oppsiteUin:" + t.src_uin + " myUin:" + t.dst_uin + " myUin1:" + e.obj.getUin())
                } else {
                    var i = 0;
                    i = t.stype === ie.Down ? ie.Up : ie.Down,
                    Ar.debug("PeerContainerManager", "", "onRecvNoContainer type:" + t.type + " stype:" + t.stype + " oppsite_action:" + t.stype + " oppsiteUin:" + t.src_uin + " myUin:" + t.dst_uin + " myUin1:" + e.obj.getUin());
                    var n = ae.KeyIdNotExsit;
                    Ar.debug("PeerContainerManager", "", "PeerConnection(" + t.dst_uin + ",stype:" + t.stype + "):send bye " + n.reason),
                    e.obj.sendBye2Client(t.src_uin, i, n.code)
                }
            }
            ,
            e
        }(), $t = Jt, er = function() {
            function e(e) {
                this.qryTptTimes = 0,
                this.qryTptOkTimes = 0,
                this.heartbeatOkTimes = 0,
                this.reportTimes = 0,
                this.reportOkTimes = 0,
                this.qrySeedTimes = 0,
                this.qrySeedOkTimes = 0,
                this.relayTimes = 0,
                this.relayRspTimes = 0,
                this.relayOkTimes = 0,
                this.recvRelayReqTimes = 0,
                this.loginTimes = 0,
                this.loginOkTimes = 0,
                this.taskType = e
            }
            return e.getItem = function(t) {
                var r = this.instances.get(t);
                return r || (r = new e(t),
                this.instances.set(t, r)),
                r
            }
            ,
            e.prototype.start = function() {
                this.resetTimer()
            }
            ,
            e.prototype.stop = function() {
                this.reportTimer && (this.report(),
                clearInterval(this.reportTimer),
                this.reportTimer = void 0)
            }
            ,
            e.prototype.onReportSchedule = function() {
                this.report(),
                this.reportInterval !== Lr.reportInterval && this.resetTimer()
            }
            ,
            e.prototype.report = function(e, t) {
                void 0 === e && (e = W.ServerPeriod),
                void 0 === t && (t = !1);
                var r = {};
                r.step = e,
                r.taskType = this.taskType === B.Vod ? 0 : 9999,
                r.heartbeatTimes = this.qryTptTimes,
                r.heartbeatOkTimes = this.qryTptOkTimes,
                r.reportTimes = this.reportTimes,
                r.reportOkTimes = this.reportOkTimes,
                r.qrySeedTimes = this.qrySeedTimes,
                r.qrySeedOkTimes = this.qrySeedOkTimes,
                r.relayTimes = this.relayTimes,
                r.relayRspTimes = this.relayRspTimes,
                r.relayOkTimes = this.relayOkTimes,
                r.recvRelayReqTimes = this.recvRelayReqTimes,
                r.loginTimes = this.loginTimes,
                r.loginOkTimes = this.loginOkTimes,
                this.resetStats(),
                1e3 * Math.random() < Lr.serverQualityReportRate && re.getInstance().reportToAtta(r, t)
            }
            ,
            e.prototype.resetStats = function() {
                this.qryTptTimes = 0,
                this.qryTptOkTimes = 0,
                this.reportTimes = 0,
                this.reportOkTimes = 0,
                this.qrySeedTimes = 0,
                this.qrySeedOkTimes = 0,
                this.relayTimes = 0,
                this.relayRspTimes = 0,
                this.relayOkTimes = 0,
                this.recvRelayReqTimes = 0,
                this.loginTimes = 0,
                this.loginOkTimes = 0
            }
            ,
            e.prototype.resetTimer = function() {
                this.reportTimer && (clearInterval(this.reportTimer),
                this.reportTimer = void 0),
                this.reportInterval = Lr.reportInterval,
                this.reportTimer = self.setInterval(this.onReportSchedule.bind(this), 1e3 * this.reportInterval)
            }
            ,
            e.instances = new Map,
            e
        }(), tr = function() {
            function e(e) {
                this.server = e,
                this.serverStats = er.getItem(e.getTaskType())
            }
            return e.prototype.createMessage = function(e, t, r) {
                var i = ee.reqHeader(e, this.server, t);
                return JSON.stringify(this.createReq(e, i, r))
            }
            ,
            e.prototype.getTaskArgs = function(e) {
                return ee.isTask(e[0]) ? e[0].args : e
            }
            ,
            e.prototype.reportQuality = function(e, t, r) {
                void 0 === t && (t = 0);
                var i = this.getReportInfo(e, t, r);
                re.getInstance().reportSvrQuality(i)
            }
            ,
            e
        }(), rr = function(e) {
            function t(t, r) {
                var i = e.call(this, r) || this;
                return i.loginStartTime = 0,
                i.querySeedStartTime = 0,
                t.set(Q.LOGIN, i),
                t.set(Q.LOGOUT, i),
                t.set(Q.HEARTBEAT, i),
                t.set(Q.REPORT, i),
                t.set(Q.QUERY_SEED, i),
                i
            }
            return E(t, e),
            t.prototype.getRetryDelay = function(e) {
                return e.cmd !== Q.LOGIN && e.cmd !== Q.REPORT ? -1 : e.retryCount < Lr.p2pPackRetryTimes ? Lr.p2pServerRetryInternal : e.cmd === Q.LOGIN ? Lr.p2pLoginRetryInternal : -1
            }
            ,
            t.prototype.afterSend = function(e) {
                switch (e.cmd) {
                case Q.LOGIN:
                    -1 !== this.loginStartTime && (this.loginStartTime = performance.now()),
                    this.serverStats.loginTimes += 1;
                    break;
                case Q.QUERY_SEED:
                    -1 !== this.querySeedStartTime && (this.querySeedStartTime = performance.now()),
                    le.getItem(e.args[3]).qrySeedTimes += 1,
                    this.serverStats.qrySeedTimes += 1;
                    break;
                case Q.REPORT:
                    this.serverStats.reportTimes += 1;
                case Q.HEARTBEAT:
                case Q.LOGOUT:
                }
            }
            ,
            t.prototype.onRecv = function(e, t) {
                switch (t.header.cmd) {
                case Q.LOGIN:
                    this.onRecvLogin(t);
                    break;
                case Q.QUERY_SEED:
                    this.onRecvQuerySeed(e, t);
                    break;
                case Q.REPORT:
                    this.serverStats.reportOkTimes += 1;
                case Q.HEARTBEAT:
                case Q.LOGOUT:
                }
            }
            ,
            t.prototype.onTimeout = function(e) {
                var t;
                switch (e.cmd) {
                case Q.LOGIN:
                    t = ne.PSLoginTimeout;
                    break;
                case Q.HEARTBEAT:
                    t = ne.PSHeartBeatTimeout;
                    break;
                case Q.QUERY_SEED:
                    t = ne.PSQuerySeedTimeout;
                    break;
                case Q.REPORT:
                    t = ne.PSReportTimeout
                }
                t && this.reportQuality(t)
            }
            ,
            t.prototype.onError = function(e, t) {
                var r;
                switch (t.header.cmd) {
                case Q.LOGIN:
                    r = ne.PSLoginFail,
                    this.server.onLoginFail();
                    break;
                case Q.QUERY_SEED:
                    r = ne.PSQuerySeedFailed;
                    break;
                case Q.HEARTBEAT:
                    r = ne.PSHeartBeatError;
                    break;
                case Q.REPORT:
                    r = ne.PSReportResFailed
                }
                this.reportQuality(r, t.body.ret_code)
            }
            ,
            t.prototype.createReq = function(e, t, r) {
                var i, n, a;
                switch (e) {
                case Q.LOGIN:
                    return ee.loginReq(t);
                case Q.LOGOUT:
                    return ee.logoutReq(t);
                case Q.HEARTBEAT:
                    var o, s, l, c, h, u;
                    return o = (i = L(this.getTaskArgs(r), 6))[0],
                    s = i[1],
                    l = i[2],
                    c = i[3],
                    h = i[4],
                    u = i[5],
                    ee.heartReq(t, o, s, l, c, h, u);
                case Q.REPORT:
                    var d, f;
                    return d = (n = L(this.getTaskArgs(r), 2))[0],
                    f = n[1],
                    ee.reportReq(t, d, f);
                case Q.QUERY_SEED:
                    var p, g;
                    return p = (a = L(this.getTaskArgs(r), 2))[0],
                    g = a[1],
                    ee.querySeedReq(t, p, g)
                }
            }
            ,
            t.prototype.getReportInfo = function(e, t, r) {
                void 0 === t && (t = 0),
                void 0 === r && (r = 0);
                var i = this.server.getAddress();
                return {
                    svrType: Y.PeerServer,
                    svrIP: i.ip,
                    svrPort: i.port,
                    errCode: e,
                    svrRetCode: t,
                    connectElapse: r,
                    taskType: this.server.getTaskType() === B.Vod ? 0 : 9999
                }
            }
            ,
            t.prototype.onRecvLogin = function(e) {
                if (e.body.ret_code === X.OK && (this.serverStats.loginOkTimes += 1,
                this.server.onLoginSuccess(e.body.uin, e.body.uin_token),
                this.loginStartTime > 0)) {
                    var t = performance.now() - this.loginStartTime;
                    this.reportQuality(ne.PSLoginSuccess, 0, t),
                    this.loginStartTime = -1
                }
            }
            ,
            t.prototype.onRecvQuerySeed = function(e, t) {
                if (this.querySeedStartTime > 0) {
                    var r = performance.now() - this.querySeedStartTime;
                    this.reportQuality(ne.PSQuerySeedSuccess, 0, r),
                    this.querySeedStartTime = -1
                }
                this.serverStats.qrySeedOkTimes += 1,
                le.getItem(e.args[3]).qrySeedOkTimes += 1;
                var i = e.args[2]
                  , n = this.getSeeds(t);
                i.onQueryCompleteCall(t.body.ret_code, t.body.fileid, n, n.length, t.body.total_seed_num),
                0 !== n.length && (le.getItem(e.args[3]).hasSeedTimes += 1)
            }
            ,
            t.prototype.getSeeds = function(e) {
                var t, r, i = [];
                try {
                    for (var n = C(e.body.seed_list), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        o !== this.server.getUin() && i.push(o)
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        a && !a.done && (r = n.return) && r.call(n)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return i
            }
            ,
            t
        }(tr), ir = function(e) {
            function t(t, r) {
                var i = e.call(this, r) || this;
                return t.set(Q.SIGNAL_RELAY, i),
                i
            }
            return E(t, e),
            t.prototype.getRetryDelay = function(e) {
                return -1
            }
            ,
            t.prototype.afterSend = function(e) {
                if (e.cmd === Q.SIGNAL_RELAY)
                    this.serverStats.relayTimes += 1
            }
            ,
            t.prototype.onRecv = function(e, t) {
                if (t.header.cmd === Q.SIGNAL_RELAY)
                    this.onRecvRelay(e, t)
            }
            ,
            t.prototype.onTimeout = function(e) {
                if (e.cmd === Q.SIGNAL_RELAY)
                    this.reportQuality(ne.SignalRelayTimeout)
            }
            ,
            t.prototype.onError = function(e, t) {
                if (t.header.cmd === Q.SIGNAL_RELAY)
                    this.onRecvRelayRsp(e, t),
                    this.reportQuality(ne.SignalRelayError, t.body.ret_code)
            }
            ,
            t.prototype.createReq = function(e, t, r) {
                var i;
                if (e === Q.SIGNAL_RELAY) {
                    var n, a = void 0;
                    return n = (i = L(this.getTaskArgs(r), 2))[0],
                    a = i[1],
                    a = JSON.stringify(ee.forwardReq(t, n, a)),
                    ee.forwardReq(t, n, a)
                }
            }
            ,
            t.prototype.getReportInfo = function(e, t) {
                void 0 === t && (t = 0);
                var r = this.server.getAddress();
                return {
                    svrType: Y.SignalServer,
                    svrIP: r.ip,
                    svrPort: r.port,
                    errCode: e,
                    svrRetCode: t,
                    taskType: this.server.getTaskType() === B.Vod ? 0 : 9999
                }
            }
            ,
            t.prototype.onRecvRelay = function(e, t) {
                void 0 !== t.body.ret_code ? this.onRecvRelayRsp(e, t) : t.body.msg && ($t.getInstance().onRecvMessage(e, t),
                this.serverStats.recvRelayReqTimes += 1)
            }
            ,
            t.prototype.onRecvRelayRsp = function(e, t) {
                this.serverStats.relayRspTimes += 1,
                t.body.ret_code === X.OK ? this.serverStats.relayOkTimes += 1 : $t.getInstance().onRecvError(e, t)
            }
            ,
            t
        }(tr), nr = function(e) {
            function t(t, r) {
                var i = e.call(this, r) || this;
                return i.queryTptStartTime = 0,
                t.set(Q.QUERY_TPT, i),
                i
            }
            return E(t, e),
            t.prototype.getRetryDelay = function(e, t) {
                return (null == t ? void 0 : t.body.ret_code) === X.TPT_NO_P2P || e.retryCount >= Lr.p2pPackRetryTimes ? -1 : Lr.p2pServerRetryInternal
            }
            ,
            t.prototype.afterSend = function(e) {
                if (e.cmd === Q.QUERY_TPT)
                    -1 !== this.queryTptStartTime && (this.queryTptStartTime = performance.now()),
                    this.serverStats.qryTptTimes += 1
            }
            ,
            t.prototype.onRecv = function(e, t) {
                if (t.header.cmd === Q.QUERY_TPT) {
                    var r = e.args[1];
                    if (e.args[0] === t.body.resourceid && (le.getItem(e.args[0]).isGotTPT = !0,
                    r.onTPTReturn(t.body.ret_code, t.body.fileid_list, t.body.ts_num_list),
                    this.serverStats.qryTptOkTimes += 1,
                    this.queryTptStartTime > 0)) {
                        var i = performance.now() - this.queryTptStartTime;
                        this.reportQuality(ne.TPTSucceed, 0, i)
                    }
                }
            }
            ,
            t.prototype.onTimeout = function(e) {
                if (e.cmd === Q.QUERY_TPT)
                    le.getItem(e.args[0]).isGotTPT = !1,
                    this.reportQuality(ne.TPTTimeout)
            }
            ,
            t.prototype.onError = function(e, t) {
                if (t.header.cmd === Q.QUERY_TPT)
                    if (e.args[1].onTPTError(t.body.ret_code),
                    le.getItem(e.args[0]).isGotTPT = !1,
                    t.body.ret_code === X.TPT_NO_P2P) {
                        if (this.queryTptStartTime > 0) {
                            var r = performance.now() - this.queryTptStartTime;
                            this.reportQuality(ne.TPTSucceed, X.TPT_NO_P2P, r)
                        }
                    } else
                        this.reportQuality(ne.TPTHlsError, t.body.ret_code)
            }
            ,
            t.prototype.createReq = function(e, t, r) {
                if (e === Q.QUERY_TPT) {
                    var i;
                    return i = L(this.getTaskArgs(r), 1)[0],
                    ee.getTPTReq(t, J.busiID, i)
                }
            }
            ,
            t.prototype.getReportInfo = function(e, t, r) {
                return void 0 === t && (t = 0),
                void 0 === r && (r = 0),
                {
                    svrType: Y.TPTServer,
                    svrIP: this.server.getAddress().ip,
                    svrPort: this.server.getAddress().port,
                    errCode: e,
                    svrRetCode: t,
                    connectElapse: r,
                    taskType: this.server.getTaskType() === B.Vod ? 0 : 9999
                }
            }
            ,
            t
        }(tr), ar = function() {
            function e(e, t) {
                this.connection = null,
                this.state = R.UNCONNECTED,
                this.onConnectedCallBack = [],
                this.isOnError = !1,
                this.sessionDelegate = t,
                this.address = e
            }
            return e.prototype.close = function() {
                this.sessionDelegate = null,
                this.connection && (this.connection.close(),
                this.connection = null)
            }
            ,
            e.prototype.connect = function(e) {
                if (this.state === R.CONNECTED)
                    return e && e(),
                    !0;
                if (this.state === R.CONNECTING)
                    return this.onConnectedCallBack.push(e),
                    !0;
                this.state = R.CONNECTING,
                e && this.onConnectedCallBack.push(e);
                var t = "wss://" + this.address.ip;
                return 0 !== this.address.port && null !== this.address.port && (t += ":" + this.address.port),
                this.connection = new WebSocket(t),
                this.connection.onmessage = this.onRecv.bind(this),
                this.connection.onopen = this.onConnect.bind(this),
                this.connection.onerror = this.onError.bind(this),
                this.connection.onclose = this.onClose.bind(this),
                this.connectStart = performance.now(),
                !0
            }
            ,
            e.prototype.getState = function() {
                return this.state
            }
            ,
            e.prototype.getAddress = function() {
                return this.address
            }
            ,
            e.prototype.isStop = function() {
                return this.state === R.STOPED
            }
            ,
            e.prototype.stop = function() {
                return this.state === R.STOPED || (null !== this.connection && (this.state !== R.CONNECTED && this.state !== R.CONNECTING || this.connection.close(),
                this.connection = null),
                this.state = R.STOPED),
                !0
            }
            ,
            e.prototype.send = function(e) {
                var t, r = this;
                if (this.state === R.UNCONNECTED) {
                    if (!this.connect((function() {
                        var t;
                        return null === (t = r.connection) || void 0 === t ? void 0 : t.send(e)
                    }
                    )))
                        return -1
                } else {
                    if (this.state === R.STOPED)
                        return 0;
                    this.state === R.CONNECTED && (null === (t = this.connection) || void 0 === t || t.send(e))
                }
                return 0
            }
            ,
            e.prototype.onRecv = function(e) {
                var t;
                (null === (t = this.sessionDelegate) || void 0 === t ? void 0 : t.onRecv) && this.sessionDelegate.onRecv(e.data)
            }
            ,
            e.prototype.onClose = function(e) {
                var t;
                if (e.code && 1e3 !== e.code && this.isOnError) {
                    var r = {
                        ip: this.address.ip,
                        port: this.address.port,
                        retCode: e.code
                    };
                    re.getInstance().lastWebSocketErrorInfo = r,
                    this.isOnError = !1
                }
                (null === (t = this.sessionDelegate) || void 0 === t ? void 0 : t.onClose) && this.sessionDelegate.onClose(this)
            }
            ,
            e.prototype.onConnect = function() {
                var e, t, r;
                this.state = R.CONNECTED;
                var i = 0;
                this.connectStart && (i = performance.now() - this.connectStart),
                (null === (r = this.sessionDelegate) || void 0 === r ? void 0 : r.onConnect) && this.sessionDelegate.onConnect(i);
                try {
                    for (var n = C(this.onConnectedCallBack), a = n.next(); !a.done; a = n.next()) {
                        var o = a.value;
                        o && o()
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        a && !a.done && (t = n.return) && t.call(n)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                this.onConnectedCallBack.length > 0 && this.onConnectedCallBack.splice(0, this.onConnectedCallBack.length)
            }
            ,
            e.prototype.onError = function(e) {
                var t;
                (null === (t = this.sessionDelegate) || void 0 === t ? void 0 : t.onError) && this.sessionDelegate.onError(this, e),
                this.isOnError = !0
            }
            ,
            e
        }(), or = function() {
            function e(e) {
                this.loginState = _.UNLOGIN,
                this.addressIndex = 0,
                this.cmdMap = new Map,
                this.seq = -1,
                this.serverState = A.UNINIT,
                this.unsendTask = [],
                this.sendTask = [],
                this.nextConnectTick = 0,
                this.heartBeatTick = 0,
                this.messageCache = "",
                this.setAddress(),
                this.connection = new ar(this.address,this),
                this.interface = e,
                this.createService()
            }
            return e.prototype.init = function() {
                var e = this;
                this.serverState = A.RUNNING,
                er.getItem(this.getTaskType()).start(),
                this.scheduleTimer = self.setInterval((function() {
                    e.schedule()
                }
                ), Lr.webSocketScheduleInternal),
                this.schedule()
            }
            ,
            e.prototype.getSeq = function() {
                return this.seq += 1,
                this.seq
            }
            ,
            e.prototype.getUin = function() {
                return this.interface.getUin()
            }
            ,
            e.prototype.getUinToken = function() {
                return this.interface.getUinToken()
            }
            ,
            e.prototype.getAddress = function() {
                return this.address
            }
            ,
            e.prototype.destroy = function() {
                this.close(),
                this.addressIndex = 0,
                this.messageCache = "",
                this.cmdMap.clear()
            }
            ,
            e.prototype.close = function() {
                (this.serverState = A.STOP) || (this.serverState = A.STOP,
                this.interface.logout(),
                this.unsendTask = [],
                this.sendTask = [],
                this.scheduleTimer && self.clearInterval(this.scheduleTimer),
                this.connection && (this.connection.close(),
                this.connection = null))
            }
            ,
            e.prototype.processCmd = function(e, t, r) {
                var i = this.cmdMap.get(e);
                if (!i)
                    return !1;
                var n = this.createTask(e, t, r);
                if (this.canSend(e)) {
                    n.seq = this.getSeq();
                    var a = i.createMessage(e, n.seq, t);
                    return this.sendTask.push(n),
                    this.send(a),
                    i.afterSend(n),
                    !0
                }
                return this.canStaged(e) ? (this.unsendTask.push(n),
                !1) : void 0
            }
            ,
            e.prototype.onRecv = function(e) {
                var t, r;
                if (this.serverState !== A.STOP) {
                    var i = this.splitJson(e);
                    if (null === i)
                        return Ar.warn(this.getLogHeader(), this.getLogStatus(), "Recv package not json format: " + e + "."),
                        void (this.messageCache = "");
                    try {
                        for (var n = C(i), a = n.next(); !a.done; a = n.next()) {
                            var o = a.value;
                            this.onRecvOnePack(o)
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            a && !a.done && (r = n.return) && r.call(n)
                        } finally {
                            if (t)
                                throw t.error
                        }
                    }
                }
            }
            ,
            e.prototype.onClose = function() {
                this.serverState !== A.STOP && (Ar.info(this.getLogHeader(), this.getLogStatus(), "WebSocket onClose."),
                this.changeSendTask2UnSend(),
                this.reconnect(!1))
            }
            ,
            e.prototype.onConnect = function(e) {
                if (this.serverState !== A.STOP) {
                    var t = {
                        svrType: Y.WebSocket,
                        svrIP: this.address.ip,
                        svrPort: this.address.port,
                        errCode: ne.WebSocketonConnect,
                        connectElapse: e,
                        taskType: this.getTaskType() === B.Vod ? 0 : 9999
                    };
                    re.getInstance().reportSvrQuality(t),
                    this.totalConnectErrorTime = 0,
                    this.connectErrorTime = 0,
                    Ar.info(this.getLogHeader(), this.getLogStatus(), "WebSocket connect success.")
                }
            }
            ,
            e.prototype.onError = function(e) {
                if (this.serverState !== A.STOP) {
                    if (this.totalConnectErrorTime += 1,
                    this.connectErrorTime += 1,
                    Ar.error(this.getLogHeader(), this.getLogStatus(), "WebSocket connect failed:" + e + " errorTime:[" + this.connectErrorTime + "," + this.totalConnectErrorTime + "]."),
                    this.totalConnectErrorTime >= Lr.p2pWebSockMaxRetryTimes)
                        return this.close(),
                        void Ar.warn(this.getLogHeader(), this.getLogStatus(), "WebSocket can't connect server,close.");
                    this.changeSendTask2UnSend(),
                    this.connectErrorTime < Lr.p2pServerRetryTimes ? (this.nextConnectTick = Tr.getTick() + Lr.p2pServerRetryInternal,
                    this.reconnect(!1)) : (this.connectErrorTime = 0,
                    this.reconnect(!0),
                    this.reportError())
                }
            }
            ,
            e.prototype.reconnect = function(e) {
                e && (this.addressIndex += 1,
                this.setAddress()),
                this.connection.close(),
                this.loginState = _.UNLOGIN,
                this.nextConnectTick = Tr.getTick() + Lr.p2pServerRetryInternal,
                this.connection = new ar(this.address,this)
            }
            ,
            e.prototype.onLoginSuccess = function(e, t) {
                this.interface.setUin(e),
                this.interface.setUinToken(t),
                this.loginState = _.LOGIN,
                Ar.info(this.getLogHeader(), this.getLogStatus(), "Login Success uin:" + e + "."),
                ut.getInstance().reportResource2Server(!0, !0)
            }
            ,
            e.prototype.onLoginFail = function() {
                this.loginState = _.LOG_ERROR,
                Ar.error(this.getLogHeader(), this.getLogStatus(), "Login error!")
            }
            ,
            e.prototype.createTask = function(e, t, r) {
                return ee.isTask(t[0]) ? t[0] : ee.getTask(this.interface, r, t, e)
            }
            ,
            e.prototype.schedule = function() {
                this.serverState !== A.STOP && this.connection && this.checkConnect() && (this.checkTimeout(),
                this.checkLogin() && (this.dealUnsendPack(),
                this.checkHeartBeat()))
            }
            ,
            e.prototype.checkConnect = function() {
                return this.connection.getState() === R.CONNECTED || (this.connection.getState() === R.UNCONNECTED && (0 === this.nextConnectTick || Tr.getTick() >= this.nextConnectTick) && (this.connection.connect(),
                Ar.debug(this.getLogHeader(), this.getLogStatus(), "WebSocket connecting server.")),
                !1)
            }
            ,
            e.prototype.checkLogin = function() {
                return this.loginState === _.LOGIN || (this.loginState === _.UNLOGIN && this.interface.login(),
                !1)
            }
            ,
            e.prototype.checkTimeout = function() {
                if (0 !== this.sendTask.length)
                    for (var e = 0, t = this.sendTask.length; e < t; e++) {
                        var r = this.sendTask[e];
                        if (r.sendTick + 1e3 * Lr.p2pSendPackTimeout <= Tr.getTick()) {
                            Ar.info(this.getLogHeader(), this.getLogStatus(), "SendTask timeout," + Q[r.cmd] + ".");
                            var i = this.cmdMap.get(r.cmd).getRetryDelay(r);
                            i >= 0 && this.resend(r, i),
                            this.taskTimeout(r),
                            this.sendTask.splice(e, 1),
                            e -= 1,
                            t -= 1
                        }
                    }
            }
            ,
            e.prototype.checkHeartBeat = function() {
                this.needHeartBeat() && (this.heartBeatTick = Tr.getTick(),
                this.interface.heartBeat(0, 0, 0, 0, 25, 0))
            }
            ,
            e.prototype.needHeartBeat = function() {
                return 0 === this.heartBeatTick || Tr.getTick() - this.heartBeatTick >= 1e3 * Lr.heartbeatInterval
            }
            ,
            e.prototype.resend = function(e, t) {
                var r = this;
                void 0 === t && (t = 0),
                e.sendTick = Tr.getTick() + t,
                e.retryCount += 1,
                Ar.debug(this.getLogHeader(), this.getLogStatus(), "Resend " + Q[e.cmd] + " delay: " + t + "ms."),
                e.cmd === Q.LOGIN ? (this.loginState = _.WAIT_LOGIN,
                self.setTimeout((function() {
                    r.interface.login(e)
                }
                ), t)) : this.unsendTask.push(e)
            }
            ,
            e.prototype.dealUnsendPack = function() {
                for (var e = 0, t = this.unsendTask.length; e < t; e++) {
                    var r = this.unsendTask[e];
                    r.sendTick <= Tr.getTick() && (r.func.call(r.obj, r),
                    this.unsendTask.splice(e, 1),
                    e -= 1,
                    t -= 1)
                }
            }
            ,
            e.prototype.taskTimeout = function(e) {
                var t;
                null === (t = this.cmdMap.get(e.cmd)) || void 0 === t || t.onTimeout(e)
            }
            ,
            e.prototype.splitJson = function(e) {
                var t = []
                  , r = this.messageCache + e;
                if (r.length >= 1 && "{" !== r.charAt(0))
                    return null;
                for (var i = 0, n = 0, a = 0, o = a; o < r.length; o++)
                    if ("{" === r.charAt(o) ? i += 1 : "}" === r.charAt(o) && (n += 1),
                    i === n && i > 0) {
                        var s = r.substr(a, o + 1);
                        a = o + 1,
                        t.push(s),
                        i = 0,
                        n = 0
                    }
                return a < r.length && (this.messageCache = r.substr(a, r.length - a)),
                t
            }
            ,
            e.prototype.onRecvOnePack = function(e) {
                try {
                    var t = JSON.parse(e)
                      , r = t.header.cmd
                      , i = this.cmdMap.get(r);
                    if (i) {
                        var n = this.popSendPack(t);
                        null === n && (n = {
                            obj: this.interface
                        }),
                        t.body.ret_code && t.body.ret_code !== X.OK ? (this.onRecvError(n, t, i),
                        i.onError(n, t)) : i.onRecv(n, t)
                    } else
                        Ar.warn(this.getLogHeader(), this.getLogStatus(), "Unkonwn recv package: " + e)
                } catch (t) {
                    Ar.warn(this.getLogHeader(), this.getLogStatus(), "Recv package not json format: " + e + ".")
                }
            }
            ,
            e.prototype.popSendPack = function(e) {
                for (var t = 0; t < this.sendTask.length; t++)
                    if (e.header.seq === this.sendTask[t].seq) {
                        var r = this.sendTask[t];
                        return this.sendTask.splice(t, 1),
                        r
                    }
                return null
            }
            ,
            e.prototype.onRecvError = function(e, t, r) {
                if (Ar.info(this.getLogHeader(), this.getLogStatus(), "Recv error: " + X[t.body.ret_code] + ",errorCmd:" + Q[t.header.cmd] + "."),
                t.body.ret_code !== X.ERR_INVALID_SESSION) {
                    var i = r.getRetryDelay(e, t);
                    i >= 0 && this.resend(e, i)
                } else
                    this.interface.relogin()
            }
            ,
            e.prototype.isWrongUinToken = function(e) {
                return this.getUin() !== e.header.uin || this.getUinToken() !== e.header.uin_token
            }
            ,
            e.prototype.canSend = function(e) {
                return this.connection.getState() === R.CONNECTED && (e === Q.LOGIN || this.loginState === _.LOGIN)
            }
            ,
            e.prototype.canStaged = function(e) {
                switch (e) {
                case Q.LOGIN:
                case Q.QUERY_TPT:
                case Q.SIGNAL_RELAY:
                    return !0;
                default:
                    return !1
                }
            }
            ,
            e.prototype.send = function(e) {
                var t;
                (null === (t = this.connection) || void 0 === t ? void 0 : t.getState()) === R.CONNECTED && this.connection.send(e)
            }
            ,
            e.prototype.changeSendTask2UnSend = function() {
                this.unsendTask = this.sendTask.concat(this.unsendTask),
                this.sendTask = []
            }
            ,
            e.prototype.reportError = function() {
                var e = re.getInstance().lastWebSocketErrorInfo;
                if (e) {
                    var t = {
                        svrType: Y.WebSocket,
                        svrIP: e.ip,
                        svrPort: e.port,
                        errCode: ne.WebSocketonError,
                        svrRetCode: e.retCode,
                        taskType: this.getTaskType() === B.Vod ? 0 : 9999
                    };
                    re.getInstance().reportSvrQuality(t)
                }
            }
            ,
            e.prototype.getLogStatus = function() {
                return "connect:" + R[this.connection.getState()] + ",login:" + _[this.loginState] + ",address:" + this.address.ip + (this.address.port ? ":" + this.address.port : "") + "."
            }
            ,
            e
        }(), sr = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.prototype.getTaskType = function() {
                return B.Vod
            }
            ,
            t.prototype.getLogHeader = function() {
                return "VodServer"
            }
            ,
            t.prototype.setAddress = function() {
                this.address = J.vodPeerServer[this.addressIndex % J.vodPeerServer.length]
            }
            ,
            t.prototype.createService = function() {
                new rr(this.cmdMap,this),
                new ir(this.cmdMap,this),
                new nr(this.cmdMap,this)
            }
            ,
            t
        }(or), lr = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.prototype.getTaskType = function() {
                return B.Live
            }
            ,
            t.prototype.getLogHeader = function() {
                return "LiveServer"
            }
            ,
            t.prototype.setAddress = function() {
                this.address = J.livePeerServer[this.addressIndex % J.livePeerServer.length]
            }
            ,
            t.prototype.createService = function() {
                new rr(this.cmdMap,this),
                new ir(this.cmdMap,this)
            }
            ,
            t
        }(or), cr = function() {
            function e() {
                this.uin = 0,
                this.uinToken = "",
                this.createServer()
            }
            return e.prototype.init = function() {
                this.server.init()
            }
            ,
            e.prototype.destroy = function() {
                this.server.destroy()
            }
            ,
            e.prototype.login = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                if (this.server.loginState !== _.LOGIN && this.server.loginState !== _.LOGINING)
                    return this.server.loginState = _.LOGINING,
                    this.server.processCmd(Q.LOGIN, e, this.login)
            }
            ,
            e.prototype.logout = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                if (this.server.loginState === _.LOGIN)
                    return this.server.loginState = _.LOGOUT,
                    this.server.processCmd(Q.LOGOUT, e, this.logout)
            }
            ,
            e.prototype.heartBeat = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                return this.server.processCmd(Q.HEARTBEAT, e, this.heartBeat)
            }
            ,
            e.prototype.report = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                return this.server.processCmd(Q.REPORT, e, this.report)
            }
            ,
            e.prototype.querySeed = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                return this.server.processCmd(Q.QUERY_SEED, e, this.querySeed)
            }
            ,
            e.prototype.queryTPT = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                return this.server.processCmd(Q.QUERY_TPT, e, this.queryTPT)
            }
            ,
            e.prototype.forward = function() {
                for (var e = [], t = 0; t < arguments.length; t++)
                    e[t] = arguments[t];
                return this.server.processCmd(Q.SIGNAL_RELAY, e, this.forward)
            }
            ,
            e.prototype.sendBye2Client = function(e, t, r) {
                var i = JSON.stringify(ee.byeNotify(this, e, t, r));
                return this.server.processCmd(Q.SIGNAL_RELAY, [e, i], this.forward)
            }
            ,
            e.prototype.relogin = function() {
                this.server.loginState = _.UNLOGIN,
                this.login()
            }
            ,
            e.prototype.setUin = function(e) {
                this.uin = e
            }
            ,
            e.prototype.getUin = function() {
                return this.uin
            }
            ,
            e.prototype.setUinToken = function(e) {
                this.uinToken = e
            }
            ,
            e.prototype.getUinToken = function() {
                return this.uinToken
            }
            ,
            e.prototype.isLogin = function() {
                return this.server.loginState === _.LOGIN
            }
            ,
            e
        }(), hr = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.getInstance = function() {
                return void 0 === t.instance && (t.instance = new t),
                t.instance
            }
            ,
            t.prototype.destroy = function() {
                Ar.info("VodServer", "", "VodServerInterface destroy."),
                t.instance = void 0,
                e.prototype.destroy.call(this)
            }
            ,
            t.prototype.createServer = function() {
                this.server = new sr(this)
            }
            ,
            t
        }(cr), ur = function(e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }
            return E(t, e),
            t.getInstance = function() {
                return void 0 === t.instance && (t.instance = new t),
                t.instance
            }
            ,
            t.prototype.destroy = function() {
                Ar.info("LiveServer", "", "LiveServerInterface destroy."),
                t.instance = void 0,
                e.prototype.destroy.call(this)
            }
            ,
            t.prototype.createServer = function() {
                this.server = new lr(this)
            }
            ,
            t
        }(cr), dr = {
            android_1: /android[\s/]([\d.]+)/i,
            android_2: /android/i,
            android_3: /MIDP-/i,
            ipod_1: /iPod\stouch;\sCPU\siPhone\sos\s([\d_]+)/i,
            ipod_2: /iPod.*os\s?([\d_.]+)/i,
            iphone_1: /iPhone;\sCPU\siPhone\sos\s([\d_]+)/i,
            iphone_2: /iPhone.*os\s?([\d_.]+)/i,
            ipad_1: /ipad;\scpu\sos\s([\d_]+)/i,
            ipad_2: /ipad([\d]+)?/i,
            windows: /windows\snt\s([\d.]+)/i,
            mac: /Macintosh.*mac\sos\sx\s([\d_.]+)/i,
            nintendo: /Nintendo Switch/i,
            tesla: /tesla/i,
            linux: /linux/i
        }, fr = {
            weishi: /WEISHI_([\d.]+)/i,
            toutiao: /TTWebView\/([\d.]+)/i,
            wechat: /MicroMessenger\/([\d.]+)/i,
            ipadqq: /IPadQQ\/([\d.]+)/i,
            mqq: /qq\/([\d.]+)/i,
            qzone: /QZONEJSSDK\/([\d.]+)/i,
            mqqbrowser: /mqqbrowser\/([\d.]+)/i,
            qqbrowser: /[^m]QQBrowser\/([\d.]+)/i,
            x5: /tbs\/(\d+)/i,
            uc: /UCBrowser\/([\d.]+)/i,
            safari: /Version\/([\d.]+)( Mobile\S*)? Safari\/([\d.]+)/i,
            firefox: /Firefox\/([\d.]+)/i,
            opera: /OPR\/([\d.]+)/i,
            ie_1: /MSIE\s([\d.]+)/i,
            ie_2: /(trident\/\d\.\d)/i,
            ie_3: /(Edge)\/\d+\.\d+/i,
            weibo: /weibo__([\d.]+)/i,
            qqnewsAd: /TADChid\/([\d.]+)/i,
            qqnews: /qqnews\/([\d.]+)/i,
            tenvideo_1: /QQLiveBrowser\/([\d.]+)/i,
            tenvideo_2: /QQLiveHDBrowser\/([\d.]+)/i,
            kuaibao: /qnreading\/([\d.]+)/i,
            liebao: /LieBaoFast\/([\d.]+)/i,
            douban: /com\.douban\.frodo\/([\d.]+)/i,
            miuibrowser: /MiuiBrowser/i,
            baidu: /baiduboxapp/i,
            browser360: /360browser/i,
            oppobrowser: /OppoBrowser/i,
            chrome_1: /CriOS\/([\d.]+)/i,
            chrome_2: /Chrome\/([\d.]+)/i,
            qqdownloader: /qqdownloader\/([\d.]+)/i,
            nintendo: /NintendoBrowser\/([\d.]+)/i,
            tesla: /QtCarBrowser/i
        }, pr = {
            "4.0": "8",
            "5.0": "9",
            "6.0": "10",
            "7.0": "11"
        }, gr = function() {
            function e() {}
            return e.uaMatch = function(t) {
                var r, i = t || (null === (r = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === r ? void 0 : r.userAgent), n = {};
                return n.os = e.getOS(i),
                n.browser = e.getBrowser(i),
                n.isMobile = e.isMobile(i),
                n
            }
            ,
            e.isMobile = function(e) {
                var t, r = e || (null === (t = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === t ? void 0 : t.userAgent);
                return /(mobile)/i.test(r)
            }
            ,
            e.getOS = function(e) {
                var t, r = {
                    name: "",
                    version: ""
                }, i = e || (null === (t = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === t ? void 0 : t.userAgent);
                return Object.keys(dr).every((function(e) {
                    var t = dr[e].exec(i);
                    if (!t)
                        return !0;
                    var n = e.replace(/_\d+/, "");
                    return r[n] = !0,
                    r.name = n,
                    t[1] && (r.version = t[1].replace(/_/g, ".")),
                    !1
                }
                )),
                (r.iphone || r.ipad || r.ipod) && (r.ios = !0),
                r
            }
            ,
            e.getBrowser = function(e) {
                var t, r = {}, i = e || (null === (t = null === window || void 0 === window ? void 0 : window.navigator) || void 0 === t ? void 0 : t.userAgent);
                return Object.keys(fr).forEach((function(e) {
                    var t, n = fr[e].exec(i);
                    if (n) {
                        var a = e.replace(/_\d+/, "");
                        r[a] || (r[a] = {
                            version: (null === (t = n[1]) || void 0 === t ? void 0 : t.replace(/_/g, ".")) || ""
                        })
                    }
                }
                )),
                r.ie && /trident/i.test(i) && (r.ie.version = pr[r.ie.version] || "11"),
                r
            }
            ,
            e
        }(), vr = gr.uaMatch;
        (jt = Vt || (Vt = {}))[jt.equal = 0] = "equal",
        jt[jt.low = -1] = "low",
        jt[jt.high = 1] = "high";
        var yr, mr = function() {
            function e() {}
            return e.getTick = function() {
                return -1 === this.initTime && (this.initTime = performance.now()),
                performance.now() - this.initTime
            }
            ,
            e.setUserAgentInfo = function() {
                var e, t;
                this.initTime = performance.now();
                var r = navigator.userAgent || "";
                if ("" !== r) {
                    var i = vr(r);
                    J.osVer = i.os.name + " " + i.os.version,
                    J.browserVer = Object.getOwnPropertyNames(i.browser)[0] + " " + (null === (e = i.browser[Object.getOwnPropertyNames(i.browser)[0]]) || void 0 === e ? void 0 : e.version)
                }
                var n = navigator.hardwareConcurrency || window.navigator.hardwareConcurrency;
                n && (J.cpuThreads = n);
                var a = null === (t = null === performance || void 0 === performance ? void 0 : performance.memory) || void 0 === t ? void 0 : t.jsHeapSizeLimit;
                a && (J.heapSizeLimit = a / 1024 / 1024)
            }
            ,
            e.openP2P = function(t) {
                this.p2pOpened || ($t.getInstance().init(),
                this.p2pOpened = !0),
                t !== B.Vod || this.vodP2POpended ? t !== B.Live || this.liveP2POpended || (Ar.info("Global", "", "Open live P2P."),
                ur.getInstance().init(),
                this.liveP2POpended = !0,
                le.initP2PTime = e.getTick()) : (Ar.info("Global", "", "Open vod P2P."),
                hr.getInstance().init(),
                Lr.vodUseDbCache && ut.getInstance().initDBCache(),
                this.vodP2POpended = !0,
                le.initP2PTime = e.getTick())
            }
            ,
            e.stopP2P = function() {
                this.p2pOpened && (Ar.info("Global", "", "Stop P2P."),
                $t.getInstance().destroy(),
                ut.getInstance().stopP2P(),
                this.p2pOpened = !1),
                this.vodP2POpended && (hr.getInstance().destroy(),
                this.vodP2POpended = !1),
                this.liveP2POpended && (ur.getInstance().destroy(),
                this.liveP2POpended = !1)
            }
            ,
            e.parseUrl = function(e) {
                var t;
                if (!e || 0 === e.length)
                    return null;
                var r = {}
                  , i = e.match(/^(https|http)?:\/\/([^/:]+):?(\d+)?(\/.+)+\?(.*)$/);
                if (null !== i && i.length > 4) {
                    r.filename = null,
                    r.params = new Map,
                    t = L(i, 5),
                    r.protocol = t[1],
                    r.host = t[2],
                    r.port = t[3],
                    r.path = t[4],
                    void 0 === r.port && (r.port = this.getDefaultPort(r.protocol));
                    var n = i[5];
                    n && (r.params = this.praseParams(n))
                }
                return r
            }
            ,
            e.getReurlValue = function(e, t) {
                var r = this.praseParams(e)[t];
                return r || 0
            }
            ,
            e.deepcopy = function(e) {
                var t, r, i, n = e.constructor === Array ? [] : {};
                if ("object" != typeof e)
                    return e;
                if (window.JSON)
                    i = JSON.stringify(e),
                    n = JSON.parse(i);
                else
                    try {
                        for (var a = C(Object.entries(e)), o = a.next(); !o.done; o = a.next()) {
                            var s = L(o.value, 2)
                              , l = s[0]
                              , c = s[1];
                            n[l] = "object" == typeof c ? this.cloneObj(c) : c
                        }
                    } catch (e) {
                        t = {
                            error: e
                        }
                    } finally {
                        try {
                            o && !o.done && (r = a.return) && r.call(a)
                        } finally {
                            if (t)
                                throw t.error
                        }
                    }
                return n
            }
            ,
            e.getChecksum = function(e) {
                for (var t = window.crcTable || (window.crcTable = this.makeCRCTable()), r = -1, i = new Uint8Array(e), n = i.byteLength, a = n >= J.PIECE_SIZE ? this.magicNum : 1, o = 0; o < n; o += a)
                    r = t[255 & (r ^ i[o])] ^ r >>> 8;
                return (4294967295 ^ r) >>> 0
            }
            ,
            e.getReportVersion = function() {
                return J.abTestID < 0 ? J.version : J.version + "." + J.abTestID
            }
            ,
            e.bkdrHash = function(e) {
                for (var t = BigInt(131), r = BigInt(0), i = 0; i < e.length; i++)
                    r = r * t + BigInt(e.charCodeAt(i));
                return (r = (((r %= BigInt("0xffffffffffffff")) & BigInt("0xfffffffffe0000")) << BigInt(5)) + BigInt("0x80000") + (r & BigInt("0x1ffff"))).toString()
            }
            ,
            e.isSameAddr = function(e, t) {
                return e.ip === t.ip && e.port === t.port
            }
            ,
            e.praseParams = function(e) {
                var t, r, i = e.split("&"), n = {};
                try {
                    for (var a = C(i), o = a.next(); !o.done; o = a.next()) {
                        var s = o.value.split("=");
                        2 === s.length && (n[s[0]] = s[1])
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        o && !o.done && (r = a.return) && r.call(a)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
                return n
            }
            ,
            e.makeCRCTable = function() {
                for (var e, t = [], r = 0; r < 256; r++) {
                    e = r;
                    for (var i = 0; i < 8; i++)
                        e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                    t[r] = e
                }
                return t
            }
            ,
            e.cloneObj = function(e) {
                return JSON.parse(JSON.stringify(e))
            }
            ,
            e.getDefaultPort = function(e) {
                return "http" === e ? 80 : 443
            }
            ,
            e.vodP2POpended = !1,
            e.p2pOpened = !1,
            e.liveP2POpended = !1,
            e.magicNum = 100,
            e.initTime = -1,
            e
        }(), Tr = mr, Sr = {
            PIECE_COMPLETE: 1,
            PIECE_TIMEOUT: 2,
            PIECE_HTTP_CHOOSE: 3,
            Piece_ELIMINAte: 4
        };
        !function(e) {
            e[e.Window_Piece_Slow = 0] = "Window_Piece_Slow",
            e[e.Window_Piece_Fast = 1] = "Window_Piece_Fast",
            e[e.Window_Block_Slow = 2] = "Window_Block_Slow",
            e[e.Window_Block_Fast = 3] = "Window_Block_Fast"
        }(yr || (yr = {}));
        var Ir = {
            min: 500,
            max: 3e3
        }
          , Pr = function() {
            function e(e) {
                this.keyID = e,
                this.downloadingMap = new Map,
                this.mode = Lr.slidingWindowMode,
                this.mode === yr.Window_Piece_Fast || this.mode === yr.Window_Piece_Slow ? (this.curWindowSize = Lr.minPieceWindowSize,
                this.minWindowSize = Lr.minPieceWindowSize,
                this.maxWindowSize = Lr.maxPieceWindowSize) : (this.curWindowSize = Lr.minBlockWindowSize,
                this.minWindowSize = Lr.minBlockWindowSize,
                this.maxWindowSize = Lr.maxBlockWindowSize),
                this.qos = Lr.minPeerQos,
                this.succeed = 0,
                this.failed = 0,
                this.windowSizeDelta = 0,
                this.rto = 1e3,
                this.recvTimeout = 2 * this.rto,
                this.rtoArray = [{
                    range: {
                        min: 0,
                        max: 199
                    },
                    count: 0
                }, {
                    range: {
                        min: 200,
                        max: 499
                    },
                    count: 0
                }, {
                    range: {
                        min: 500,
                        max: 999
                    },
                    count: 0
                }, {
                    range: {
                        min: 1e3,
                        max: 1999
                    },
                    count: 0
                }, {
                    range: {
                        min: 2e3,
                        max: 2999
                    },
                    count: 0
                }, {
                    range: {
                        min: 3e3,
                        max: 4999
                    },
                    count: 0
                }, {
                    range: {
                        min: 5e3,
                        max: 5e5
                    },
                    count: 0
                }]
            }
            return e.prototype.getFreeWindowSize = function() {
                var e = this.curWindowSize - this.downloadingMap.size;
                return e >= 0 ? e : 0
            }
            ,
            e.prototype.canDownload = function() {
                return this.getFreeWindowSize() >= this.minWindowSize
            }
            ,
            e.prototype.getQos = function() {
                return this.qos
            }
            ,
            e.prototype.getQosLog = function() {
                return "rto:" + this.rto + " recvTimeout:" + this.recvTimeout + " suc:" + this.succeed + " failed:" + this.failed + " qos:" + this.qos
            }
            ,
            e.prototype.addPiece = function(e, t, r, i) {
                for (var n = Tr.getTick(), a = r + i, o = r; o < a; o++) {
                    var s = this.getkey(e, t, o);
                    if (!this.downloadingMap.has(s)) {
                        var l = {
                            tsNo: e,
                            blockNo: t,
                            pieceNo: o,
                            dTimeStamp: n
                        };
                        this.downloadingMap.set(s, l)
                    }
                }
            }
            ,
            e.prototype.delPiece = function(e, t, r, i) {
                var n = this.getkey(e, t, r)
                  , a = this.downloadingMap.get(n);
                a ? (this.calcQos(i),
                i === Sr.PIECE_COMPLETE ? (this.calcRto(a.dTimeStamp),
                le.getItem(this.keyID).validDataRspCount += 1,
                this.increaseWindowSize()) : i === Sr.PIECE_TIMEOUT && (this.decreaseWindowSize(),
                this.mode = 2 * Math.floor(this.mode / 2)),
                this.downloadingMap.delete(n),
                Ar.debug("PeerConnection", "", "delete piece " + n + " for " + i)) : (le.getItem(this.keyID).redundancyDataCount += 1,
                Ar.debug("PeerConnection", "", "redundancyDataCount piece " + n + " for " + i))
            }
            ,
            e.prototype.calcQos = function(e) {
                e === Sr.PIECE_COMPLETE ? this.succeed += 1 : e === Sr.PIECE_TIMEOUT && (this.failed += 1);
                var t = this.succeed + this.failed;
                t > 0 && (this.qos = this.succeed / t * 1e4)
            }
            ,
            e.prototype.deleteTimeoutPieces = function() {
                var e, t, r, i, n = Tr.getTick(), a = [];
                try {
                    for (var o = C(this.downloadingMap.values()), s = o.next(); !s.done; s = o.next()) {
                        var l = s.value
                          , c = Lr.useDynamicRecvTimeout ? Math.min(1e3 * Lr.maxP2PRecvTimeout, this.recvTimeout) : Lr.maxP2PRecvTimeout;
                        n - l.dTimeStamp > c && a.push(l)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        s && !s.done && (t = o.return) && t.call(o)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                try {
                    for (var h = C(a), u = h.next(); !u.done; u = h.next()) {
                        l = u.value;
                        this.delPiece(l.tsNo, l.blockNo, l.pieceNo, Sr.PIECE_TIMEOUT)
                    }
                } catch (e) {
                    r = {
                        error: e
                    }
                } finally {
                    try {
                        u && !u.done && (i = h.return) && i.call(h)
                    } finally {
                        if (r)
                            throw r.error
                    }
                }
                return a
            }
            ,
            e.prototype.getAllDownloadingPiece = function() {
                var e, t, r = [];
                try {
                    for (var i = C(this.downloadingMap.values()), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value;
                        r.push(a)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        n && !n.done && (t = i.return) && t.call(i)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                return r
            }
            ,
            e.prototype.deleteAllDownloadingPiece = function() {
                var e, t;
                try {
                    for (var r = C(this.downloadingMap.values()), i = r.next(); !i.done; i = r.next()) {
                        var n = i.value;
                        this.delPiece(n.tsNo, n.blockNo, n.pieceNo, Sr.Piece_ELIMINAte)
                    }
                } catch (t) {
                    e = {
                        error: t
                    }
                } finally {
                    try {
                        i && !i.done && (t = r.return) && t.call(r)
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
            }
            ,
            e.prototype.getRtoRange = function() {
                if (this.succeed <= 30)
                    return Ir;
                for (var e = this.rtoArray[0].count, t = 0, r = 1; r < this.rtoArray.length; r++)
                    e < this.rtoArray[r].count && (e = this.rtoArray[r].count,
                    t = r);
                return e / this.succeed >= .5 ? this.rtoArray[t].range : Ir
            }
            ,
            e.prototype.calcRto = function(e) {
                var t = Tr.getTick() - e;
                this.add2RtoArray(t),
                this.rto = (this.rto * this.succeed + t) / (this.succeed + 1);
                var r = this.getRtoRange();
                this.rto > r.max ? this.rto = r.max : this.rto < r.min && (this.rto = r.min),
                this.recvTimeout = 2 * this.rto
            }
            ,
            e.prototype.increaseWindowSize = function() {
                switch (this.mode) {
                case yr.Window_Block_Fast:
                case yr.Window_Piece_Fast:
                    this.curWindowSize += 1;
                    break;
                case yr.Window_Block_Slow:
                case yr.Window_Piece_Slow:
                    this.curWindowSize < this.maxWindowSize ? this.curWindowSize += 1 : this.curWindowSize === this.maxWindowSize ? (this.windowSizeDelta = 0 - this.curWindowSize,
                    this.curWindowSize += 1) : this.curWindowSize > this.maxWindowSize && (this.windowSizeDelta += 1,
                    0 === this.windowSizeDelta && (this.curWindowSize += 1,
                    this.windowSizeDelta = 0 - this.curWindowSize))
                }
            }
            ,
            e.prototype.decreaseWindowSize = function() {
                this.curWindowSize > this.downloadingMap.size && this.curWindowSize - 1 > this.minWindowSize && (this.curWindowSize -= 1)
            }
            ,
            e.prototype.getkey = function(e, t, r) {
                return e + "_" + t + "_" + r
            }
            ,
            e.prototype.getRtoArrayIndex = function(e) {
                var t = 0;
                return e >= 0 && e < 200 ? t = 0 : e >= 200 && e <= 500 ? t = 1 : e >= 500 && e <= 1e3 ? t = 2 : e >= 1e3 && e <= 3e3 ? t = 3 : e >= 3e3 && e <= 5e3 ? t = 4 : e >= 5e3 && (t = 5),
                t
            }
            ,
            e.prototype.add2RtoArray = function(e) {
                var t, r;
                try {
                    for (var i = C(this.rtoArray), n = i.next(); !n.done; n = i.next()) {
                        var a = n.value;
                        a.range.min >= e && a.range.max <= e && (a.count += 1)
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        n && !n.done && (r = i.return) && r.call(i)
                    } finally {
                        if (t)
                            throw t.error
                    }
                }
            }
            ,
            e
        }()
          , br = {
            reqConfigInterval: 1800,
            sendDataScheduleInterval: 30,
            downloadScheduleInterval: 1e3,
            commitBlockCntPerTime: 16,
            vodDownloadStrategy: z.Watch_Time_Adjust,
            liveDownloadStrategy: K.Part_TS_Download,
            maxCacheSize: 104857600,
            notPlayingReleaseRatio: 0,
            p2pDownloadMemoryRatio: 10,
            httpDownloadMemoryRatio: 20,
            vodFragKeepAfterReadIndex: 5,
            liveFragKeepBeforeReadIndex: 10,
            useAdaptiveCache: !0,
            defaultCacheSize: 104857600,
            maxCacheSizeLevel0: 104857600,
            maxCacheSizeLevel1: 157286400,
            maxCacheSizeLevel2: 209715200,
            maxCacheSizeLevel3: 314572800,
            vodUseDbCache: !1,
            releaseDBSize: 52428800,
            maxAccessDBCacheErrorTimes: Number.MAX_SAFE_INTEGER,
            canWriteWhileDeletingDB: !0,
            readDBtimeout: 500,
            isUseRange: !0,
            useTimeoutCtrl: !0,
            fetchRecvTimeout: 8e3,
            fetchConnectTimeout: 3e3,
            xhrRecvTimeout: 1e4,
            xhrConnectTimeout: 3e3,
            enableCDNSlowCallback: !0,
            lowSpeedRatio: 1,
            maxLowSpeedCount: 8,
            minReportErrorTime: 5,
            httpMaxFailedTimes: 3,
            preloadStartHTTPTime: 3,
            vodAdjustHttpBufferTime: "0-19 90 120,19-24 30 60",
            vodImmediateDownloadTime: 20,
            vodDefaultEmergencyTime: 30,
            vodDefaultSafeTime: 60,
            vodNotP2PEmergencyTime: 45,
            vodNotP2PSafeTime: 60,
            vodWatchTime10EmergencyTime: 20,
            vodWatchTime10SafeTime: 30,
            vodWatchTime30EmergencyTime: 25,
            vodWatchTime30SafeTime: 40,
            vodWatchTime60EmergencyTime: 30,
            vodWatchTime60SafeTime: 50,
            vodUsePlayPoint: !1,
            liveImmediateDownloadTime: 2,
            liveDefaultEmergencyTime: 4,
            liveDefaultSafeTime: 8,
            liveNotP2PEmergencyTime: 6,
            liveNotP2PSafeTime: 12,
            liveDownloadExpiredTs: !1,
            liveDownloadExpiredTsTime: 100,
            liveDownloadExpiredTSNum: 1,
            liveDownloadPartNum: 4,
            useP2P: !0,
            webrtcOrdered: !1,
            webrtcMaxPacketLifeTime: 1e3,
            useSlidingWindow: !0,
            slidingWindowMode: yr.Window_Piece_Fast,
            minPieceWindowSize: 8,
            maxPieceWindowSize: 64,
            minBlockWindowSize: 64,
            maxBlockWindowSize: 256,
            querySeedInterval: 5,
            maxQuerySeedNum: 30,
            maxPeerNum: 50,
            reducePeerCount: 30,
            addQuerySeedInterval: 10,
            maxKeepPeerPoolTime: 60,
            reduceIntervalByConnectedNum: !1,
            baseConnectPeerNumber: 4,
            maxConnectPeerNumberOneTime: 1,
            maxBitmapNumber: 30,
            maxP2PRecvTimeout: 3,
            useDynamicRecvTimeout: !1,
            peerBlackTime: 90,
            peerSpareTime: 60,
            maxP2PConnectTimeout: 10,
            maxP2PRecvDataTimeOut: 30,
            minPeerQos: 5e3,
            maxProtectPeerTime: 15,
            maxP2POfflineSendDataTimeOut: 60,
            p2pPeerUploadMsgDead: 40,
            p2pPeerDownloadMsgDead: 40,
            useAdaptiveThreadConfig: !0,
            defaultConnectPeerNumber: 4,
            baseConnectPeerNumberLevel0: 4,
            baseConnectPeerNumberLevel1: 6,
            baseConnectPeerNumberLevel2: 8,
            baseConnectPeerNumberLevel3: 10,
            useDropFrames: !1,
            dropFramesWatchInterval: 15,
            dropRateLevel1: 5,
            dropRateLevel2: 10,
            dropRateLevel3: 15,
            dropFrameReduceLevel1: 1.5,
            dropFrameReduceLevel2: 2,
            dropFrameReduceLevel3: 3,
            preloadP2PDownloadTime: 150,
            maxTsCheckFailTimes: 3,
            maxKeyIDCheckFailTimes: 50,
            maxWrongDataTimes: 1,
            relayLocalCandidate: !0,
            exchangeBitmapImmediate: !1,
            sendPieceNum: 1,
            vodP2PStartTime: 3,
            vodCanUploadTime: 15,
            vodExchangeBitmapInterval: 5,
            vodMaxChooseTsNum: 30,
            vodGenerateFileID: !0,
            vodFileIDTSNum: 15,
            vodDisableP2PInBackground: !1,
            vodConnectPeerInterval: 1,
            liveP2PStartTime: 0,
            liveCanUploadTime: 2,
            liveExchangeBitmapInterval: 1,
            liveMaxChooseTsNum: 10,
            liveConnectPeerInterval: 1,
            webSocketScheduleInternal: 100,
            p2pServerRetryInternal: 3e3,
            p2pServerRetryTimes: 3,
            p2pWebSockMaxRetryTimes: 6,
            p2pSendPackTimeout: 10,
            p2pPackRetryTimes: 3,
            p2pLoginRetryTimes: 3,
            p2pLoginRetryInternal: 1e4,
            heartbeatInterval: 40,
            reportInterval: 60,
            preloadReportInterval: 10,
            playQualityReportRate: 10,
            serverQualityReportRate: 10,
            httpCheckInterval: 5,
            maxLastBitrateCount: 5,
            reportLoadingTime: !0,
            logOpen: !0,
            logLevel: O.info,
            logSize: 5e4,
            logWriteCache: !1,
            logWriteConsole: !1,
            uploadLog: !1,
            uploadLogRate1: 0,
            uploadLogRate2: 0,
            uploadLogRate3: 0,
            isOpenABTest: !1,
            abTestHashKeyUseGUID: !0,
            abTestOption: ""
        }
          , Er = Object.assign({}, br);
        var Dr, kr, Cr, Lr = Er, wr = function() {
            function e(e) {
                this.elements = new Array,
                this.capacity = e
            }
            return e.prototype.push = function(e) {
                return null !== e && (this.elements.push(e),
                void 0 === this.capacity || isNaN(this.capacity) || this.elements.length === this.capacity + 1 && this.pop(),
                !0)
            }
            ,
            e.prototype.erase = function(e) {
                var t = this.elements.findIndex((function(t) {
                    return t === e
                }
                ));
                -1 !== t && this.elements.splice(t, 1)
            }
            ,
            e.prototype.refresh = function(e) {
                this.erase(e),
                this.push(e)
            }
            ,
            e.prototype.pop = function() {
                return this.elements.shift()
            }
            ,
            e.prototype.size = function() {
                return this.elements.length
            }
            ,
            e.prototype.empty = function() {
                return 0 === this.size()
            }
            ,
            e.prototype.clear = function() {
                delete this.elements,
                this.elements = new Array
            }
            ,
            e
        }(), Rr = function() {
            function e() {}
            return e.registerLogger = function(e) {
                this.playerLogger.has(e) || this.playerLogger.add(e)
            }
            ,
            e.unregisterLogger = function(e) {
                this.playerLogger.has(e) && this.playerLogger.delete(e)
            }
            ,
            e.uploadLog = function(e, t) {
                Lr.uploadLog && this.uploadLogFunc && t > 0 && Math.random() * t < 1 && this.uploadLogFunc(e.toString())
            }
            ,
            e.setUploadLog = function(e) {
                this.uploadLogFunc = e
            }
            ,
            e.setLogConfig = function(e, t, r) {
                Lr.logLevel = e,
                Lr.logWriteCache = r,
                Lr.logWriteConsole = t
            }
            ,
            e.debug = function(t, r) {
                for (var i = [], n = 2; n < arguments.length; n++)
                    i[n - 2] = arguments[n];
                e.write.apply(e, w([O.debug, t, r], L(i)))
            }
            ,
            e.info = function(t, r) {
                for (var i = [], n = 2; n < arguments.length; n++)
                    i[n - 2] = arguments[n];
                e.write.apply(e, w([O.info, t, r], L(i)))
            }
            ,
            e.warn = function(t, r) {
                for (var i = [], n = 2; n < arguments.length; n++)
                    i[n - 2] = arguments[n];
                e.write.apply(e, w([O.warn, t, r], L(i)))
            }
            ,
            e.error = function(t, r) {
                for (var i = [], n = 2; n < arguments.length; n++)
                    i[n - 2] = arguments[n];
                e.write.apply(e, w([O.error, t, r], L(i)))
            }
            ,
            e.write = function(t, r, i) {
                for (var n = this, a = [], o = 3; o < arguments.length; o++)
                    a[o - 3] = arguments[o];
                if (Lr.logOpen && t >= Lr.logLevel) {
                    var s = {
                        time: new Date,
                        scope: r,
                        level: t,
                        status: i,
                        msg: w([], L(a)).join("")
                    };
                    if (this.playerLogger.forEach((function(e) {
                        try {
                            e[O[t]]((r ? "[" + r + "]" : "") + (i ? "[" + i + "]" : ""), s.msg)
                        } catch (t) {
                            n.playerLogger.delete(e)
                        }
                    }
                    )),
                    Lr.logWriteCache && e.cache.push(s),
                    Lr.logWriteConsole) {
                        var l = "[" + e.getLogTime(s.time) + "][" + O[t] + "]" + (r ? "[" + r + "]" : "") + (i ? "[" + i + "]" : "");
                        self.console[O[t]](l, s.msg)
                    }
                }
            }
            ,
            e.getLogTime = function(e) {
                var t = e.getMonth() + 1 >= 10 ? (e.getMonth() + 1).toString() : "0" + (e.getMonth() + 1)
                  , r = e.getDate() >= 10 ? e.getDate().toString() : "0" + e.getDate()
                  , i = e.getHours() >= 10 ? e.getHours().toString() : "0" + e.getHours()
                  , n = e.getMinutes() >= 10 ? e.getMinutes().toString() : "0" + e.getMinutes()
                  , a = e.getSeconds() >= 10 ? e.getSeconds().toString() : "0" + e.getSeconds()
                  , o = e.getMilliseconds() >= 10 ? e.getMilliseconds().toString() : "0" + e.getMilliseconds();
                return e.getFullYear() + "-" + t + "-" + r + " " + i + ":" + n + ":" + a + "." + o
            }
            ,
            e.cache = new wr(Lr.logSize),
            e.playerLogger = new Set,
            e
        }(), Ar = Rr, _r = /^age:\s*[\d.]+\s*$/m, xr = function() {
            function e(e) {
                this.loader = null,
                this.config = null,
                this.callbacks = null,
                this.xhrSetup = e ? e.xhrSetup : null,
                this.stats = new Ce,
                this.retryDelay = 0
            }
            return e.prototype.destroy = function() {
                this.callbacks = null,
                this.abortInternal(),
                this.loader = null,
                this.config = null
            }
            ,
            e.prototype.abortInternal = function() {
                var e = this.loader;
                self.clearTimeout(this.requestTimeout),
                self.clearTimeout(this.retryTimeout),
                e && (e.onreadystatechange = null,
                e.onprogress = null,
                4 !== e.readyState && (this.stats.aborted = !0,
                e.abort()))
            }
            ,
            e.prototype.abort = function() {
                var e;
                this.abortInternal(),
                (null === (e = this.callbacks) || void 0 === e ? void 0 : e.onAbort) && this.callbacks.onAbort(this.stats, this.context, this.loader)
            }
            ,
            e.prototype.load = function(e, t, r) {
                if (this.stats.loading.start)
                    throw new Error("Loader can only be used once.");
                this.stats.loading.start = self.performance.now(),
                this.context = e,
                this.config = t,
                this.callbacks = r,
                this.retryDelay = t.retryDelay,
                this.loadInternal()
            }
            ,
            e.prototype.loadInternal = function() {
                var e = this.config
                  , t = this.context;
                if (e) {
                    this.loader = new self.XMLHttpRequest;
                    var r = this.loader
                      , i = this.stats;
                    i.loading.first = 0,
                    i.loaded = 0;
                    var n = this.xhrSetup;
                    try {
                        if (n)
                            try {
                                n(r, t.url)
                            } catch (e) {
                                r.open("GET", t.url, !0),
                                n(r, t.url)
                            }
                        r.readyState || r.open("GET", t.url, !0)
                    } catch (e) {
                        return void this.callbacks.onError({
                            code: r.status,
                            text: e.message
                        }, t, r)
                    }
                    t.rangeEnd && r.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)),
                    r.onreadystatechange = this.readystatechange.bind(this),
                    r.onprogress = this.loadprogress.bind(this),
                    r.responseType = t.responseType,
                    self.clearTimeout(this.requestTimeout),
                    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), e.timeout),
                    r.send()
                }
            }
            ,
            e.prototype.readystatechange = function() {
                var e = this
                  , t = e.context
                  , r = e.loader
                  , i = e.stats;
                if (t && r) {
                    var n = r.readyState
                      , a = this.config;
                    if (!i.aborted && n >= 2)
                        if (self.clearTimeout(this.requestTimeout),
                        0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start)),
                        4 === n) {
                            r.onreadystatechange = null,
                            r.onprogress = null;
                            var o = r.status;
                            if (o >= 200 && o < 300) {
                                i.loading.end = Math.max(self.performance.now(), i.loading.first);
                                var s = void 0
                                  , l = void 0;
                                if (l = "arraybuffer" === t.responseType ? (s = r.response).byteLength : (s = r.responseText).length,
                                i.total = l,
                                i.loaded = i.total,
                                !this.callbacks)
                                    return;
                                var c = this.callbacks.onProgress;
                                if (c && c(i, t, s, r),
                                !this.callbacks)
                                    return;
                                var h = {
                                    url: r.responseURL,
                                    data: s
                                };
                                this.callbacks.onSuccess(h, i, t, r)
                            } else
                                i.retry >= a.maxRetry || o >= 400 && o < 499 ? (Ar.error("NativeLoader", "", o + " while loading " + t.url),
                                this.callbacks.onError({
                                    code: o,
                                    text: r.statusText
                                }, t, r)) : (Ar.warn("NativeLoader", "", o + " while loading " + t.url + ", retrying in " + this.retryDelay + "."),
                                this.abortInternal(),
                                this.loader = null,
                                self.clearTimeout(this.retryTimeout),
                                this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay),
                                this.retryDelay = Math.min(2 * this.retryDelay, a.maxRetryDelay),
                                i.retry += 1)
                        } else
                            self.clearTimeout(this.requestTimeout),
                            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), a.timeout)
                }
            }
            ,
            e.prototype.loadtimeout = function() {
                Ar.warn("NativeLoader", "", "Timeout while loading " + this.context.url + ".");
                var e = this.callbacks;
                e && (this.abortInternal(),
                e.onTimeout(this.stats, this.context, this.loader))
            }
            ,
            e.prototype.loadprogress = function(e) {
                var t = this.stats;
                t.loaded = e.loaded,
                e.lengthComputable && (t.total = e.total)
            }
            ,
            e.prototype.getCacheAge = function() {
                var e = null;
                if (this.loader && _r.test(this.loader.getAllResponseHeaders())) {
                    var t = this.loader.getResponseHeader("age");
                    e = t ? parseFloat(t) : null
                }
                return e
            }
            ,
            e
        }(), Or = function(e) {
            function t(t) {
                var r = e.call(this, t) || this;
                return r.task = null,
                r.useProxy = !1,
                r.task = null,
                r
            }
            return E(t, e),
            t.prototype.destroy = function() {
                this.task && (this.task = null),
                e.prototype.destroy.call(this)
            }
            ,
            t.prototype.load = function(t, r, i) {
                var n, a = this;
                if ("main" !== t.frag.type || "initSegment" === t.frag.sn)
                    e.prototype.load.call(this, t, r, i);
                else {
                    this.useProxy = !0,
                    this.task = Oe.getInstance().getTask(t.frag.ext.keyID);
                    var o = {
                        onSuccess: function(e, r) {
                            i.onSuccess({
                                data: r,
                                url: t.url
                            }, e, t, null)
                        },
                        onError: function(e, r) {
                            i.onError({
                                code: e.code,
                                text: ""
                            }, t, r)
                        },
                        onTimeout: function(e) {
                            i.onError({
                                code: e.code,
                                text: ""
                            }, t, {})
                        },
                        onAbort: function() {
                            i.onAbort && (null == i || i.onAbort(a.stats, t, null))
                        },
                        onProgress: i.onProgress ? function(e, r) {
                            i.onProgress(e, t, r, null)
                        }
                        : void 0
                    };
                    null === (n = this.task) || void 0 === n || n.load(t.frag.sn, o)
                }
            }
            ,
            t.prototype.abort = function() {
                var t;
                this.useProxy ? null === (t = this.task) || void 0 === t || t.abort() : e.prototype.abort.call(this)
            }
            ,
            t
        }(xr), Fr = function() {
            function e(e, t, r) {
                this.currentTask = null,
                this.updatePlayerInfo(e),
                Oe.getInstance(),
                this.logger = t,
                Ar.registerLogger(t),
                r && Ar.setUploadLog(r),
                le.initProxyTime = Tr.getTick()
            }
            return e.prototype.destroy = function() {
                this.currentTask = null,
                this.logger && (Ar.unregisterLogger(this.logger),
                this.logger = null)
            }
            ,
            e.prototype.updatePlayerInfo = function(e) {
                J.playerInfo = Object.assign(J.playerInfo, e),
                J.playerInfo.platform = +J.playerInfo.platform
            }
            ,
            e.prototype.createDownloadTask = function(e, t, r) {
                return this.currentTask = Oe.getInstance().createTask(e, t, r.fragments),
                null !== this.currentTask
            }
            ,
            e.prototype.stopDownloadTask = function(e, t) {
                void 0 === t && (t = !1),
                Oe.getInstance().stopTask(e, t)
            }
            ,
            e.prototype.updatePlaylist = function(e) {
                var t;
                (null == e ? void 0 : e.fragments[0]) && (null === (t = this.currentTask) || void 0 === t || t.updatePlaylist(e.fragments))
            }
            ,
            e.prototype.updateRemainTime = function(e, t) {
                var r;
                return null === (r = this.currentTask) || void 0 === r ? void 0 : r.setRemainTime(e, t)
            }
            ,
            e.prototype.updatePlayState = function(e) {
                var t;
                null === (t = this.currentTask) || void 0 === t || t.setPlayState(e)
            }
            ,
            e.prototype.updateDropFrameInfo = function(e) {
                var t;
                null === (t = this.currentTask) || void 0 === t || t.setDropFrameInfo(e)
            }
            ,
            e.prototype.updatePreloadRemainTime = function(e) {
                var t;
                (null === (t = this.currentTask) || void 0 === t ? void 0 : t.playState) === M.Preload && this.currentTask.setPreloadRemainTime(e)
            }
            ,
            e.prototype.notifyCanPlay = function() {
                var e;
                null === (e = this.currentTask) || void 0 === e || e.notifyCanPlay()
            }
            ,
            e.prototype.getVersion = function() {
                return Tr.getReportVersion()
            }
            ,
            e.prototype.getInfo = function() {
                var e;
                return null === (e = this.currentTask) || void 0 === e ? void 0 : e.getInfo()
            }
            ,
            e.prototype.getRecentHTTPHeaders = function() {
                var e;
                return null === (e = this.currentTask) || void 0 === e ? void 0 : e.getRecentHTTPHeaders()
            }
            ,
            e
        }(), Br = function() {
            return Br = Object.assign || function(e) {
                for (var t, r = 1, i = arguments.length; r < i; r++)
                    for (var n in t = arguments[r])
                        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e
            }
            ,
            Br.apply(this, arguments)
        }, Mr = function() {
            function t(r, i, n, a) {
                if (this.stateInternal = M.Stoped,
                this.mode = r,
                this.logger = a,
                this.hls = n,
                i && t.isSupported() && this.hls.config.progressive) {
                    var o = Br(Br({}, i.playerInfo), {
                        platform: +i.playerInfo.platform,
                        device: e.uaTool.mobile ? G.Phone : G.PC
                    });
                    this.proxy = new Fr(o,a,(function() {}
                    )),
                    this.setTaskInfo({
                        flowID: i.flowId || "",
                        keyID: i.keyId,
                        useP2P: !!i.useP2P,
                        downloadMode: i.downloadMode || 0,
                        encoding: i.encoding || 0,
                        vid: i.vid || "",
                        format: i.format || ""
                    }),
                    this.logger.log("Initialized new download kit controller, MultiNetProxy version: ".concat(this.proxy.getVersion())),
                    this.enable()
                } else
                    this.logger.log("Download kit controller is not initialized, because p2pConfig is null or environment is not supported")
            }
            return t.isSupported = function() {
                return !(e.uaTool.browser.ie || "0" === e.urlTool.getUrlParamByKey(location.href, o.enableP2P))
            }
            ,
            Object.defineProperty(t.prototype, "state", {
                get: function() {
                    return this.stateInternal
                },
                set: function(e) {
                    var t;
                    this.stateInternal = e,
                    null === (t = this.proxy) || void 0 === t || t.updatePlayState(e)
                },
                enumerable: !1,
                configurable: !0
            }),
            t.prototype.getHTTPHeaders = function() {
                var e;
                return null !== (e = this.proxy.getRecentHTTPHeaders()) && void 0 !== e ? e : {}
            }
            ,
            t.prototype.reportPerformance = function(e) {
                this.proxy && e === Ur.canplay && this.proxy.notifyCanPlay()
            }
            ,
            t.prototype.enable = function() {
                var e, t;
                this.hls.config.fLoader = Or,
                this.hls.config.fragLoadingMaxRetry = 0,
                this.hls.config.maxBufferLength = 5,
                this.hls.config.maxMaxBufferLength = 5,
                null !== (e = (t = this.hls.config).m3u8PostProcessor) && void 0 !== e || (t.m3u8PostProcessor = {}),
                this.hls.config.m3u8PostProcessor.fragUrlProcessor = this.injectKeyIDToFragment.bind(this),
                this.addEventListeners()
            }
            ,
            t.prototype.changeKeyID = function(e) {
                this.nextKeyId = e
            }
            ,
            t.prototype.getVersion = function() {
                var e;
                return null === (e = this.proxy) || void 0 === e ? void 0 : e.getVersion()
            }
            ,
            t.prototype.stop = function(e) {
                void 0 === e && (e = !1),
                this.isRunning() && (this.logger.log("stop task for keyID: ".concat(this.lastLoadedKeyId)),
                this.stateInternal = M.Stoped,
                this.removeEventListeners(),
                this.proxy.stopDownloadTask(this.lastLoadedKeyId, e),
                this.proxy.destroy(),
                this.proxy = null,
                this.nextKeyId = null,
                this.lastLoadedKeyId = null)
            }
            ,
            t.prototype.setPlaying = function() {
                this.state = M.Playing
            }
            ,
            t.prototype.setPaused = function() {
                this.state = M.Paused
            }
            ,
            t.prototype.setPreload = function() {
                this.state = M.Preload
            }
            ,
            t.prototype.isRunning = function() {
                return this.state !== M.Stoped && !!this.proxy
            }
            ,
            t.prototype.detach = function() {
                this.removeEventListeners(),
                this.hls = null
            }
            ,
            t.prototype.setTaskInfo = function(e) {
                this.logger.log("setting download task info: ", e),
                this.nextKeyId = e.keyID,
                this.taskInfo = Br(Br({}, e), {
                    taskType: Nr[this.mode]
                })
            }
            ,
            t.prototype.updateBuffer = function(e, t) {
                if (this.isRunning())
                    return this.proxy.updateRemainTime(e, t)
            }
            ,
            t.prototype.updateFrameDropped = function(e, t) {
                this.isRunning() && this.proxy.updateDropFrameInfo({
                    totalFrames: e,
                    droppedFrames: t
                })
            }
            ,
            t.prototype.updatePreloadCounter = function(e) {
                this.isRunning() && this.proxy.updatePreloadRemainTime(e)
            }
            ,
            t.prototype.getPerformanceInfo = function() {
                return this.isRunning() ? this.proxy.getInfo() : null
            }
            ,
            t.prototype.addEventListeners = function() {
                this.hls.on(l().Events.FRAG_LOADING, this.onHlsFragLoading, this),
                this.hls.on(l().Events.LEVEL_SWITCHED, this.onHlsLevelSwitched, this),
                this.hls.on(l().Events.LEVEL_UPDATED, this.onHlsLevelUpdated, this),
                this.hls.on(l().Events.LEVEL_SWITCHING, this.onHlsLevelSwitching, this)
            }
            ,
            t.prototype.removeEventListeners = function() {
                this.hls.off(l().Events.FRAG_LOADING, this.onHlsFragLoading, this),
                this.hls.off(l().Events.LEVEL_SWITCHED, this.onHlsLevelSwitched, this),
                this.hls.off(l().Events.LEVEL_UPDATED, this.onHlsLevelUpdated, this),
                this.hls.off(l().Events.LEVEL_SWITCHING, this.onHlsLevelSwitching, this)
            }
            ,
            t.prototype.onHlsFragLoading = function(e, t) {
                if (this.isRunning()) {
                    var r = t.frag
                      , i = r.ext
                      , n = r.sn
                      , a = i.keyID;
                    if ("main" === r.type && this.lastLoadedKeyId !== a) {
                        this.lastLoadedKeyId && (this.logger.log("keyID changed from ".concat(this.lastLoadedKeyId, " to ").concat(a, ", recreate task")),
                        this.proxy.stopDownloadTask(this.lastLoadedKeyId));
                        var o = this.hls.levels[r.level].details;
                        this.logger.log("creating task for keyID ".concat(a, " in state ").concat(this.state)),
                        this.lastLoadedKeyId = a,
                        this.proxy.createDownloadTask(Br(Br({}, this.taskInfo), {
                            keyID: a,
                            startSn: n,
                            taskType: Nr[this.mode]
                        }), this.state, o),
                        this.stateInternal = M.Playing
                    }
                }
            }
            ,
            t.prototype.onHlsLevelSwitching = function() {
                this.isRunning() && this.proxy.updateRemainTime(0)
            }
            ,
            t.prototype.onHlsLevelSwitched = function(e, t) {
                this.isRunning() && (this.currentLevel = t.level)
            }
            ,
            t.prototype.onHlsLevelUpdated = function(e, t) {
                var r;
                this.isRunning() && (null !== (r = this.currentLevel) && void 0 !== r || (this.currentLevel = t.level),
                t.level === this.currentLevel ? this.lastLoadedKeyId && (this.logger.log("updating playlist for keyID ".concat(this.lastLoadedKeyId)),
                this.proxy.updatePlaylist(t.details)) : this.logger.log("level updated but not current level, handled by new frag loading logic. new=".concat(t.level, ", cur=").concat(this.currentLevel, "}")))
            }
            ,
            t.prototype.injectKeyIDToFragment = function(t) {
                var r = "".concat(this.nextKeyId);
                if (this.mode === e.PLAY_MODE.LIVE) {
                    var i = (t.tagList.find((function(e) {
                        return "EXT-QQHLS-MACHINEID" === e[0]
                    }
                    )) || [])[1]
                      , n = void 0 === i ? "0000" : i;
                    r = "".concat(r, ".").concat(n)
                }
                return {
                    relurl: null == t ? void 0 : t.relurl,
                    ext: {
                        keyID: r
                    }
                }
            }
            ,
            t
        }(), Ur = {
            canplay: "canplay"
        }, Nr = ((Dr = {})[e.PLAY_MODE.LIVE] = B.Live,
        Dr[e.PLAY_MODE.VOD] = B.Vod,
        Dr);
        !function(e) {
            e.Loading = "LOADING",
            e.Loaded = "LOADED",
            e.Played = "PLAYED",
            e.Error = "ERROR"
        }(kr || (kr = {})),
        function(e) {
            e.Main = "main",
            e.Insert = "insert"
        }(Cr || (Cr = {}));
        var Gr = function() {
            return Gr = Object.assign || function(e) {
                for (var t, r = 1, i = arguments.length; r < i; r++)
                    for (var n in t = arguments[r])
                        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e
            }
            ,
            Gr.apply(this, arguments)
        }
          , Hr = function() {
            function e(e, t) {
                this.currentTime = 0,
                this.state = kr.Loading,
                this.config = Gr(Gr({}, qr), t),
                this.type = e.type,
                this.type === Cr.Insert && (this.config.startPosition = 0),
                this.hls = new (l())(this.config),
                this.addEventListeners(),
                this.url = e.url
            }
            return e.prototype.getHlsInstance = function() {
                return this.hls
            }
            ,
            e.prototype.load = function() {
                this.hls.loadSource(this.url)
            }
            ,
            e.prototype.destroy = function() {
                this.removeEventListeners(),
                this.hls.destroy(),
                this.hls = null
            }
            ,
            e.prototype.attachMedia = function(e) {
                this.hls.attachMedia(e),
                this.state = kr.Played
            }
            ,
            e.prototype.detachMedia = function() {
                this.hls.detachMedia(),
                this.type === Cr.Insert && (this.currentTime = 0,
                this.hls.loadSource(this.url))
            }
            ,
            e.prototype.reset = function() {
                this.state !== kr.Played || (this.state = kr.Loaded)
            }
            ,
            e.prototype.addEventListeners = function() {
                this.hls.once(l().Events.FRAG_LOADED, this.onFragLoaded, this),
                this.hls.on(l().Events.ERROR, this.onError, this)
            }
            ,
            e.prototype.removeEventListeners = function() {
                this.hls.off(l().Events.FRAG_LOADED, this.onFragLoaded, this),
                this.hls.off(l().Events.ERROR, this.onError, this)
            }
            ,
            e.prototype.onFragLoaded = function() {
                this.state = kr.Loaded
            }
            ,
            e.prototype.onError = function(e, t) {
                t.fatal && (this.state = kr.Error)
            }
            ,
            e
        }()
          , qr = {
            startFragPrefetch: !0
        }
          , zr = function() {
            function t(t) {
                var r = this;
                this.sources = {},
                this.schedule = [],
                this.currentIndex = 0,
                this.requestAnimationCallback = function() {
                    var e = r.media.currentTime;
                    if (r.getCurrentSource().currentTime = e,
                    r.media.ended && r.getCurrentSourceType() !== Cr.Main)
                        r.onVideoEnded();
                    else if (!(r.getCurrentSourceType() !== Cr.Main || r.currentIndex >= r.schedule.length)) {
                        var t = r.schedule[r.currentIndex]
                          , i = t.url
                          , n = t.start
                          , a = r.sources[i];
                        e >= n && e <= n + .05 && (a.state === kr.Loaded && (r.swapSource(a),
                        r.onSourceChange && r.onSourceChange(a, r.currentIndex)),
                        r.currentIndex += 1)
                    }
                }
                ,
                this.onVideoSeeking = function() {
                    if (r.getCurrentSourceType() === Cr.Main) {
                        var e = r.media.currentTime
                          , t = r.schedule.findIndex((function(t) {
                            return t.start >= e + 2
                        }
                        ));
                        t > -1 && (r.currentIndex = t);
                        for (var i = r.currentIndex; i < r.schedule.length; i += 1) {
                            var n = r.schedule[i].url;
                            r.sources[n].reset()
                        }
                    }
                }
                ,
                this.onVideoEnded = function() {
                    r.getCurrentSourceType() !== Cr.Main && (r.swapSource(r.mainSource),
                    r.onSourceChange && r.onSourceChange(r.mainSource, -1))
                }
                ,
                this.onVideoError = function() {
                    r.getCurrentSourceType() !== Cr.Main && (r.getCurrentSource().state = kr.Error,
                    r.swapSource(r.mainSource))
                }
                ,
                this.media = t,
                this.taskLoop = new e.TaskLoop(this.requestAnimationCallback,e.LoopMode.RAF)
            }
            return t.prototype.getCurrentSource = function() {
                return this.sources[this.currentSrc]
            }
            ,
            t.prototype.getCurrentSourceType = function() {
                return this.sources[this.currentSrc].type
            }
            ,
            t.prototype.getMainSource = function() {
                return this.mainSource
            }
            ,
            t.prototype.initSources = function(e, t) {
                var r = this
                  , i = e.loadingUrl
                  , n = e.config.insertableStreams;
                this.schedule = [],
                this.currentIndex = 0;
                var a = new Hr({
                    url: i,
                    type: Cr.Main
                },t);
                this.sources[i] = a,
                this.mainSource = a,
                this.currentSrc = i,
                a.attachMedia(this.media),
                (null == n ? void 0 : n.length) > 0 && (n.forEach((function(e) {
                    var i = e.startTime
                      , n = e.url;
                    r.sources[e.url] = new Hr({
                        url: n,
                        type: Cr.Insert
                    },t),
                    r.schedule.push({
                        start: i,
                        url: n
                    })
                }
                )),
                this.schedule.sort((function(e, t) {
                    return e.start - t.start
                }
                )),
                this.addVideoEventListeners(),
                this.taskLoop.start())
            }
            ,
            t.prototype.start = function() {
                var e = this;
                Object.keys(this.sources).forEach((function(t) {
                    e.sources[t].load()
                }
                ))
            }
            ,
            t.prototype.clear = function() {
                var e, t = this;
                this.removeVideoEventListeners(),
                this.taskLoop.stop(),
                null === (e = this.getCurrentSource()) || void 0 === e || e.detachMedia(),
                this.currentSrc = null,
                Object.keys(this.sources).forEach((function(e) {
                    t.sources[e].destroy()
                }
                )),
                this.sources = {}
            }
            ,
            t.prototype.addVideoEventListeners = function() {
                this.media.addEventListener("ended", this.onVideoEnded),
                this.media.addEventListener("seeking", this.onVideoSeeking),
                this.media.addEventListener("error", this.onVideoError)
            }
            ,
            t.prototype.removeVideoEventListeners = function() {
                this.media.removeEventListener("ended", this.onVideoEnded),
                this.media.removeEventListener("seeking", this.onVideoSeeking),
                this.media.removeEventListener("error", this.onVideoError)
            }
            ,
            t.prototype.swapSource = function(t) {
                e.uaTool.browser.safari && this.media.seeking && this.media.dispatchEvent(new Event("seeked"));
                var r = t.currentTime
                  , i = t.url;
                this.media.pause(),
                this.getCurrentSource().detachMedia(),
                this.currentSrc = i,
                t.attachMedia(this.media),
                t.type === Cr.Main && (this.media.currentTime = r),
                this.media.play()
            }
            ,
            t
        }()
          , Kr = function() {
            var e = function(t, r) {
                return e = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(e, t) {
                    e.__proto__ = t
                }
                || function(e, t) {
                    for (var r in t)
                        Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
                }
                ,
                e(t, r)
            };
            return function(t, r) {
                if ("function" != typeof r && null !== r)
                    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
                function i() {
                    this.constructor = t
                }
                e(t, r),
                t.prototype = null === r ? Object.create(r) : (i.prototype = r.prototype,
                new i)
            }
        }()
          , Vr = function() {
            return Vr = Object.assign || function(e) {
                for (var t, r = 1, i = arguments.length; r < i; r++)
                    for (var n in t = arguments[r])
                        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e
            }
            ,
            Vr.apply(this, arguments)
        }
          , jr = function(e, t, r) {
            if (r || 2 === arguments.length)
                for (var i, n = 0, a = t.length; n < a; n++)
                    !i && n in t || (i || (i = Array.prototype.slice.call(t, 0, n)),
                    i[n] = t[n]);
            return e.concat(i || Array.prototype.slice.call(t))
        }
          , Wr = function(t) {
            function r(e) {
                var r = t.call(this, e) || this;
                return r.handleDownloadKitRequestLog = function() {}
                ,
                r._eventMap.hlsjsEvtHandler = r.hlsjsEvtHandler.bind(r),
                v.enableDumpFmp4Data && (r.dumpFmp4 = new v),
                r.collectStepTiming = new u(r.config.instanceId),
                r.sourceController = new zr(r._video),
                r
            }
            return Kr(r, t),
            Object.defineProperty(r.prototype, "_hls", {
                get: function() {
                    var e;
                    return null === (e = this.sourceController.getMainSource()) || void 0 === e ? void 0 : e.getHlsInstance()
                },
                enumerable: !1,
                configurable: !0
            }),
            r.prototype.destroy = function() {
                var e, r;
                null === (e = this.dumpFmp4) || void 0 === e || e.destroy(),
                null === (r = this.collectStepTiming) || void 0 === r || r.destroy(),
                this.collectStepTiming = null,
                this.resetSourceController(),
                this.stopDownloadKit(),
                t.prototype.destroy.call(this)
            }
            ,
            r.prototype.getDynamicHlsConfig = function(t) {
                var r = t.startPosition
                  , i = void 0 === r ? -1 : r
                  , n = t.licenseUrl
                  , a = void 0 === n ? "" : n
                  , o = i > 0 ? i : -1;
                return {
                    startFragPrefetch: !0,
                    startPosition: this.config.type === e.PLAY_MODE.LIVE ? -1 : o,
                    licenseUrl: a,
                    emeEnabled: !1,
                    fragLoadingMaxRetryTimeout: 1e4,
                    fragLoadingRetryDelay: 10,
                    fragLoadingMaxRetry: 3,
                    fragLoadingTimeOut: 1e4,
                    maxBufferLength: 180,
                    maxMaxBufferLength: 180,
                    progressive: !0,
                    testBandwidth: !1,
                    maxBufferHole: .5,
                    manifestLoadingMaxRetry: 2,
                    manifestLoadingRetryDelay: 100,
                    manifestLoadingTimeOut: 1e4,
                    levelLoadingMaxRetry: 2,
                    levelLoadingRetryDelay: 100,
                    levelLoadingTimeOut: 1e4,
                    liveSyncDuration: 15,
                    liveMaxLatencyDuration: 25,
                    useSBRWorkaround: e.uaTool.browser.chrome && e.commonTool.compareVersion(e.uaTool.browser.chrome.version, "130.0.0") < 0,
                    m3u8PostProcessor: {
                        mediaReplace: this.updateHlsMedia.bind(this)
                    }
                }
            }
            ,
            r.prototype.load = function(t, r) {
                var i, n;
                void 0 === r && (r = {}),
                this._logger.log("load()");
                var a = t.loadingUrl
                  , s = t.config
                  , l = s.chachaParam
                  , c = s.drmConfig
                  , h = s.p2pConfig
                  , u = this.config.tempOffsetStartPosition;
                if (a) {
                    var d = r.startTime;
                    Number.isNaN(d) && (this._logger.warn("load(), startTime can not be NaN!"),
                    d = 0),
                    u && (d = u(d)),
                    this._userStartTime = d,
                    this.stopInner(!0),
                    this._drm.init(c),
                    this.callplayAfterLoadDefer = new e.SimpleDefer,
                    this._videoInfo = t,
                    this._videoInfo.extraVars.isLoadstarted = !0,
                    this.setVideoEvents(!0);
                    var f = this._config.hlsjsKernelConfig || {}
                      , p = Object.assign({
                        chachaParam: l,
                        externalRedundantUrls: t.config.backupUrls || [],
                        externalAudioRedundantUrls: (null === (i = t.config.audioTrack) || void 0 === i ? void 0 : i.backupUrls) || []
                    }, this.getDynamicHlsConfig({
                        startPosition: d
                    }), f);
                    this._logger.log("hls using config: ", p),
                    ("0" === e.urlTool.getUrlParamByKey(location.href, o.enableHlsProgressive) || this.config.type === e.PLAY_MODE.VOD && (l || e.uaTool.browser.safari)) && (p.progressive = !1),
                    this.initSourceController(p),
                    this.config.enableP2P && this.initDownloadKitController(h);
                    var g = this._playbackRate;
                    this.sourceController.start(),
                    this.playbackRate = g,
                    this.stateMgr.setLoadStart(),
                    null === (n = this.dumpFmp4) || void 0 === n || n.reset(),
                    this.setCheckLoadTimeoutEnable(!0)
                }
            }
            ,
            r.prototype.onVideoEventLoadedmetadata = function() {
                this._videoInfo.discontinuityTimeRanges = this.hlsDiscontinuityRanges,
                t.prototype.onVideoEventLoadedmetadata.call(this)
            }
            ,
            r.prototype.onVideoEventEnded = function() {
                this.sourceController.getCurrentSourceType() === Cr.Main && t.prototype.onVideoEventEnded.call(this)
            }
            ,
            r.prototype.onVideoEventSeeking = function() {
                this.updateBufferRemain(),
                t.prototype.onVideoEventSeeking.call(this)
            }
            ,
            r.prototype.onVideoEventPlaying = function() {
                var e;
                return this.collectStepTiming.over(),
                null === (e = this.downloadKitController) || void 0 === e || e.setPlaying(),
                t.prototype.onVideoEventPlaying.call(this)
            }
            ,
            r.prototype.onVideoEventCanplay = function() {
                var r;
                t.prototype.onVideoEventCanplay.call(this),
                this.state === e.VIDEO_STATE.CANPLAY && (null === (r = this.downloadKitController) || void 0 === r || r.reportPerformance(Ur.canplay))
            }
            ,
            r.prototype.onVideoEventTimeUpdate = function() {
                var e, r = null === (e = this.downloadKitController) || void 0 === e ? void 0 : e.getPerformanceInfo();
                if (r) {
                    var i = r.httpSpeed
                      , n = r.p2pDownloadSpeed
                      , a = r.p2pScore
                      , o = r.p2pUpload
                      , s = r.downIdle
                      , l = r.downConnected
                      , c = r.downConnecting
                      , h = r.up
                      , u = r.upAndDown;
                    this._videoInfo.performance.speed = +i + +n,
                    this._videoInfo.performance.p2pStats = "".concat(a, "/").concat(n, "/").concat(o, "/").concat(s, "/").concat(c, "/").concat(l, "/").concat(h, "/").concat(u)
                }
                t.prototype.onVideoEventTimeUpdate.call(this)
            }
            ,
            r.prototype.onVideoEventPause = function() {
                var e;
                null === (e = this.downloadKitController) || void 0 === e || e.setPaused(),
                t.prototype.onVideoEventPause.call(this)
            }
            ,
            r.prototype.setLevelOver = function() {
                return isNaN(this.currentVideoInfo.currentAudioTrack) || (this.hls.audioTrack = this.currentVideoInfo.currentAudioTrack),
                t.prototype.setLevelOver.call(this)
            }
            ,
            r.prototype.onVideoEventResize = function() {
                t.prototype.onVideoEventResize.call(this),
                this.setLevelMode === e.SET_LEVEL_MODE.SMOOTH && this.setLevelOver()
            }
            ,
            Object.defineProperty(r.prototype, "hls", {
                get: function() {
                    return this._hls
                },
                enumerable: !1,
                configurable: !0
            }),
            r.prototype.resetSourceController = function() {
                this.setHlsJsEvents(!1),
                this.sourceController.clear()
            }
            ,
            r.prototype.initSourceController = function(t) {
                var r, i, n = null !== (r = null === e.LogMode || void 0 === e.LogMode ? void 0 : e.LogMode.cache) && void 0 !== r ? r : 2, a = this.config.logLevel >= e.PLAYER_LOG_LEVEL.KERNEL ? null !== (i = null === e.LogMode || void 0 === e.LogMode ? void 0 : e.LogMode.console) && void 0 !== i ? i : 1 : 0;
                this.resetSourceController(),
                this.collectStepTiming.start(),
                this.sourceController.initSources(this._videoInfo, Vr(Vr({}, t), {
                    debug: new e.Logger(this._config.instanceId,"HlsJs",{
                        log: n | a,
                        warn: n | a,
                        error: n | a
                    })
                })),
                this.sourceController.onSourceChange = this.onSourceChange.bind(this),
                this.setHlsJsEvents(!0),
                this.emitKernelEvt("hlsInstanceChange", {
                    videoInfo: this._videoInfo
                })
            }
            ,
            r.prototype.initDownloadKitController = function(t) {
                var r;
                this.downloadKitController = new Mr(this.config.type,t,this._hls,new e.Logger(this._config.instanceId,"DownloadKit",{
                    info: (null === e.LogMode || void 0 === e.LogMode ? void 0 : e.LogMode.cache) | (null === e.LogMode || void 0 === e.LogMode ? void 0 : e.LogMode.console),
                    log: null === e.LogMode || void 0 === e.LogMode ? void 0 : e.LogMode.console
                })),
                this.downloadKitController.setPlaying(),
                null !== (r = this.downloadKitTaskLoop) && void 0 !== r || (this.downloadKitTaskLoop = new e.TaskLoop(this.updateP2PInfo.bind(this),e.LoopMode.Timer)),
                this.downloadKitTaskLoop.start(1e3)
            }
            ,
            r.prototype.updateHlsMedia = function(e) {
                return "AUDIO" === e.type ? this.selectDefaultAudioTrack(e) : e
            }
            ,
            r.prototype.selectDefaultAudioTrack = function(e) {
                this._logger.log("modify audio track", e);
                var t = this.currentVideoInfo.config;
                return !t.defaultAudioTrack || e.lang !== t.defaultAudioTrack && e.name !== t.defaultAudioTrack || (e.default = !0),
                e
            }
            ,
            r.prototype.onSourceChange = function(t, r) {
                var i = t.type === Cr.Main ? e.VIDEO_NODE_EVENT.EXIT_INSERT_STREAM : e.VIDEO_NODE_EVENT.ENTER_INSERT_STREAM;
                this.emit(i, {
                    videoInfo: this._videoInfo,
                    index: r
                })
            }
            ,
            r.prototype.updateP2PInfo = function() {
                var e, t, r, i, n, a, o, s = this.updateBufferRemain();
                s && (this._videoInfo.buffered = s),
                "visible" === document.visibilityState && (null === (e = this.downloadKitController) || void 0 === e || e.updateFrameDropped(null !== (i = null === (r = null === (t = this._videoInfo) || void 0 === t ? void 0 : t.qualityInfo) || void 0 === r ? void 0 : r.totalVideoFrames) && void 0 !== i ? i : 0, null !== (o = null === (a = null === (n = this._videoInfo) || void 0 === n ? void 0 : n.qualityInfo) || void 0 === a ? void 0 : a.droppedVideoFrames) && void 0 !== o ? o : 0))
            }
            ,
            r.prototype.updateLevelInfo = function(e) {
                var t = e.levels
                  , r = void 0 === t ? this._hls.levels : t
                  , i = e.currentLevel
                  , n = void 0 === i ? this._hls.currentLevel : i
                  , a = this.currentVideoInfo
                  , o = a.config.url;
                a.levels = r.map((function(e) {
                    return p(e, o)
                }
                )),
                a.currentLevelIndex = n,
                a.currentLevel = n >= 0 ? p(r[n], o) : null,
                a.isAutoLevel = this.isEnableABR() && -1 === this._hls.manualLevel
            }
            ,
            r.prototype.setHlsJsEvents = function(e) {
                var t = this;
                this._videoInfo && this._hls && (this._eventAddedMap.hlsjsEventAdded !== e && (this._logger.log("setHlsJsEvents(), uid/value: ".concat(this._videoInfo.uid, "/").concat(e)),
                this._eventAddedMap.hlsjsEventAdded = e,
                Object.values(l().Events).forEach((function(r) {
                    e ? t._hls.on(r, t._eventMap.hlsjsEvtHandler) : t._hls.off(r, t._eventMap.hlsjsEvtHandler)
                }
                ))))
            }
            ,
            r.prototype.hlsjsEvtHandler = function(e, t) {
                var r, i = this, n = ((r = {})[l().Events.MANIFEST_PARSED] = this.onHlsManifestParsed,
                r[l().Events.FRAG_CHANGED] = this.onHlsFragChanged,
                r[l().Events.ERROR] = this.handlerHlsErr,
                r[l().Events.BUFFER_CODECS] = this.onHlsBufferCodec,
                r[l().Events.LEVELS_UPDATED] = function() {
                    return i.onHlsLevelsUpdated(t)
                }
                ,
                r[l().Events.LEVEL_SWITCHED] = function() {
                    return i.onHlsLevelSwitched(t)
                }
                ,
                r[l().Events.INIT_PTS_FOUND] = this.onHlsInitPtsFound,
                r[l().Events.BUFFER_APPENDING] = this.onHlsBufferAppending,
                r[l().Events.AUDIO_TRACK_SWITCHED] = this.onHlsAudioTrackSwitched,
                r[l().Events.AUDIO_TRACK_SWITCHING] = this.onHlsAudioTrackSwitching,
                r[l().Events.FRAG_LOADING] = this.onHlsFragLoading,
                r[l().Events.FRAG_PARSING_INIT_SEGMENT] = this.onHlsFragParsingInitSegment,
                r[l().Events.FRAG_PARSING_USERDATA] = this.onHlsFragParsingUserdata,
                r);
                n[e] && n[e].call(this, t),
                this.isDestroyed || (this.collectStepTiming.pushEvts(e, t),
                this.emitKernelEvt(e, t))
            }
            ,
            r.prototype.handlerHlsErr = function(t) {
                var r, i = t.fatal, n = t.type, a = t.details;
                this._logger.warn("hlsjs encounters error", {
                    fatal: i,
                    type: n,
                    details: a,
                    data: t,
                    currentFragSn: this._videoInfo.currentFragSn,
                    currentFragUrl: this._videoInfo.currentFragUrl
                }),
                null === (r = this.downloadKitController) || void 0 === r || r.setPlaying(),
                i ? this.errorHandler(function(t) {
                    var r, i, n, a = t.details, o = t.type, l = t.response;
                    if (o === s.ErrorTypes.NETWORK_ERROR) {
                        var c = null !== (r = null == l ? void 0 : l.code) && void 0 !== r ? r : -1
                          , h = null !== (i = f.network[a]) && void 0 !== i ? i : f.network.uncategorized;
                        return e.PlayerError.NetworkError({
                            code: h,
                            detail: c,
                            fatal: !0,
                            message: (0,
                            e.t)(e.i18nConfig.txhlsjsKernel.ERR_NET),
                            debugMessage: "".concat(a, ".").concat(e.jsonTool.safelyStringify(l))
                        })
                    }
                    return S({
                        code: null !== (n = f.general[a]) && void 0 !== n ? n : f.general.uncategorized,
                        fatal: !0,
                        message: (0,
                        e.t)(e.i18nConfig.txhlsjsKernel.ERR_INNER_EXCEPTION),
                        debugMessage: "".concat(a, ".").concat(e.jsonTool.safelyStringify(t))
                    })
                }(t)) : t.details === l().ErrorDetails.AUDIO_TRACK_LOAD_ERROR && this.onHlsAudioTrackSwitchFailed()
            }
            ,
            r.prototype.onHlsLevelsUpdated = function(e) {
                this.updateLevelInfo({
                    levels: e.levels
                })
            }
            ,
            r.prototype.onHlsLevelSwitched = function(e) {
                this.updateLevelInfo({
                    currentLevel: e.level
                })
            }
            ,
            r.prototype.onHlsFragParsingUserdata = function(t) {
                var r = t.samples
                  , i = [];
                r.forEach((function(e) {
                    var t = e.pts
                      , r = e.payloadType
                      , n = e.uuid
                      , a = e.bytes;
                    i.push({
                        payloadType: r,
                        payload: {
                            uuid: n,
                            ptsMs: 1e3 * t,
                            data: a
                        }
                    })
                }
                )),
                this.emit(e.VIDEO_NODE_EVENT.RECEIVE_SEI_DATA, {
                    videoInfo: this._videoInfo,
                    sei: i
                })
            }
            ,
            r.prototype.onHlsFragParsingInitSegment = function(e) {
                var t, r, i = e.tracks.video;
                if (null == i ? void 0 : i.metadata) {
                    var n = i.metadata
                      , a = n.bitDepth
                      , o = n.colorPrimaries
                      , s = n.transferCharacteristics
                      , l = n.pixelFormat;
                    this.currentVideoInfo.bitDepth = a,
                    this.currentVideoInfo.colorSpace = {
                        primaries: null !== (t = I[o]) && void 0 !== t ? t : null,
                        transfer: null !== (r = P[s]) && void 0 !== r ? r : null
                    },
                    this.currentVideoInfo.pixelFormat = l
                }
            }
            ,
            r.prototype.onHlsAudioTrackSwitchFailed = function() {
                var e;
                this._logger.warn("audio track switching failed from hls.js", {
                    currentAudioTrack: this.currentVideoInfo.currentAudioTrack
                }),
                this.onAudioTrackSwitched(this.currentVideoInfo.currentAudioTrack, !0),
                isNaN(this.currentVideoInfo.currentAudioTrack) ? (null === (e = this.currentVideoInfo.config.drmConfig) || void 0 === e ? void 0 : e.keySystem) || (this._hls.audioTrack = -1) : this._hls.audioTrack = this.currentVideoInfo.currentAudioTrack
            }
            ,
            r.prototype.onHlsAudioTrackSwitching = function(t) {
                this.audioTrackSwitchingDefer || (this.audioTrackSwitchingDefer = new e.SimpleDefer,
                this.emit(e.VIDEO_NODE_EVENT.SET_AUDIO_TRACK_START, {
                    userTrigger: this.isUserSwitchAudioTrack,
                    videoInfo: this.currentVideoInfo,
                    id: t.id
                }))
            }
            ,
            r.prototype.onHlsFragLoading = function(t) {
                var r, i = this;
                (null === (r = t.frag) || void 0 === r ? void 0 : r.url) && e.NetTiming.observer(this._config.instanceId, {
                    url: t.frag.url,
                    tag: "".concat(this._videoInfo.uid, "_hls_clip"),
                    callback: function(e) {
                        i._logger.log("frag perf entry, ", e)
                    }
                })
            }
            ,
            r.prototype.onHlsBufferCodec = function(e) {
                var t, r, i, n, a = null !== (r = null === (t = e.video) || void 0 === t ? void 0 : t.codec) && void 0 !== r ? r : "", o = null !== (n = null === (i = e.audio) || void 0 === i ? void 0 : i.codec) && void 0 !== n ? n : "";
                this._logger.log("Hls Codecs: ".concat(a, ",").concat(o)),
                this._videoInfo && (this._videoInfo.codecs = {
                    video: a,
                    audio: o
                })
            }
            ,
            r.prototype.onHlsAudioTrackSwitched = function(e) {
                this.currentVideoInfo.currentAudioTrack = e.id,
                t.prototype.onAudioTrackSwitched.call(this, e.id)
            }
            ,
            r.prototype.onHlsManifestParsed = function(e) {
                var t, r, i, n = e.levels, a = e.altAudio, o = this.determineLevelLock(e);
                (null === (t = e.audioTracks) || void 0 === t ? void 0 : t.length) > 0 && !(null === (r = e.audioTracks) || void 0 === r ? void 0 : r.find((function(e) {
                    return e.default
                }
                ))) && (this._logger.warn("audio track default not found, fallback to first audio track"),
                e.audioTracks[0].default = !0),
                this.altAudio = a,
                this.updateLevelInfo({
                    levels: n,
                    currentLevel: o
                }),
                this.currentVideoInfo.audioTracks = jr([], e.audioTracks.map((function(e) {
                    return {
                        name: e.name,
                        id: e.id
                    }
                }
                )), !0),
                this.hlsDiscontinuityRanges = null === (i = n[o].details) || void 0 === i ? void 0 : i.discontinuityTimeRanges,
                this.callplayAfterLoadDefer.resolve()
            }
            ,
            r.prototype.determineLevelLock = function(e) {
                return e.firstLevel
            }
            ,
            r.prototype.onHlsInitPtsFound = function(e) {
                var t = e.frag
                  , r = e.initPTS
                  , i = void 0 === r ? 0 : r
                  , n = e.timescale
                  , a = e.videoStartPts
                  , o = void 0 === a ? 0 : a
                  , s = e.audioStartPts
                  , l = void 0 === s ? 0 : s;
                !isNaN(+n) && n > 0 && 0 === t.sn && (this._videoInfo.startPts = i / n,
                this._videoInfo.videoStartPts = o / n,
                this._videoInfo.audioStartPts = l / n)
            }
            ,
            r.prototype.onHlsBufferAppending = function(e) {
                var t, r;
                if (null === (t = this.dumpFmp4) || void 0 === t || t.append(e.type, e.data),
                null === (r = this.downloadKitController) || void 0 === r ? void 0 : r.isRunning()) {
                    var i = this.downloadKitController.getHTTPHeaders();
                    this._videoInfo.performance.protocol = i["x-protocol-used"] || i["X-Protocol-Used"] || ""
                }
            }
            ,
            r.prototype.onHlsFragChanged = function(t) {
                var r = t.frag
                  , i = r.sn
                  , n = r.url;
                this._videoInfo.currentFragSn = i,
                this._videoInfo.currentFragUrl = n,
                this.config.type === e.PLAY_MODE.LIVE && (this._videoInfo.performance.latency = Date.now() - r.programDateTime),
                this._logger.log("fragment changed to: ".concat(i), n)
            }
            ,
            r.prototype.parseErrorData = function(r) {
                var i, n, a = t.prototype.parseErrorData.call(this, r);
                return n = a,
                T.some((function(e) {
                    return e.equals(n)
                }
                )) && (a = null !== (i = function(t) {
                    if (!t)
                        return null;
                    var r = t.stats
                      , i = r.loaded
                      , n = r.loading
                      , a = r.parsing
                      , o = r.buffering;
                    if (0 === i || 0 === n.start || 0 === n.first)
                        return e.PlayerError.NetworkError({
                            code: f.network.unexpectedLoadingError,
                            fatal: !0,
                            message: (0,
                            e.t)(e.i18nConfig.txhlsjsKernel.ERR_NET),
                            debugMessage: "fragment not loaded. ".concat(i, "/").concat(n.start, "/").concat(n.first, "}")
                        });
                    var s = +("visible" === document.visibilityState);
                    return a.start > 0 && 0 === a.end ? S({
                        code: f.custom.currentFragmentNotParsed,
                        detail: s,
                        fatal: !0,
                        message: (0,
                        e.t)(e.i18nConfig.txhlsjsKernel.ERR_INNER_EXCEPTION),
                        debugMessage: "fragment not parsed. ".concat(a.start, "/").concat(a.end)
                    }) : o.start > 0 && 0 === o.end ? S({
                        code: f.custom.currentFragmentNotBuffered,
                        detail: s,
                        fatal: !0,
                        message: (0,
                        e.t)(e.i18nConfig.txhlsjsKernel.ERR_INNER_EXCEPTION),
                        debugMessage: "fragment not buffered. ".concat(o.start, "/").concat(o.end)
                    }) : void 0
                }(this.hls.currentFragment)) && void 0 !== i ? i : a),
                this.currentVideoInfo.config.preferKernelRetry && (a.fatal = !0),
                "network" !== a.type || a.errorCode !== f.network[l().ErrorDetails.MANIFEST_LOAD_ERROR] && a.errorCode !== f.network[l().ErrorDetails.MANIFEST_LOAD_TIMEOUT] || (a.fatal = !1),
                a
            }
            ,
            r.prototype.play = function(e, t) {
                var r = this;
                void 0 === t && (t = {}),
                this._logger.log("play(), uid/idx/state: ".concat(e ? e.uid : "", "/").concat(this.idx, "/").concat(this.state)),
                this._played = !0,
                e && !e.extraVars.isLoadstarted && this.load(e, t),
                this.callplayAfterLoadDefer.promise.then((function() {
                    r.videoplay()
                }
                )),
                this.setMainLoopEnable(!0)
            }
            ,
            r.prototype.seek = function(e, t) {
                void 0 === t && (t = !1);
                var r = Math.abs(this._videoInfo.duration - e) <= 1 ? e - 1 : e;
                return !!this.checkCanSeek(r, t) && (!!this._video && (this._isUserSeek = t,
                this._targetSeekTime = r,
                this._video.currentTime = r,
                !0))
            }
            ,
            r.prototype.setAudioTrack = function(t) {
                if (!this.checkCanSetAudioTrack())
                    return Promise.reject(e.AUDIO_TRACK_ERROR_MSG.STATE_INVALID);
                if (+t === this.hls.audioTrack)
                    return Promise.resolve({
                        fail: !0,
                        userTrigger: !0,
                        id: t
                    });
                var r = new e.SimpleDefer;
                return this.isUserSwitchAudioTrack = !0,
                this.audioTrackSwitchingDefer = r,
                this.emit(e.VIDEO_NODE_EVENT.SET_AUDIO_TRACK_START, {
                    videoInfo: this._videoInfo,
                    id: t,
                    userTrigger: !0
                }),
                this.hls.audioTrack = t,
                r.promise
            }
            ,
            r.prototype.setLevel = function(r) {
                var i, n, a;
                if (this.setLevelMode = r,
                r === e.SET_LEVEL_MODE.SMOOTH) {
                    var o = this.currentVideoInfo
                      , s = o.loadingUrl
                      , l = o.config
                      , c = l.p2pConfig
                      , h = l.defn
                      , u = new e.SimpleDefer;
                    return this.hls.config.externalRedundantUrls = null !== (n = null === (i = this.config.hlsjsKernelConfig) || void 0 === i ? void 0 : i.externalRedundantUrls) && void 0 !== n ? n : [],
                    this.loading.hide(),
                    null === (a = this.downloadKitController) || void 0 === a || a.changeKeyID(null == c ? void 0 : c.keyId),
                    this.emit(e.VIDEO_NODE_EVENT.SETLEVEL_START, {
                        videoInfo: this._videoInfo,
                        mode: r
                    }),
                    h ? (this._levelSwitchingDefer = u,
                    void this.setHlsPlaylistLevel(h)) : (this.hls.setLevel(s),
                    this._levelSwitchingDefer = u,
                    u.promise)
                }
                return t.prototype.setLevel.call(this, r)
            }
            ,
            r.prototype.setHlsPlaylistLevel = function(e) {
                if ("abr" !== e) {
                    var t = this._hls.levels.findIndex((function(t) {
                        return t.name === e
                    }
                    ));
                    if (-1 === t)
                        throw new Error("Defn ".concat(e, " is not found."));
                    this._hls.nextLevel = t,
                    this.updateLevelInfo({
                        currentLevel: t
                    })
                }
            }
            ,
            r.prototype.checkSetLevelOver = function(r) {
                if (this.setLevelMode !== e.SET_LEVEL_MODE.SMOOTH)
                    return t.prototype.checkSetLevelOver.call(this, r)
            }
            ,
            r.prototype.stopInner = function(r, i) {
                var n;
                this._config.clearVideoAfterStop ? this.resetSourceController() : null === (n = this._hls) || void 0 === n || n.stopLoad(),
                this.setHlsJsEvents(!1),
                this.stopDownloadKit(!!(null == i ? void 0 : i.error)),
                this.callplayAfterLoadDefer = null,
                this._config && this._videoInfo && e.NetTiming.unobserver(this._config.instanceId, {
                    tag: "".concat(this._videoInfo.uid, "_hls_clip")
                }),
                t.prototype.stopInner.call(this, r, i)
            }
            ,
            r.prototype.updateBufferRemain = function() {
                var e, t;
                if (!(null === (e = this.downloadKitController) || void 0 === e ? void 0 : e.isRunning()) || this.sourceController.getCurrentSourceType() !== Cr.Main)
                    return null;
                var r = this.videoBuffered
                  , i = this._video
                  , n = function(e, t) {
                    void 0 === t && (t = []);
                    var r = t.find((function(t) {
                        return t.start <= e && t.end >= e
                    }
                    ));
                    return r ? r.end - e : 0
                }(i.currentTime, r);
                return null === (t = this.downloadKitController) || void 0 === t ? void 0 : t.updateBuffer(n, i.currentTime)
            }
            ,
            r.prototype.isEnableABR = function() {
                var e;
                return !!(null === (e = this.config.hlsjsKernelConfig) || void 0 === e ? void 0 : e.enableAbrLevel)
            }
            ,
            r.prototype.stopDownloadKit = function(e) {
                var t, r;
                void 0 === e && (e = !1),
                null === (t = this.downloadKitTaskLoop) || void 0 === t || t.stop(),
                null === (r = this.downloadKitController) || void 0 === r || r.stop(e)
            }
            ,
            r
        }(e.BaseVideoNode)
          , Yr = Wr
          , Qr = function() {
            var e = function(t, r) {
                return e = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(e, t) {
                    e.__proto__ = t
                }
                || function(e, t) {
                    for (var r in t)
                        Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
                }
                ,
                e(t, r)
            };
            return function(t, r) {
                if ("function" != typeof r && null !== r)
                    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
                function i() {
                    this.constructor = t
                }
                e(t, r),
                t.prototype = null === r ? Object.create(r) : (i.prototype = r.prototype,
                new i)
            }
        }()
          , Xr = function(t) {
            function r() {
                return null !== t && t.apply(this, arguments) || this
            }
            return Qr(r, t),
            Object.defineProperty(r.prototype, "kernelName", {
                get: function() {
                    return e.KERNEL_NAME.HLS_JS
                },
                enumerable: !1,
                configurable: !0
            }),
            r.prototype.getHls = function() {
                var e;
                return null === (e = this._curVideoNode) || void 0 === e ? void 0 : e.hls
            }
            ,
            r.prototype.getP2P = function() {
                var e;
                return null === (e = this._curVideoNode) || void 0 === e ? void 0 : e.downloadKitController
            }
            ,
            r.prototype.setAudioTrack = function(e) {
                return this._curVideoNode.setAudioTrack(e)
            }
            ,
            r.prototype.getAudioTrack = function() {
                var e = this.getHls();
                return null == e ? void 0 : e.audioTrack
            }
            ,
            r.prototype.getAudioTracks = function() {
                var e = this.getHls();
                return null == e ? void 0 : e.audioTracks
            }
            ,
            r.prototype.createVideoNode = function(e) {
                return new Yr(e)
            }
            ,
            r
        }(e.BaseLivePlayer)
          , Zr = Xr
          , Jr = function() {
            var e = function(t, r) {
                return e = Object.setPrototypeOf || {
                    __proto__: []
                }instanceof Array && function(e, t) {
                    e.__proto__ = t
                }
                || function(e, t) {
                    for (var r in t)
                        Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
                }
                ,
                e(t, r)
            };
            return function(t, r) {
                if ("function" != typeof r && null !== r)
                    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
                function i() {
                    this.constructor = t
                }
                e(t, r),
                t.prototype = null === r ? Object.create(r) : (i.prototype = r.prototype,
                new i)
            }
        }()
          , $r = function() {
            return $r = Object.assign || function(e) {
                for (var t, r = 1, i = arguments.length; r < i; r++)
                    for (var n in t = arguments[r])
                        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e
            }
            ,
            $r.apply(this, arguments)
        }
          , ei = function(t) {
            function r(r) {
                var i, n = t.call(this, r) || this;
                return n.supportResizeEvt = !1,
                n.videoEvtHandlerMap = $r($r({}, n.videoEvtHandlerMap), ((i = {})[e.VIDEO_NODE_EVENT.VIDEO_RESIZE] = n.onVideoNodeResize.bind(n),
                i)),
                delete n.playerStatusChecker.setLevelValidator.TARGET_NOT_CHANGE,
                n
            }
            return Jr(r, t),
            r.prototype.getHls = function() {
                var e;
                return null === (e = this._curVideoNode) || void 0 === e ? void 0 : e.hls
            }
            ,
            r.prototype.getP2P = function() {
                var e;
                return null === (e = this._curVideoNode) || void 0 === e ? void 0 : e.downloadKitController
            }
            ,
            r.prototype.setAudioTrack = function(e) {
                return this._curVideoNode.setAudioTrack(e)
            }
            ,
            r.prototype.getAudioTrack = function() {
                var e = this.getHls();
                return null == e ? void 0 : e.audioTrack
            }
            ,
            r.prototype.getAudioTracks = function() {
                var e = this.getHls();
                return null == e ? void 0 : e.audioTracks
            }
            ,
            Object.defineProperty(r.prototype, "kernelName", {
                get: function() {
                    return e.KERNEL_NAME.HLS_JS
                },
                enumerable: !1,
                configurable: !0
            }),
            r.prototype.setLevelInner = function(r) {
                var i = this.decideSetLevelMode(r.setLevelMode);
                return this._logger.log("setLevelMode=".concat(i)),
                i === e.SET_LEVEL_MODE.SOFT ? t.prototype.setLevelInner.call(this, r) : this._curVideoNode.setLevel(i)
            }
            ,
            r.prototype.createVideoNode = function(e) {
                return new Yr(e)
            }
            ,
            r.prototype.onVideoNodeResize = function(e) {
                return e.data.isNative && (this.supportResizeEvt = !0),
                !0
            }
            ,
            r.prototype.decideSetLevelMode = function(t) {
                var r, i;
                if (e.uaTool.browser.harmonyTxVideo)
                    return e.SET_LEVEL_MODE.HARD;
                var n = this.config.minFragmentCountForSmoothLevelSwitching
                  , a = void 0 === n ? 3 : n;
                return !this.supportResizeEvt || this._curVideoNode.isCurrentContentDRMEncrypted() || (null === (r = this.currentVideoInfo.config) || void 0 === r ? void 0 : r.drmConfig) || this._curVideoNode.hasAltAudio() || (null === (i = this.getHls()) || void 0 === i ? void 0 : i.remainingFragmentCount) < a ? e.SET_LEVEL_MODE.HARD : t || e.SET_LEVEL_MODE.SMOOTH
            }
            ,
            r
        }(e.MultiPlayer)
          , ti = ei
          , ri = function() {
            function t() {}
            return t.register = function() {
                e.preloadEvtBus.on(e.PRELOAD_EVENT.START, t.preload),
                e.preloadEvtBus.on(e.PRELOAD_EVENT.STOP, t.stopPreload),
                e.preloadEvtBus.on(e.PRELOAD_EVENT.UPDATE, t.updatePreloadInfo)
            }
            ,
            t.unregister = function() {
                t.stopPreload(),
                e.preloadEvtBus.off(e.PRELOAD_EVENT.START, t.preload),
                e.preloadEvtBus.off(e.PRELOAD_EVENT.STOP, t.stopPreload),
                e.preloadEvtBus.off(e.PRELOAD_EVENT.UPDATE, t.updatePreloadInfo)
            }
            ,
            t.preload = function(r) {
                var i = r.data
                  , n = i.playerConfig
                  , a = i.urlConfig
                  , o = i.videoLoadParam
                  , s = i.instanceId;
                if (a) {
                    var c = a.url
                      , h = a.p2pConfig;
                    if (c && h) {
                        var u = new e.Logger(s,"p2p-preload")
                          , d = (null == n ? void 0 : n.hlsjsKernelConfig) || {}
                          , f = (null == o ? void 0 : o.startTime) || 0
                          , p = new (l())(d);
                        p.on(l().Events.MANIFEST_PARSED, (function() {
                            var e;
                            if (null === (e = p.levels[0]) || void 0 === e ? void 0 : e.details) {
                                var r = h.playerInfo
                                  , i = h.flowId
                                  , n = void 0 === i ? "" : i
                                  , a = h.keyId
                                  , o = h.useP2P
                                  , s = void 0 !== o && o
                                  , l = h.downloadMode
                                  , c = void 0 === l ? 0 : l
                                  , d = h.encoding
                                  , g = void 0 === d ? 0 : d
                                  , v = p.levels[0].details
                                  , y = v.fragments.find((function(e) {
                                    return f >= e.start && f < e.end
                                }
                                ));
                                v.fragments.forEach((function(e) {
                                    return e.ext = {
                                        keyID: a
                                    }
                                }
                                )),
                                t.stopPreload(),
                                t.p2pProxy = new Fr(r,u,(function() {}
                                )),
                                t.p2pKeyIdLastLoaded = a,
                                t.p2pProxy.createDownloadTask({
                                    keyID: a,
                                    flowID: n,
                                    startSn: Number(null == y ? void 0 : y.sn) || 0,
                                    taskType: B.Vod,
                                    useP2P: s,
                                    downloadMode: c,
                                    encoding: g
                                }, M.Preload, v),
                                u.log("success create p2p preload task")
                            }
                        }
                        )),
                        p.loadSource(c)
                    }
                }
            }
            ,
            t.stopPreload = function() {
                t.p2pProxy && (t.p2pProxy.stopDownloadTask(t.p2pKeyIdLastLoaded),
                t.p2pProxy.destroy(),
                t.p2pProxy = null)
            }
            ,
            t.updatePreloadInfo = function(e) {
                var r, i, n = e.data.remainTime, a = void 0 === n ? 0 : n;
                t.p2pProxy && (null === (i = (r = t.p2pProxy).updatePreloadRemainTime) || void 0 === i || i.call(r, a))
            }
            ,
            t
        }()
          , ii = ri
          , ni = function() {
            function t(t) {
                return t.type === e.PLAY_MODE.LIVE ? new Zr(t) : new ti(t)
            }
            return Object.defineProperty(t, "isEnvSupport", {
                get: function() {
                    return l().isSupported()
                },
                enumerable: !1,
                configurable: !0
            }),
            Object.defineProperty(t, "canPlayType", {
                get: function() {
                    return [e.VIDEO_TYPE.HLS]
                },
                enumerable: !1,
                configurable: !0
            }),
            t.register = function() {
                ii.register()
            }
            ,
            t.unregister = function() {
                ii.unregister()
            }
            ,
            Object.defineProperty(t, "exportApis", {
                get: function() {
                    return ["getHls", "setAudioTrack", "getAudioTrack", "getAudioTracks", "getP2P"]
                },
                enumerable: !1,
                configurable: !0
            }),
            t.VERSION = "1.57.5",
            t.BUILD_TIME = 1765800020830,
            t
        }();
        e.KernelFactory.registerKernel(e.KERNEL_NAME.HLS_JS, ni);
        var ai = 1765800020830
          , oi = "1.57.5"
    }(),
    window.ThumbPlayerKernelHlsjs = i
}();
